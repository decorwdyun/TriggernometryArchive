<?xml version="1.0"?>
<TriggernometryExport PluginVersion="1.2.0.735">
<ExportedFolder Id="2f8861fc-77d4-4859-9d5f-d784edfa3fe5" Name="[工具] 运行支持库" Enabled="true">
<Folders>
<Folder Id="0521ebd0-6564-46ee-bff6-4a89bfbe57b1" Name="BeepTimer" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="CountDown5" Id="46eeb4b1-4ed0-4eb1-ae43-9a0c8af32f93" RegularExpression="^(?i)cd5:(?&lt;delay&gt;[\d.]+)(?::(?&lt;duration&gt;[\d.]+))?">
<Actions>
<Action OrderNumber="1" LogMessageText="CountDown5 的延迟至少应为 4 s，实际提供了 ${delay} s。" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${delay}" ExpressionTypeL="String" ExpressionR="4" ExpressionTypeR="String" ConditionType="NumericLess" />
</Condition>
</Action>
<Action OrderNumber="2" SystemBeepFreqExpression="freq(C6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000 * ${delay} - 4000" />
<Action OrderNumber="3" SystemBeepFreqExpression="freq(D6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="4" SystemBeepFreqExpression="freq(E6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="5" SystemBeepFreqExpression="freq(G6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="6" SystemBeepFreqExpression="freq(C7)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1500" ExecutionDelayExpression="1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="CountDown4" Id="c0303324-3324-474a-a779-b7e84f10966e" RegularExpression="^(?i)cd4:(?&lt;delay&gt;[\d.]+)(?::(?&lt;duration&gt;[\d.]+))?">
<Actions>
<Action OrderNumber="1" LogMessageText="CountDown4 的延迟至少应为 3 s，实际提供了 ${delay} s。" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${delay}" ExpressionTypeL="String" ExpressionR="3" ExpressionTypeR="String" ConditionType="NumericLess" />
</Condition>
</Action>
<Action OrderNumber="2" SystemBeepFreqExpression="freq(C6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000 * ${delay} - 3000" />
<Action OrderNumber="3" SystemBeepFreqExpression="freq(E6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="4" SystemBeepFreqExpression="freq(G6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="5" SystemBeepFreqExpression="freq(C7)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1500" ExecutionDelayExpression="1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="CountDown8" Id="c6976841-9692-4edb-a1fc-5fcbbc80edbd" RegularExpression="^(?i)cd8:(?&lt;delay&gt;[\d.]+)(?::(?&lt;duration&gt;[\d.]+))?">
<Actions>
<Action OrderNumber="1" LogMessageText="CountDown8 的延迟至少应为 7 s，实际提供了 ${delay} s。" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${delay}" ExpressionTypeL="String" ExpressionR="7" ExpressionTypeR="String" ConditionType="NumericLess" />
</Condition>
</Action>
<Action OrderNumber="2" SystemBeepFreqExpression="freq(C6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000 * ${delay} - 7000" />
<Action OrderNumber="3" SystemBeepFreqExpression="freq(D6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="4" SystemBeepFreqExpression="freq(E6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="5" SystemBeepFreqExpression="freq(F6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="6" SystemBeepFreqExpression="freq(G6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="7" SystemBeepFreqExpression="freq(A6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="8" SystemBeepFreqExpression="freq(B6)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1000" ExecutionDelayExpression="1000" />
<Action OrderNumber="9" SystemBeepFreqExpression="freq(C7)" SystemBeepLengthExpression="(${duration} ?? 0.2) * 1500" ExecutionDelayExpression="1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="DelayBeep" Id="74047707-e927-4753-95f6-746559d83cf0" RegularExpression="^(?i)Beep:(?&lt;delay&gt;[\d.]+)(?::(?&lt;freq&gt;[^:]*))?(?::(?&lt;duration&gt;[^:]*))?">
<Actions>
<Action OrderNumber="1" SystemBeepFreqExpression="(${freq} ?? freq(C6))" SystemBeepLengthExpression="(${duration} ?? 200)" ExecutionDelayExpression="1000 * ${delay}" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="83bddaa3-14e0-41e9-964a-21dab502d5cf" Name="高级标点工具箱 AdvWm 旧版本 v2.x（仅兼容 即将移除）" Enabled="true">
<Folders>
<Folder Id="98302940-c3d2-496a-bf71-7cd6cb29e88a" Name="场地标点" Enabled="true">
<Folders>
<Folder Id="76ef9f94-8ac2-4b45-8fc4-80b5f837b3c1" Name="debug" Enabled="false">
<Folders />
<Triggers>
<Trigger Enabled="false" Name="测试循环标点     B：自己-B 线性    AC：自己-C 径向" Id="36a69634-0363-4e49-9a06-5fd9482fb292" RegularExpression="^.{15}\S+ 1C:Add:(?&lt;wmid&gt;\d+):.{8}:(?&lt;pn&gt;[^:]+):(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" VariableOp="SetNumeric" VariableName="1" VariableExpression="${v:1} + 1" ActionType="Variable" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="AdmWm_test_A" VariableExpression="${x}:${y}:${z}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="3" LogMessageText="AdvWm_linearConnect:start:${_me.x}:${_me.y}:${_me.z}:end:${x}:${y}:${z}:waymarkers:ABCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="4" LogMessageText="AdvWm_polarConnect:center:${v:AdmWm_test_A}:start:${_me.x}:${_me.y}:${_me.z}:end:${x}:${y}:${z}:waymarkers:BCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="2" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="5" LogMessageText="${_event}" LogProcess="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid} = 1 || ${wmid} = 2" ExpressionTypeL="Numeric" ExpressionR="1" ExpressionTypeR="Numeric" ConditionType="NumericEqual" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pn}" ExpressionTypeL="String" ExpressionR="${_me}" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Trigger>
<Trigger Enabled="false" Name="测试   A-B：线性   A-C：径向" Id="a37828c6-7a3b-4d09-9760-44f50668ea85" RegularExpression="^.{15}\S+ 1C:Add:(?&lt;wmid&gt;\d+):.{8}:(?&lt;pn&gt;[^:]+):(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="AdmWm_test_start" VariableExpression="start:${x}:${y}:${z}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="2" LogMessageText="AdvWm:linear:${v:AdmWm_test_start}:end:${x}:${y}:${z}:waymarkers:ABCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="3" LogMessageText="AdvWm:polar:center:${_me.x}:${_me.y}:${v:AdmWm_test_start}:end:${x}:${y}:${z}:waymarkers:ABCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="2" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pn}" ExpressionTypeL="String" ExpressionR="${_me}" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Trigger>
</Triggers>
</Folder>
<Folder Id="4a971f72-8531-40f6-9f86-96ec5ae78a0b" Name="恢复 / 清空标点" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Load 队列" Id="bb89dbbe-7a44-405f-b105-40f59074618b" RegularExpression="^AdvWm_loadQueue:(?&lt;t&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="本触发器会被所有标点指令打断" DescriptionOverride="True" />
<Action OrderNumber="2" NamedCallbackName="place" NamedCallbackParam="load" ActionType="NamedCallback" ExecutionDelayExpression="(${t}) * 1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Load" Id="3005217d-f20c-47d1-a4db-c36083b9a584" RegularExpression="^AdvWm_load$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="place" NamedCallbackParam="load" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Clear" Id="aabbeef9-ec8e-494a-b6e3-60c64cf58451" RegularExpression="^AdvWm_clear$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="place" NamedCallbackParam="{&#xD;&#xA;  &quot;A&quot;:{}, &#xD;&#xA;  &quot;B&quot;:{}, &#xD;&#xA;  &quot;C&quot;:{}, &#xD;&#xA;  &quot;D&quot;:{}, &#xD;&#xA;  &quot;One&quot;:{}, &#xD;&#xA;  &quot;Two&quot;:{}, &#xD;&#xA;  &quot;Three&quot;:{}, &#xD;&#xA;  &quot;Four&quot;:{}&#xD;&#xA;}" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Clear 队列" Id="ccc164eb-272e-4f6a-a879-6a8c6a0eafc3" RegularExpression="^AdvWm_clearQueue:(?&lt;t&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="本触发器会被所有标点指令打断" DescriptionOverride="True" />
<Action OrderNumber="2" NamedCallbackName="place" NamedCallbackParam="{&#xD;&#xA;  &quot;A&quot;:{}, &#xD;&#xA;  &quot;B&quot;:{}, &#xD;&#xA;  &quot;C&quot;:{}, &#xD;&#xA;  &quot;D&quot;:{}, &#xD;&#xA;  &quot;One&quot;:{}, &#xD;&#xA;  &quot;Two&quot;:{}, &#xD;&#xA;  &quot;Three&quot;:{}, &#xD;&#xA;  &quot;Four&quot;:{}&#xD;&#xA;}" ActionType="NamedCallback" ExecutionDelayExpression="(${t}) * 1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="转发排队" Id="b2272be0-36a9-4875-b6e4-d106c2b35f74" RegularExpression="^AdvWm_(?&lt;type&gt;clear|load):(?&lt;t&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="用这个转发，以免同时执行一条标点和一条排队取消时，后者立刻被前者打断" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="AdvWm_${type}Queue:${n: max(0, ${t} - 0.5) }" LogProcess="True" ActionType="LogMessage" ExecutionDelayExpression="${t} &gt; 0.5 ? 0.5 : ${t}" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="cd4f3430-0630-496e-b213-6e91b488e47f" Name="本地标点转为网络标点" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="本地标点转为网络标点" Id="af82ef69-660a-4afc-a466-40eee555e66b" RegularExpression="^AdvWm_public$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="command" NamedCallbackParam="/waymark save 30" ActionType="NamedCallback" />
<Action OrderNumber="2" NamedCallbackName="command" NamedCallbackParam="/waymark preset 30" ActionType="NamedCallback" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="如果你无论如何一定想在 30 号位置存自己的标点，把上面两个 30 换成你不用的槽位。" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Name="径向插值标点 polarConnect" Id="942baafa-973f-4100-9943-6b85decc56df" RegularExpression="^AdvWm_polarConnect:[Cc]enter:(?&lt;xc&gt;[^:]+):(?&lt;yc&gt;[^:]+)(?::[^:]+)?:[Ss]tart:(?&lt;x0&gt;[^:]+):(?&lt;y0&gt;[^:]+):(?&lt;z0&gt;[^:]+):[Ee]nd:(?&lt;x1&gt;[^:]+):(?&lt;y1&gt;[^:]+):(?&lt;z1&gt;[^:]+):[Ww]aymarkers:(?&lt;wm&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="bb89dbbe-7a44-405f-b105-40f59074618b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="ccc164eb-272e-4f6a-a879-6a8c6a0eafc3" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Description="初始化" DescriptionOverride="True" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_len" VariableExpression="${f:length:${wm}}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" DictVariableOp="Build" DictVariableTarget="AdvWm_WmMapping" DictVariableValue="=,A=A,B=B,C=C,D=D,1=One,2=Two,3=Three,4=Four" DictTargetPersist="True" ActionType="DictVariable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pd:AdvWm_WmMapping.size}" ExpressionTypeL="String" ExpressionR="8" ExpressionTypeR="String" ConditionType="NumericNotEqual" />
</Condition>
</Action>
<Action OrderNumber="6" ActionType="Placeholder" Description="极坐标转换（注：实际为不考虑高度的柱坐标系）" DescriptionOverride="True" />
<Action OrderNumber="7" VariableOp="SetNumeric" VariableName="AdvWm_r0" VariableExpression="d(${xc}, ${yc}, ${x0}, ${y0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="8" VariableOp="SetNumeric" VariableName="AdvWm_r1" VariableExpression="d(${xc}, ${yc}, ${x1}, ${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="9" VariableOp="SetNumeric" VariableName="AdvWm_θ0" VariableExpression="θ(${xc}, ${yc}, ${x0}, ${y0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="10" VariableOp="SetNumeric" VariableName="AdvWm_θ1" VariableExpression="θ(${xc}, ${yc}, ${x1}, ${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="11" VariableOp="SetNumeric" VariableName="AdvWm_θ1" VariableExpression="relθ(${v:AdvWm_θ0}, ${v:AdvWm_θ1}) + ${v:AdvWm_θ0}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" ActionType="Placeholder" Description="wm 拆分为列表   转换为标点名" DescriptionOverride="True" />
<Action OrderNumber="13" ListVariableOp="SetAll" ListVariableName="AdvWm_polar" ListVariableExpression="${pd:AdvWm_WmMapping[${f:slice(${n:${_idx}-1}):${wm}}]}" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="14" ActionType="Placeholder" Description="计算所有半径和角度" DescriptionOverride="True" />
<Action OrderNumber="15" ListVariableOp="SetAll" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_r" ListVariableExpression="((${v:AdvWm_len} - ${_idx}) * ${v:AdvWm_r0} + (${_idx} - 1) * ${v:AdvWm_r1}) / (${v:AdvWm_len} - 1)" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="16" ListVariableOp="SetAll" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_θ" ListVariableExpression="((${v:AdvWm_len} - ${_idx}) * ${v:AdvWm_θ0} + (${_idx} - 1) * ${v:AdvWm_θ1}) / (${v:AdvWm_len} - 1)" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="17" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="18" ListVariableOp="SetAll" ListVariableName="AdvWm_polar" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;: ${n: ${xc} + ${l:AdvWm_r[${_idx}]} * sin(${l:AdvWm_θ[${_idx}]})}, &#xD;&#xA;    &quot;Z&quot;: ${n: ${yc} + ${l:AdvWm_r[${_idx}]} * cos(${l:AdvWm_θ[${_idx}]})}, &#xD;&#xA;    &quot;Y&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${z0} + (${_idx} - 1) * ${z1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Active&quot;: true&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="19" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="20" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_polar.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wm}" ExpressionTypeL="String" ExpressionR="[A-D1-4]{2,8}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="绝对坐标标点 abs" Id="c69f3124-ac3f-4c85-b34d-38d6ee82c893" RegularExpression="^AdvWm_abs(?&lt;A&gt;:A:(?&lt;xa&gt;[^:]*):(?&lt;ya&gt;[^:]*):(?&lt;za&gt;[^:]*):(?&lt;aa&gt;[^:]*))?(?&lt;B&gt;:B:(?&lt;xb&gt;[^:]*):(?&lt;yb&gt;[^:]*):(?&lt;zb&gt;[^:]*):(?&lt;ab&gt;[^:]*))?(?&lt;C&gt;:C:(?&lt;xc&gt;[^:]*):(?&lt;yc&gt;[^:]*):(?&lt;zc&gt;[^:]*):(?&lt;ac&gt;[^:]*))?(?&lt;D&gt;:D:(?&lt;xd&gt;[^:]*):(?&lt;yd&gt;[^:]*):(?&lt;zd&gt;[^:]*):(?&lt;ad&gt;[^:]*))?(?&lt;One&gt;:One:(?&lt;x1&gt;[^:]*):(?&lt;y1&gt;[^:]*):(?&lt;z1&gt;[^:]*):(?&lt;a1&gt;[^:]*))?(?&lt;Two&gt;:Two:(?&lt;x2&gt;[^:]*):(?&lt;y2&gt;[^:]*):(?&lt;z2&gt;[^:]*):(?&lt;a2&gt;[^:]*))?(?&lt;Three&gt;:Three:(?&lt;x3&gt;[^:]*):(?&lt;y3&gt;[^:]*):(?&lt;z3&gt;[^:]*):(?&lt;a3&gt;[^:]*))?(?&lt;Four&gt;:Four:(?&lt;x4&gt;[^:]*):(?&lt;y4&gt;[^:]*):(?&lt;z4&gt;[^:]*):(?&lt;a4&gt;[^:]*))?$">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="bb89dbbe-7a44-405f-b105-40f59074618b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="ccc164eb-272e-4f6a-a879-6a8c6a0eafc3" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" VariableOp="SetNumeric" VariableName="AdvWm_x_A" VariableExpression="(${xa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_y_A" VariableExpression="(${ya})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" VariableOp="SetNumeric" VariableName="AdvWm_z_A" VariableExpression="(${za})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="6" VariableOp="SetNumeric" VariableName="AdvWm_a_A" VariableExpression="(${aa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="7" VariableOp="SetNumeric" VariableName="AdvWm_x_B" VariableExpression="(${xb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="8" VariableOp="SetNumeric" VariableName="AdvWm_y_B" VariableExpression="(${yb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="9" VariableOp="SetNumeric" VariableName="AdvWm_z_B" VariableExpression="(${zb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="10" VariableOp="SetNumeric" VariableName="AdvWm_a_B" VariableExpression="(${ab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="11" VariableOp="SetNumeric" VariableName="AdvWm_x_C" VariableExpression="(${xc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" VariableOp="SetNumeric" VariableName="AdvWm_y_C" VariableExpression="(${yc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="13" VariableOp="SetNumeric" VariableName="AdvWm_z_C" VariableExpression="(${zc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="14" VariableOp="SetNumeric" VariableName="AdvWm_a_C" VariableExpression="(${ac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="15" VariableOp="SetNumeric" VariableName="AdvWm_x_D" VariableExpression="(${xd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="16" VariableOp="SetNumeric" VariableName="AdvWm_y_D" VariableExpression="(${yd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="17" VariableOp="SetNumeric" VariableName="AdvWm_z_D" VariableExpression="(${zd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="18" VariableOp="SetNumeric" VariableName="AdvWm_a_D" VariableExpression="(${ad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="19" VariableOp="SetNumeric" VariableName="AdvWm_x_One" VariableExpression="(${x1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="20" VariableOp="SetNumeric" VariableName="AdvWm_y_One" VariableExpression="(${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="SetNumeric" VariableName="AdvWm_z_One" VariableExpression="(${z1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" VariableOp="SetNumeric" VariableName="AdvWm_a_One" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="SetNumeric" VariableName="AdvWm_x_Two" VariableExpression="(${x2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="24" VariableOp="SetNumeric" VariableName="AdvWm_y_Two" VariableExpression="(${y2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="25" VariableOp="SetNumeric" VariableName="AdvWm_z_Two" VariableExpression="(${z2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="26" VariableOp="SetNumeric" VariableName="AdvWm_a_Two" VariableExpression="(${a2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="27" VariableOp="SetNumeric" VariableName="AdvWm_x_Three" VariableExpression="(${x3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="28" VariableOp="SetNumeric" VariableName="AdvWm_y_Three" VariableExpression="(${y3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="29" VariableOp="SetNumeric" VariableName="AdvWm_z_Three" VariableExpression="(${z3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="30" VariableOp="SetNumeric" VariableName="AdvWm_a_Three" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="31" VariableOp="SetNumeric" VariableName="AdvWm_x_Four" VariableExpression="(${x4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="32" VariableOp="SetNumeric" VariableName="AdvWm_y_Four" VariableExpression="(${y4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="33" VariableOp="SetNumeric" VariableName="AdvWm_z_Four" VariableExpression="(${z4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="34" VariableOp="SetNumeric" VariableName="AdvWm_a_Four" VariableExpression="(${a4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="35" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="36" ListVariableOp="Build" ListVariableExpression=",A,B,C,D,One,Two,Three,Four" ListVariableTarget="AdvWm_abs" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="37" ListVariableOp="Filter" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_abs" ListVariableExpression="${f:length:${${_this}}} != 0" ListVariableTarget="AdvWm_abs" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="38" ListVariableOp="SetAll" ListVariableName="AdvWm_abs" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;:${var:AdvWm_x_${_this}}, &#xD;&#xA;    &quot;Y&quot;:${var:AdvWm_z_${_this}}, &#xD;&#xA;    &quot;Z&quot;:${var:AdvWm_y_${_this}}, &#xD;&#xA;    &quot;Active&quot;:${var:AdvWm_a_${_this}}&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="39" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="40" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_abs.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="41" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="42" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="43" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="线性插值标点 linearConnect" Id="4ead44d2-7689-4382-bf5f-2e4f76dd18d2" RegularExpression="^AdvWm_linearConnect:[Ss]tart:(?&lt;x0&gt;[^:]+):(?&lt;y0&gt;[^:]+):(?&lt;z0&gt;[^:]+):[Ee]nd:(?&lt;x1&gt;[^:]+):(?&lt;y1&gt;[^:]+):(?&lt;z1&gt;[^:]+):[Ww]aymarkers:(?&lt;wm&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="bb89dbbe-7a44-405f-b105-40f59074618b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="ccc164eb-272e-4f6a-a879-6a8c6a0eafc3" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Description="初始化" DescriptionOverride="True" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_len" VariableExpression="${f:length:${wm}}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" DictVariableOp="Build" DictVariableTarget="AdvWm_WmMapping" DictVariableValue="=,A=A,B=B,C=C,D=D,1=One,2=Two,3=Three,4=Four" DictTargetPersist="True" ActionType="DictVariable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pd:AdvWm_WmMapping.size}" ExpressionTypeL="String" ExpressionR="8" ExpressionTypeR="String" ConditionType="NumericNotEqual" />
</Condition>
</Action>
<Action OrderNumber="6" ActionType="Placeholder" Description="wm 拆分为列表   转换为标点名" DescriptionOverride="True" />
<Action OrderNumber="7" ListVariableOp="SetAll" ListVariableName="AdvWm_linear" ListVariableExpression="${pd:AdvWm_WmMapping[${f:slice(${n:${_idx}-1}):${wm}}]}" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="8" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="9" ListVariableOp="SetAll" ListVariableName="AdvWm_linear" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${x0} + (${_idx} - 1) * ${x1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Z&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${y0} + (${_idx} - 1) * ${y1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Y&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${z0} + (${_idx} - 1) * ${z1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Active&quot;: true&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="10" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="11" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_linear.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="13" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="14" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wm}" ExpressionTypeL="String" ExpressionR="[A-D1-4]{2,8}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="旋转矩阵标点 rotate" Id="3d0cc684-9934-4457-b1d5-8796f9536728" RegularExpression="^AdvWm_rotate(?::[Ss]cale:(?&lt;scale&gt;[^:]*))?(?::θ:(?&lt;theta&gt;[^:]*))?(?::[Cc]enter:(?&lt;x0&gt;[^:]*):(?&lt;y0&gt;[^:]*):(?&lt;z0&gt;[^:]*))?(?&lt;A&gt;:A:(?&lt;xa&gt;[^:]*):(?&lt;ya&gt;[^:]*):(?&lt;za&gt;[^:]*):(?&lt;aa&gt;[^:]*))?(?&lt;B&gt;:B:(?&lt;xb&gt;[^:]*):(?&lt;yb&gt;[^:]*):(?&lt;zb&gt;[^:]*):(?&lt;ab&gt;[^:]*))?(?&lt;C&gt;:C:(?&lt;xc&gt;[^:]*):(?&lt;yc&gt;[^:]*):(?&lt;zc&gt;[^:]*):(?&lt;ac&gt;[^:]*))?(?&lt;D&gt;:D:(?&lt;xd&gt;[^:]*):(?&lt;yd&gt;[^:]*):(?&lt;zd&gt;[^:]*):(?&lt;ad&gt;[^:]*))?(?&lt;One&gt;:One:(?&lt;x1&gt;[^:]*):(?&lt;y1&gt;[^:]*):(?&lt;z1&gt;[^:]*):(?&lt;a1&gt;[^:]*))?(?&lt;Two&gt;:Two:(?&lt;x2&gt;[^:]*):(?&lt;y2&gt;[^:]*):(?&lt;z2&gt;[^:]*):(?&lt;a2&gt;[^:]*))?(?&lt;Three&gt;:Three:(?&lt;x3&gt;[^:]*):(?&lt;y3&gt;[^:]*):(?&lt;z3&gt;[^:]*):(?&lt;a3&gt;[^:]*))?(?&lt;Four&gt;:Four:(?&lt;x4&gt;[^:]*):(?&lt;y4&gt;[^:]*):(?&lt;z4&gt;[^:]*):(?&lt;a4&gt;[^:]*))?$">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="bb89dbbe-7a44-405f-b105-40f59074618b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="ccc164eb-272e-4f6a-a879-6a8c6a0eafc3" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Description="本触发器为带有旋转角度的标点函数，以 给定的各组坐标偏移 与 给定角度对应的旋转矩阵 分别相乘得到各组实际坐标，并以计算结果调用鲶鱼精邮差场地标点。" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Description="格式：AdvWm_rotate:θ:-3.14:Center:100:100:0:A:0:-10:0:1:B:10:0:0:1:C:...:D:...:One:...:Two:...:Three:...:Four:..." DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="7" ActionType="Placeholder" Description="θ: 作为相对北的参照物所处的坐标的 atan2(dx, dy) 值，即从绝对正北开始逆时针一周 -pi 至 pi" DescriptionOverride="True" />
<Action OrderNumber="8" ActionType="Placeholder" Description="Center：场中心坐标，作为旋转中心。需要 (x0, y0, z0) 三个数值。" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Description="A/B/C/D/One/Two/Three/Four: 四个值：(dx, dy, dz, isActive)。其中坐标偏移以相对中心、相对方向为正北时的参考系计算。如以参照物为正北（正上）" DescriptionOverride="True" />
<Action OrderNumber="10" ActionType="Placeholder" Description="如以参照物为正北（正上）时，位于场地中心左 5 下 2 的 A 点，可以记为 “A:-5:2:0:1”" DescriptionOverride="True" />
<Action OrderNumber="11" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="12" ActionType="Placeholder" Description="可以缺少整组数据（如 B:xB:yB:zB:isActiveB 整组省略），但剩余组要按顺序。" DescriptionOverride="True" />
<Action OrderNumber="13" ActionType="Placeholder" Description="省略的θ、Center组将使用缺省值：-pi, (100, 100, 0), 省略某个标点组则不会修改该标点（与鲶鱼精邮差相同）。" DescriptionOverride="True" />
<Action OrderNumber="14" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="15" ActionType="Placeholder" Description="也可以缺少单个数据，但要保留冒号，如前文“A:-5:2:0:1”可以记做“A:-5:2::1”，场地中心的 3 点可记做“Three::::1”。" DescriptionOverride="True" />
<Action OrderNumber="16" ActionType="Placeholder" Description="省略的参数将使用缺省值：x0 = 100, y0 = 100, z0 = 0, θ = -pi, 标点的四个参数均为 0" DescriptionOverride="True" />
<Action OrderNumber="17" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="18" VariableOp="SetNumeric" VariableName="AdvWm_θ" VariableExpression="${theta} ?? -pi" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="19" VariableOp="SetNumeric" VariableName="AdvWm_x0" VariableExpression="${x0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="20" VariableOp="SetNumeric" VariableName="AdvWm_y0" VariableExpression="${y0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="SetNumeric" VariableName="AdvWm_z0" VariableExpression="(${z0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" VariableOp="SetNumeric" VariableName="AdvWm_x_A" VariableExpression="(${xa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="SetNumeric" VariableName="AdvWm_y_A" VariableExpression="(${ya})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="24" VariableOp="SetNumeric" VariableName="AdvWm_z_A" VariableExpression="(${za})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="25" VariableOp="SetNumeric" VariableName="AdvWm_a_A" VariableExpression="(${aa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="26" VariableOp="SetNumeric" VariableName="AdvWm_x_B" VariableExpression="(${xb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="27" VariableOp="SetNumeric" VariableName="AdvWm_y_B" VariableExpression="(${yb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="28" VariableOp="SetNumeric" VariableName="AdvWm_z_B" VariableExpression="(${zb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="29" VariableOp="SetNumeric" VariableName="AdvWm_a_B" VariableExpression="(${ab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="30" VariableOp="SetNumeric" VariableName="AdvWm_x_C" VariableExpression="(${xc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="31" VariableOp="SetNumeric" VariableName="AdvWm_y_C" VariableExpression="(${yc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="32" VariableOp="SetNumeric" VariableName="AdvWm_z_C" VariableExpression="(${zc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="33" VariableOp="SetNumeric" VariableName="AdvWm_a_C" VariableExpression="(${ac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="34" VariableOp="SetNumeric" VariableName="AdvWm_x_D" VariableExpression="(${xd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="35" VariableOp="SetNumeric" VariableName="AdvWm_y_D" VariableExpression="(${yd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="36" VariableOp="SetNumeric" VariableName="AdvWm_z_D" VariableExpression="(${zd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="37" VariableOp="SetNumeric" VariableName="AdvWm_a_D" VariableExpression="(${ad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="38" VariableOp="SetNumeric" VariableName="AdvWm_x_One" VariableExpression="(${x1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="39" VariableOp="SetNumeric" VariableName="AdvWm_y_One" VariableExpression="(${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="40" VariableOp="SetNumeric" VariableName="AdvWm_z_One" VariableExpression="(${z1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="41" VariableOp="SetNumeric" VariableName="AdvWm_a_One" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="42" VariableOp="SetNumeric" VariableName="AdvWm_x_Two" VariableExpression="(${x2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="43" VariableOp="SetNumeric" VariableName="AdvWm_y_Two" VariableExpression="(${y2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="44" VariableOp="SetNumeric" VariableName="AdvWm_z_Two" VariableExpression="(${z2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="45" VariableOp="SetNumeric" VariableName="AdvWm_a_Two" VariableExpression="(${a2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="46" VariableOp="SetNumeric" VariableName="AdvWm_x_Three" VariableExpression="(${x3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="47" VariableOp="SetNumeric" VariableName="AdvWm_y_Three" VariableExpression="(${y3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="48" VariableOp="SetNumeric" VariableName="AdvWm_z_Three" VariableExpression="(${z3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="49" VariableOp="SetNumeric" VariableName="AdvWm_a_Three" VariableExpression="(${a3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="50" VariableOp="SetNumeric" VariableName="AdvWm_x_Four" VariableExpression="(${x4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="51" VariableOp="SetNumeric" VariableName="AdvWm_y_Four" VariableExpression="(${y4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="52" VariableOp="SetNumeric" VariableName="AdvWm_z_Four" VariableExpression="(${z4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="53" VariableOp="SetNumeric" VariableName="AdvWm_a_Four" VariableExpression="(${a4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="54" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="55" ListVariableOp="Build" ListVariableExpression=",A,B,C,D,One,Two,Three,Four" ListVariableTarget="AdvWm_rotate" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="56" ListVariableOp="Filter" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_rotate" ListVariableExpression="${f:length:${${_this}}} != 0" ListVariableTarget="AdvWm_rotate" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="57" ListVariableOp="SetAll" ListVariableName="AdvWm_rotate" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;:${n: ${var:AdvWm_x0} + (${scale} ?? 1) * (- ${var:AdvWm_x_${_this}}*cos(${var:AdvWm_θ}) - ${var:AdvWm_y_${_this}}*sin(${var:AdvWm_θ}))}, &#xD;&#xA;    &quot;Y&quot;:${n: ${var:AdvWm_z0} + (${scale} ?? 1) * ${var:AdvWm_z_${_this}}}, &#xD;&#xA;    &quot;Z&quot;:${n: ${var:AdvWm_y0} + (${scale} ?? 1) * (+ ${var:AdvWm_x_${_this}}*sin(${var:AdvWm_θ}) - ${var:AdvWm_y_${_this}}*cos(${var:AdvWm_θ}))}, &#xD;&#xA;    &quot;Active&quot;:${var:AdvWm_a_${_this}}&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="58" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="59" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_rotate.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="60" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="61" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="62" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="极坐标标点 polarDeg / polarRad" Id="961c2c84-67ba-44b9-a252-faefc8124211" RegularExpression="^AdvWm_polar(?&lt;type&gt;Deg|Rad)(?::[Ss]cale:(?&lt;scale&gt;[^:]*))?(?::θ:(?&lt;theta&gt;[^:]*))?(?::[Cc]enter:(?&lt;x0&gt;[^:]*):(?&lt;y0&gt;[^:]*):(?&lt;z0&gt;[^:]*))?(?&lt;A&gt;:A:(?&lt;ra&gt;[^:]*):(?&lt;thetaa&gt;[^:]*):(?&lt;za&gt;[^:]*):(?&lt;aa&gt;[^:]*))?(?&lt;B&gt;:B:(?&lt;rb&gt;[^:]*):(?&lt;thetab&gt;[^:]*):(?&lt;zb&gt;[^:]*):(?&lt;ab&gt;[^:]*))?(?&lt;C&gt;:C:(?&lt;rc&gt;[^:]*):(?&lt;thetac&gt;[^:]*):(?&lt;zc&gt;[^:]*):(?&lt;ac&gt;[^:]*))?(?&lt;D&gt;:D:(?&lt;rd&gt;[^:]*):(?&lt;thetad&gt;[^:]*):(?&lt;zd&gt;[^:]*):(?&lt;ad&gt;[^:]*))?(?&lt;One&gt;:One:(?&lt;r1&gt;[^:]*):(?&lt;theta1&gt;[^:]*):(?&lt;z1&gt;[^:]*):(?&lt;a1&gt;[^:]*))?(?&lt;Two&gt;:Two:(?&lt;r2&gt;[^:]*):(?&lt;theta2&gt;[^:]*):(?&lt;z2&gt;[^:]*):(?&lt;a2&gt;[^:]*))?(?&lt;Three&gt;:Three:(?&lt;r3&gt;[^:]*):(?&lt;theta3&gt;[^:]*):(?&lt;z3&gt;[^:]*):(?&lt;a3&gt;[^:]*))?(?&lt;Four&gt;:Four:(?&lt;r4&gt;[^:]*):(?&lt;theta4&gt;[^:]*):(?&lt;z4&gt;[^:]*):(?&lt;a4&gt;[^:]*))?$">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="bb89dbbe-7a44-405f-b105-40f59074618b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="ccc164eb-272e-4f6a-a879-6a8c6a0eafc3" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" VariableOp="SetNumeric" VariableName="AdvWm_dθ" VariableExpression="(${theta} ?? -pi) + pi" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_x0" VariableExpression="${x0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" VariableOp="SetNumeric" VariableName="AdvWm_y0" VariableExpression="${y0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="6" VariableOp="SetNumeric" VariableName="AdvWm_z0" VariableExpression="(${z0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="7" VariableOp="SetNumeric" VariableName="AdvWm_r_A" VariableExpression="(${ra})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="8" VariableOp="SetNumeric" VariableName="AdvWm_θ_A" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetaa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="9" VariableOp="SetNumeric" VariableName="AdvWm_z_A" VariableExpression="(${za})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="10" VariableOp="SetNumeric" VariableName="AdvWm_a_A" VariableExpression="(${aa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="11" VariableOp="SetNumeric" VariableName="AdvWm_r_B" VariableExpression="(${rb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" VariableOp="SetNumeric" VariableName="AdvWm_θ_B" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="13" VariableOp="SetNumeric" VariableName="AdvWm_z_B" VariableExpression="(${zb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="14" VariableOp="SetNumeric" VariableName="AdvWm_a_B" VariableExpression="(${ab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="15" VariableOp="SetNumeric" VariableName="AdvWm_r_C" VariableExpression="(${rc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="16" VariableOp="SetNumeric" VariableName="AdvWm_θ_C" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="17" VariableOp="SetNumeric" VariableName="AdvWm_z_C" VariableExpression="(${zc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="18" VariableOp="SetNumeric" VariableName="AdvWm_a_C" VariableExpression="(${ac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="19" VariableOp="SetNumeric" VariableName="AdvWm_r_D" VariableExpression="(${rd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="20" VariableOp="SetNumeric" VariableName="AdvWm_θ_D" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="SetNumeric" VariableName="AdvWm_z_D" VariableExpression="(${zd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" VariableOp="SetNumeric" VariableName="AdvWm_a_D" VariableExpression="(${ad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="SetNumeric" VariableName="AdvWm_r_One" VariableExpression="(${r1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="24" VariableOp="SetNumeric" VariableName="AdvWm_θ_One" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="25" VariableOp="SetNumeric" VariableName="AdvWm_z_One" VariableExpression="(${z1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="26" VariableOp="SetNumeric" VariableName="AdvWm_a_One" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="27" VariableOp="SetNumeric" VariableName="AdvWm_r_Two" VariableExpression="(${r2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="28" VariableOp="SetNumeric" VariableName="AdvWm_θ_Two" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="29" VariableOp="SetNumeric" VariableName="AdvWm_z_Two" VariableExpression="(${z2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="30" VariableOp="SetNumeric" VariableName="AdvWm_a_Two" VariableExpression="(${a2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="31" VariableOp="SetNumeric" VariableName="AdvWm_r_Three" VariableExpression="(${r3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="32" VariableOp="SetNumeric" VariableName="AdvWm_θ_Three" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="33" VariableOp="SetNumeric" VariableName="AdvWm_z_Three" VariableExpression="(${z3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="34" VariableOp="SetNumeric" VariableName="AdvWm_a_Three" VariableExpression="(${a3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="35" VariableOp="SetNumeric" VariableName="AdvWm_r_Four" VariableExpression="(${r4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="36" VariableOp="SetNumeric" VariableName="AdvWm_θ_Four" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="37" VariableOp="SetNumeric" VariableName="AdvWm_z_Four" VariableExpression="(${z4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="38" VariableOp="SetNumeric" VariableName="AdvWm_a_Four" VariableExpression="(${a4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="39" Enabled="False" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="40" ListVariableOp="Build" ListVariableExpression=",A,B,C,D,One,Two,Three,Four" ListVariableTarget="AdvWm_polar" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="41" ListVariableOp="Filter" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_polar" ListVariableExpression="${f:length:${${_this}}} != 0" ListVariableTarget="AdvWm_polar" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="42" ListVariableOp="SetAll" ListVariableName="AdvWm_polar" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;: ${n: ${v:AdvWm_x0} + (${scale} ?? 1) * ${v:AdvWm_r_${_this}} * sin(${v:AdvWm_θ_${_this}} + ${v:AdvWm_dθ}) }, &#xD;&#xA;    &quot;Y&quot;: ${n: ${v:AdvWm_z0} + (${scale} ?? 1) * ${v:AdvWm_z_${_this}} }, &#xD;&#xA;    &quot;Z&quot;: ${n: ${v:AdvWm_y0} + (${scale} ?? 1) * ${v:AdvWm_r_${_this}} * cos(${v:AdvWm_θ_${_this}} + ${v:AdvWm_dθ}) }, &#xD;&#xA;    &quot;Active&quot;: ${v:AdvWm_a_${_this}}&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="43" Enabled="False" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="44" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_polar.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="45" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="46" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="47" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="84c6ac8d-5002-495b-bcb9-1a38809b79a5" Name="实体标点" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="清空标点（网络） networkClear" Id="8b6b9e31-e3a1-49e3-b1da-7c8a72bcbbdc" RegularExpression="^AdvHm_networkClear:(?&lt;orders&gt;[1-8]+)">
<Actions>
<Action OrderNumber="1" ListVariableOp="SetAll" ListVariableName="AdvHm_clearAll" ListVariableExpression="    { &quot;c&quot;: &quot;command&quot;, &quot;p&quot;: &quot;/mk clear &lt;${f:slice(${_idx}):0${orders}}&gt;&quot; }" ListVariableIndex="${f:length:${orders}}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="AdvHm_clearAll" VariableExpression="[&#xD;&#xA;${l:AdvHm_clearAll.join(&quot;,⏎&quot;)}&#xD;&#xA;]" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="3" NamedCallbackName="queue" NamedCallbackParam="${v:AdvHm_clearAll}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="AdvHm_clearAll" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" ListVariableName="AdvHm_clearAll" ActionType="ListVariable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="清空标点（本地） localClear" Id="ed5c3a46-0047-46ee-8a6b-0b96b7c906e8" RegularExpression="^AdvHm_localClear:(?!all$)(?&lt;listname&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" ListVariableOp="SetAll" ListVariableName="AdvHm_clearAll" ListVariableExpression="    {&#xD;&#xA;        &quot;c&quot;: &quot;mark&quot;,&#xD;&#xA;        &quot;p&quot;: &quot;{\&quot;Name\&quot;: \&quot;${l:${listname}[${_idx}]}\&quot;, \&quot;MarkType\&quot;: \&quot;0\&quot;, \&quot;LocalOnly\&quot;: 1}&quot;&#xD;&#xA;    }" ListVariableIndex="${l:${listname}.size}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="AdvHm_clearAll" VariableExpression="[&#xD;&#xA;${l:AdvHm_clearAll.join(&quot;,⏎&quot;)}&#xD;&#xA;]" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="3" NamedCallbackName="queue" NamedCallbackParam="${v:AdvHm_clearAll}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="AdvHm_clearAll" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" ListVariableName="AdvHm_clearAll" ActionType="ListVariable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="清空全部标点（本地） localClear:all" Id="d0064dc4-9e1e-409d-9803-5241aaa2d56f" RegularExpression="^AdvHm_localClear:all(?::id:(?&lt;id&gt;.+))?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="指定一个实体 ID，对其遍历执行所有标点后清除标点。ID 未提供时默认为自己。" DescriptionOverride="True" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_id" VariableExpression="0x${_me.id}" ActionType="Variable">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${id}" ExpressionTypeL="String" ExpressionR="[14]0.{6}" ExpressionTypeR="String" ConditionType="RegexNotMatch" />
</Condition>
</Action>
<Action OrderNumber="3" VariableOp="SetString" VariableName="tmp_id" VariableExpression="0x${id}" ActionType="Variable">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${id}" ExpressionTypeL="String" ExpressionR="[14]0.{6}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
<Action OrderNumber="4" LoopInitExpression="32" LoopIncrExpression="-1" ActionType="Loop">
<LoopCondition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${_i}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericGreaterEqual" />
</LoopCondition>
<LoopActions>
<Action OrderNumber="1" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;    &quot;ActorID&quot;: ${v:tmp_id},&#xD;&#xA;    &quot;MarkType&quot;: ${_i},&#xD;&#xA;    &quot;LocalOnly&quot;: true&#xD;&#xA;}" ActionType="NamedCallback" />
</LoopActions>
</Action>
<Action OrderNumber="5" VariableName="tmp_id" ActionType="Variable">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${id}" ExpressionTypeL="String" ExpressionR="[14]0.{6}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
</Actions>
</Trigger>
<Trigger Enabled="true" Name="单个实体标点 mark" Id="e55dd9f3-55cc-48ff-bc63-45c84aca5bd6" RegularExpression="^AdvHm_mark:(?&lt;entity&gt;[^:]+):(?&lt;marker&gt;[^:]+):(?&lt;isLocal&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" VariableOp="SetNumeric" VariableName="tmp_match" VariableExpression="1" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${entity}" ExpressionTypeL="String" ExpressionR="^[14]0[A-F0-9].{6}$" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
<Action OrderNumber="2" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;  &quot;ActorID&quot;: 0x${entity},&#xD;&#xA;  &quot;MarkType&quot;: &quot;${marker}&quot;,&#xD;&#xA;  &quot;LocalOnly&quot;: ${isLocal} &#xD;&#xA;}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_match}" ExpressionTypeL="Numeric" ExpressionR="1" ExpressionTypeR="Numeric" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;  &quot;Name&quot;: &quot;${entity}&quot;,&#xD;&#xA;  &quot;MarkType&quot;: &quot;${marker}&quot;,&#xD;&#xA;  &quot;LocalOnly&quot;: ${isLocal} &#xD;&#xA;}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_match}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="Numeric" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="4" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;  ${f:ifmatch(${entity}, '&quot;ActorID&quot;: 0x${entity}', '&quot;Name&quot;: &quot;${entity}&quot;'):[14]0[0-9A-F]｛6｝},&#xD;&#xA;  &quot;MarkType&quot;: &quot;${marker}&quot;,&#xD;&#xA;  &quot;LocalOnly&quot;: ${isLocal} &#xD;&#xA;}" ActionType="NamedCallback" />
<Action OrderNumber="5" VariableName="tmp_match" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers />
</Folder>
<Folder Id="bfe8d3aa-3aff-4cb4-bbb6-a15b13400308" Name="鲶鱼精邮差扩展 v3.6" Enabled="true" RawEnvironmentVariables="version = 3.6&#xD;&#xA;trigversion = 1.2.0.732">
<Folders>
<Folder Id="d176e430-6eb9-4f76-9b4a-03f39a82092a" Name="接收文本指令" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Scaling" Id="d174cb0e-a0eb-466b-9413-f0795fd3db50" RegularExpression="^.{15}\S+ 00:0038::scale +(?&lt;scales&gt;.+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${v:tmp_address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="ObjectScaling" NamedCallbackParam="${v:tmp_address}, ${f:replace(&quot; &quot;, &quot;,&quot;):${scales}}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="SetHighlightColor" Id="05e93714-3d61-420a-b03d-d47022950500" RegularExpression="^.{15}\S+ 00:0038::highlight (?&lt;color&gt;\d+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${v:tmp_address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="SetHighlightColor" NamedCallbackParam="${v:tmp_address}, ${color}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="SetStatusLoopVfx" Id="2d32f175-8e17-4ca0-b7b3-f8172ce3bedb" RegularExpression="^.{15}\S+ 00:0038::vfx (?&lt;vfxid&gt;.+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${v:tmp_address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="SetStatusLoopVfx" NamedCallbackParam="${v:tmp_address}, ${vfxid}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Redraw" Id="6fa6baa8-c77e-4b6b-a533-e451ce618ab3" RegularExpression="^.{15}\S+ 00:0038::redraw$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${v:tmp_address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="Redraw" NamedCallbackParam="${v:tmp_address}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="LockOn" Id="ac031878-8dd1-45d9-b4a0-45fb9dfcbdac" RegularExpression="^.{15}\S+ 00:0038::lockon (?&lt;vfxname&gt;.+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${v:tmp_address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="LockOn" NamedCallbackParam="${v:tmp_address}, ${vfxname}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Hint / Warn" Id="85293dd9-e873-4f3a-ad08-f5ced1f9c2dc" RegularExpression="^.{15}\S+ 00:0038::(?i) *(?&lt;type&gt;hint|warn) +(?&lt;t&gt;[\d.]+) (?&lt;data&gt;.+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="${f:tolower:${type}}" NamedCallbackParam="${n:${t}}&#xD;&#xA;${data}" ActionType="NamedCallback" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Quit" Id="20c0e31b-8ae0-418b-8c7c-69fc806d6abf" RegularExpression="^.{15}\S+ 00:0038::(?i) *quit *$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="quit" NamedCallbackParam="0" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="2" NamedCallbackName="quit" NamedCallbackParam="1" ActionType="NamedCallback" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Channeling" Id="085ae859-5c13-4184-abe1-15debcc0357a" RegularExpression="^.{15}\S+ 00:0038::channeling (?&lt;vfxname&gt;.+)$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="Channeling" NamedCallbackParam="${_me.address}, ${_entity[${_me.targetid}].address}, ${vfxname}" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${_entity[${_me.targetid}].address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
</Condition>
</Action>
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="95a21c69-6b1c-4711-a23c-3dc970c59e98" Name="自动刷新" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Camera" Id="06bdbafa-45d9-477f-8b5e-73bbc7ff4d9b" RegularExpression="^.{15}\S+ 01:">
<Actions>
<Action OrderNumber="1" NamedCallbackName="SetCameraParams" NamedCallbackParam="Apply" ActionType="NamedCallback" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="注册回调" Id="af21b2de-5392-42c4-aaac-cc5ca69af464" RegularExpression="^.{15}\S+ 01:" PrevActionsRefire="Deny" PeriodRefire="Deny" RefirePeriodExpression="500">
<Actions>
<Action OrderNumber="1" ExecScriptExpression="using System.Windows.Forms;&#xD;&#xA;using System.Threading;&#xD;&#xA;using Triggernometry;&#xD;&#xA;&#xD;&#xA;public bool IsCafeACT()&#xD;&#xA;{&#xD;&#xA;    Control current = RealPlugin.plug.ui;&#xD;&#xA;    while (current != null &amp;&amp; !(current is TabControl))&#xD;&#xA;    {&#xD;&#xA;        current = current.Parent;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    if (current is TabControl tabControl)&#xD;&#xA;    {&#xD;&#xA;        foreach (TabPage tabPage in tabControl.TabPages)&#xD;&#xA;        {&#xD;&#xA;            if (tabPage.Text == &quot;插件中心&quot;)&#xD;&#xA;            {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    return false;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Log(string msg) =&gt; Triggernometry.Interpreter.StaticHelpers.Log(RealPlugin.DebugLevelEnum.Warning, msg);&#xD;&#xA;void Error(string msg) =&gt; Triggernometry.Interpreter.StaticHelpers.Log(RealPlugin.DebugLevelEnum.Error, msg);&#xD;&#xA;&#xD;&#xA;if (IsCafeACT())&#xD;&#xA;{&#xD;&#xA;    Log(&quot;  不要截图到处问这是什么意思该怎么办，上面写得很清楚了。&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Log(&quot;  如果你想使用高级功能，目前已知的解决方法仅有更换呆萌整合版本。&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Log(&quot;  鲶鱼精邮差扩展无法运行，将只有基础的场地标点功能。&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Log(&quot;  由于 CafeACT 使用旧版 ACT 且未解决程序集版本冲突，&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Error(&quot;[高级标点工具箱] 检测到 CafeACT 环境。&quot;);&#xD;&#xA;    Triggernometry.RealPlugin.plug.RegisterNamedCallback(&quot;hint&quot;, new Action&lt;object, string&gt;((_, __) =&gt; { }), null, registrant: &quot;注册失败&quot;);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;if (new Version(&quot;${_pluginversion}&quot;) &lt; new Version(&quot;${env:trigversion}&quot;))&#xD;&#xA;{&#xD;&#xA;    Error(&quot;[高级标点工具箱] 当前触发器版本 ${_pluginversion}，需要更新至 ${env:trigversion}&quot;);&#xD;&#xA;}" ActionType="ExecuteScript" Asynchronous="False" Description="检测 Cafe 环境" DescriptionOverride="True" />
<Action OrderNumber="2" ExecScriptAssembliesExpression="PostNamazu, GreyMagic" ExecScriptExpression="using System;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;using System.Globalization;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Text;&#xD;&#xA;using System.Threading;&#xD;&#xA;using System.Threading.Tasks;&#xD;&#xA;using PostNamazu;&#xD;&#xA;using PostNamazu.Actions;&#xD;&#xA;using PostNamazu.Common;&#xD;&#xA;using GreyMagic;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using Triggernometry.PluginBridges;&#xD;&#xA;using System.Numerics;&#xD;&#xA;using System.Text.RegularExpressions;&#xD;&#xA;using static Triggernometry.RealPlugin;&#xD;&#xA;using static Triggernometry.Utilities.Memory;&#xD;&#xA;using Triggernometry.Variables;&#xD;&#xA;&#xD;&#xA;bool initialized = false;&#xD;&#xA;int i = 1;&#xD;&#xA;for (i = 1; i &lt;= 5; i++)&#xD;&#xA;{&#xD;&#xA;    try&#xD;&#xA;    {&#xD;&#xA;        PostNamazuExtension.Init();&#xD;&#xA;        initialized = true;&#xD;&#xA;        break;&#xD;&#xA;    }&#xD;&#xA;    catch&#xD;&#xA;    {&#xD;&#xA;        Interpreter.StaticHelpers.Log(DebugLevelEnum.Warning, $&quot;[鲶鱼精邮差扩展] 初始化失败，正在重试第 {i} / 5 次……&quot;);&#xD;&#xA;        if (i == 5) throw;&#xD;&#xA;    }&#xD;&#xA;    Thread.Sleep(i * 1000);&#xD;&#xA;}&#xD;&#xA;PostNamazuExtension.Log(i &gt; 1 ? DebugLevelEnum.Warning : DebugLevelEnum.Custom, $&quot;[鲶鱼精邮差扩展] 初始化成功。&quot;);&#xD;&#xA;&#xD;&#xA;public static class PostNamazuExtension&#xD;&#xA;{&#xD;&#xA;&#xD;&#xA;    #region Common&#xD;&#xA;&#xD;&#xA;    private static readonly string Name = &quot;PostNamazuExtension&quot;;&#xD;&#xA;&#xD;&#xA;    public static PostNamazu.PostNamazu NamazuPlugin =&gt; (PostNamazu.PostNamazu)RealPlugin.InstanceHook(null, &quot;PostNamazu.PostNamazu&quot;).pluginObj;&#xD;&#xA;    public static ExternalProcessMemory Memory =&gt; NamazuPlugin?.Memory;&#xD;&#xA;    public static SigScanner Scanner =&gt; NamazuPlugin?.SigScanner;&#xD;&#xA;    private static PostNamazuUi _postNamazuUi;&#xD;&#xA;    public static PostNamazuUi PostNamazuUi&#xD;&#xA;    {&#xD;&#xA;        get&#xD;&#xA;        {&#xD;&#xA;            if (_postNamazuUi?.Parent as TabPage == null)&#xD;&#xA;            {&#xD;&#xA;                _postNamazuUi = GetPostNamazuUi();&#xD;&#xA;            }&#xD;&#xA;            return _postNamazuUi;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static bool IsReady =&gt; Triggernometry.Interpreter.StaticHelpers.XivProcess != null &amp;&amp; Memory != null;&#xD;&#xA;&#xD;&#xA;    private static PostNamazuUi GetPostNamazuUi()&#xD;&#xA;    {&#xD;&#xA;        TabPage tp = RealPlugin.InstanceHook(null, &quot;PostNamazu.PostNamazu&quot;).TabPage;&#xD;&#xA;        return tp.Controls.OfType&lt;PostNamazuUi&gt;().FirstOrDefault();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void OnXivProcUpdate()&#xD;&#xA;    {&#xD;&#xA;        ScanSignatures();&#xD;&#xA;        DisableAfkCountDown();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void RegisterCallback(string callBackName, Action&lt;string&gt; callBackAction, IntPtr? successIndicator = null)&#xD;&#xA;    {&#xD;&#xA;        if (successIndicator == IntPtr.Zero) return;&#xD;&#xA;        Triggernometry.RealPlugin.plug.RegisterNamedCallback(&#xD;&#xA;            callBackName,&#xD;&#xA;            new Action&lt;object, string&gt;((_, cmd) =&gt; callBackAction(cmd)),&#xD;&#xA;            null,&#xD;&#xA;            registrant: Name&#xD;&#xA;        );&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void ScanSignatures()&#xD;&#xA;    {&#xD;&#xA;        ShowTextGimmickHintHelper.Scan();&#xD;&#xA;        QuitInstanceHelper.Scan();&#xD;&#xA;        EntityHelper.Scan();&#xD;&#xA;        VfxHelper.Scan();&#xD;&#xA;        EnvironmentEffectHelper.Scan();&#xD;&#xA;        CameraHelper.Scan();&#xD;&#xA;        UseActionHelper.Scan();&#xD;&#xA;        ExecuteCommandHelper.Scan();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Init()&#xD;&#xA;    {&#xD;&#xA;        OnXivProcUpdate();&#xD;&#xA;        Triggernometry.Interpreter.StaticHelpers.RegisterXivProcessUpdatedAction(Name, new System.Action(OnXivProcUpdate));&#xD;&#xA;&#xD;&#xA;        ShowTextGimmickHintHelper.Register();&#xD;&#xA;        QuitInstanceHelper.Register();&#xD;&#xA;        EntityHelper.Register();&#xD;&#xA;        VfxHelper.Register();&#xD;&#xA;        EnvironmentEffectHelper.Register();&#xD;&#xA;        CameraHelper.Register();&#xD;&#xA;        UseActionHelper.Register();&#xD;&#xA;        ExecuteCommandHelper.Register();&#xD;&#xA;        Echo($&quot;已激活：{Name} v{&quot;${env:version}&quot;}&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void CheckBeforeExecution(string command)&#xD;&#xA;    {&#xD;&#xA;        if (!IsReady)&#xD;&#xA;            throw new Exception(&quot;[鲶鱼精邮差扩展] 没有对应的 FFXIV 进程&quot;);&#xD;&#xA;&#xD;&#xA;        if (string.IsNullOrWhiteSpace(command))&#xD;&#xA;            throw new Exception(&quot;[鲶鱼精邮差扩展] 指令为空&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static void DisableAfkCountDown()&#xD;&#xA;    {&#xD;&#xA;        IntPtr ptr = TryScan(&quot;E9 ? ? ? ? F3 0F 10 53 1C&quot;, nameof(DisableAfkCountDown)) + 0x23; // 不是跳转！&#xD;&#xA;        byte[] nop = new byte[] {&#xD;&#xA;            0x90, 0x90, 0x90, 0x90, 0x90,    // F3 0F11 53 1C         - movss [rbx+1C],xmm2  副本外计时器&#xD;&#xA;            0x90, 0x90, 0x90, 0x90, 0x90     // F3 0F11 43 14         - movss [rbx+14],xmm0  副本内计时器&#xD;&#xA;        };&#xD;&#xA;        WriteBytes(XivProcHandle, ptr, (uint)nop.Length, nop);&#xD;&#xA;        Log(DebugLevelEnum.Custom, &quot;已禁用 AFK 倒计时。&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static VariableDictionary GetConfig()&#xD;&#xA;    {&#xD;&#xA;        var cfg = Triggernometry.Interpreter.StaticHelpers.GetDictVariable(true, &quot;PNE_cfg&quot;);&#xD;&#xA;        if (cfg == null)&#xD;&#xA;        {&#xD;&#xA;            cfg = new VariableDictionary();&#xD;&#xA;            Triggernometry.Interpreter.StaticHelpers.SetDictVariable(true, &quot;PNE_cfg&quot;, cfg);&#xD;&#xA;        }&#xD;&#xA;        return cfg;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    #endregion Common&#xD;&#xA;&#xD;&#xA;    public static class ShowTextGimmickHintHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr GetUiModulePtr;&#xD;&#xA;        public static IntPtr FrameworkPtrPtr;&#xD;&#xA;        public static IntPtr ShowTextGimmickHintPtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            var myName = BridgeFFXIV.GetMyself().GetValue(&quot;name&quot;).ToString();&#xD;&#xA;            FrameworkPtrPtr = TryScanMultiple(new string[] {&#xD;&#xA;                &quot;49 8B C4 48 8B 0D ? ? ? ? 48 8D 15 ? ? ? ? 48 89 05 * * * *&quot;, // 7.0 CN&#xD;&#xA;                &quot;49 8B DC 48 89 1D * * * *&quot; // 7.0 global&#xD;&#xA;            }, nameof(FrameworkPtrPtr));&#xD;&#xA;            GetUiModulePtr = TryScan(&quot;E8 * * * * 80 7B 1D 01&quot;, nameof(GetUiModulePtr));&#xD;&#xA;            ShowTextGimmickHintPtr = TryScan(&quot;48 ?? ?? 0F 84 ?? ?? ?? ?? 4C ?? ?? 49 89 5B ?? 49 89 73&quot;, nameof(ShowTextGimmickHintPtr));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            RegisterCallback(&quot;Hint&quot;, Hint);&#xD;&#xA;            RegisterCallback(&quot;Warn&quot;, Warn);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Hint(string command) =&gt; DoShowTextGimmickHint(true, command);&#xD;&#xA;        public static void Warn(string command) =&gt; DoShowTextGimmickHint(false, command);&#xD;&#xA;        public static void DoShowTextGimmickHint(bool isInfo, string command)&#xD;&#xA;        {&#xD;&#xA;            CheckBeforeExecution(command);&#xD;&#xA;&#xD;&#xA;            string rawTime = command.Substring(0, command.IndexOf('\n')).Trim();&#xD;&#xA;            if (!double.TryParse(rawTime, NumberStyles.Float, CultureInfo.InvariantCulture, out double time))&#xD;&#xA;            {&#xD;&#xA;                throw Context.ParseTypeError(&quot;string&quot;, rawTime, &quot;double&quot;, command);&#xD;&#xA;            }&#xD;&#xA;            int timeIn100Ms = Math.Max(0, (int)(time * 10));&#xD;&#xA;            string text = command.Substring(command.IndexOf('\n') + 1);&#xD;&#xA;            PostNamazuUi?.Log((isInfo ? &quot;Hint&quot; : &quot;Warn&quot;) + $&quot; ({timeIn100Ms / 10.0:F1} s): \n{text}&quot;);&#xD;&#xA;&#xD;&#xA;            ExecuteWithLock(() =&gt; {&#xD;&#xA;                _DoShowTextGimmickHint(isInfo, text, timeIn100Ms);&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void _DoShowTextGimmickHint(bool isHint, string text, int timeIn100Ms)&#xD;&#xA;        {&#xD;&#xA;            var frameworkPtr = Memory.Read&lt;IntPtr&gt;(FrameworkPtrPtr);&#xD;&#xA;            var uiModulePtr = Memory.CallInjected64&lt;IntPtr&gt;(GetUiModulePtr, frameworkPtr);&#xD;&#xA;            var raptureAtkModule = Memory.CallInjected64&lt;IntPtr&gt;(Memory.Read&lt;IntPtr&gt;(Memory.Read&lt;IntPtr&gt;(uiModulePtr) + (0x8 * 7)), uiModulePtr);&#xD;&#xA;            IntPtr stringPtr = IntPtr.Zero;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                stringPtr = Memory.AllocateMemory(1024);&#xD;&#xA;                Memory.WriteString(stringPtr, text, Encoding.UTF8);&#xD;&#xA;                Memory.CallInjected64&lt;int&gt;(ShowTextGimmickHintPtr, raptureAtkModule, stringPtr, isHint ? 1 : 0, timeIn100Ms);&#xD;&#xA;            }&#xD;&#xA;            finally { if (stringPtr != IntPtr.Zero) Memory.FreeMemory(stringPtr); }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class QuitInstanceHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr QuitInstancePtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            QuitInstancePtr = TryScan(&quot;48 83 EC ?? 0F B6 D1 45 33 C9&quot;, nameof(QuitInstancePtr));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            RegisterCallback(&quot;Quit&quot;, QuitInstance, QuitInstancePtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void QuitInstance(string cmd)&#xD;&#xA;        {&#xD;&#xA;            cmd = cmd.Trim().ToLower();&#xD;&#xA;            bool force = cmd == &quot;1&quot; || cmd == &quot;true&quot;;&#xD;&#xA;            ExecuteWithLock(() =&gt; Memory.CallInjected64&lt;IntPtr&gt;(QuitInstancePtr, force ? 1 : 0));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class EntityHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr TargetSystemPtr;&#xD;&#xA;        public static IntPtr HasStatusPtr;&#xD;&#xA;        public static IntPtr GetStatusIndexPtr;&#xD;&#xA;        public static IntPtr RemoveStatusPtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            TargetSystemPtr = TryScan(&quot;48 8D 0D * * * * E8 ? ? ? ? 48 3B C6 0F 95 C0&quot;, nameof(TargetSystemPtr));&#xD;&#xA;            HasStatusPtr = TryScan(&quot;E8 * * * * C6 43 2D 00&quot;, nameof(HasStatusPtr));&#xD;&#xA;            GetStatusIndexPtr = TryScan(&quot;E8 * * * * 85 C0 79 21&quot;, nameof(GetStatusIndexPtr));&#xD;&#xA;            RemoveStatusPtr = TryScan(&quot;83 FA 3C 73 50&quot;, nameof(RemoveStatusPtr));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            Triggernometry.Interpreter.StaticHelpers.Storage[&quot;_SetPos&quot;] = (object)_SetPos;&#xD;&#xA;            RegisterCallback(&quot;InvokeOnMultipleEntities&quot;, InvokeOnMultipleEntities);&#xD;&#xA;            RegisterCallback(&quot;SetHeading&quot;, SetHeading);&#xD;&#xA;            RegisterCallback(&quot;Target&quot;, Target, TargetSystemPtr);&#xD;&#xA;            RegisterCallback(&quot;SetModelStatus&quot;, SetModelStatus);&#xD;&#xA;            RegisterCallback(&quot;SetObjectScale&quot;, SetObjectScale);&#xD;&#xA;            RegisterCallback(&quot;ObjectScaling&quot;, ObjectScaling);&#xD;&#xA;            RegisterCallback(&quot;SetOpacity&quot;, SetOpacity);&#xD;&#xA;            RegisterCallback(&quot;SetOpacityForOtherPlayers&quot;, SetOpacityForOtherPlayers);&#xD;&#xA;            RegisterCallback(&quot;Hide&quot;, Hide);&#xD;&#xA;            RegisterCallback(&quot;HideOtherPlayers&quot;, HideOtherPlayers);&#xD;&#xA;            RegisterCallback(&quot;SetStatusLoopVfx&quot;, SetStatusLoopVfx);&#xD;&#xA;            RegisterCallback(&quot;Redraw&quot;, Redraw);&#xD;&#xA;            RegisterCallback(&quot;SetHighlightColor&quot;, SetHighlightColor);&#xD;&#xA;            RegisterCallback(&quot;RemoveStatus&quot;, RemoveStatus, RemoveStatusPtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void InvokeOnMultipleEntities(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var cmds = cmd.Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);&#xD;&#xA;            string entityFilter = cmds[0];&#xD;&#xA;            foreach (IntPtr address in Triggernometry.FFXIV.Entity.GetFilteredEntities(entityFilter).Select(e =&gt; e.Address))&#xD;&#xA;            {&#xD;&#xA;                foreach (var cbPair in cmds.Skip(1).Select(c =&gt; c.Split(new[] { ',' }, 2)))&#xD;&#xA;                {&#xD;&#xA;                    if (cbPair.Length == 1) throw new Exception($&quot;批量调用回调时未提供回调参数：{cbPair[0]}&quot;);&#xD;&#xA;                    var name = cbPair[0].Trim();&#xD;&#xA;                    var param = cbPair[1].Replace(&quot;_address&quot;, address.ToString());&#xD;&#xA;                    Task.Run(() =&gt;&#xD;&#xA;                    {&#xD;&#xA;                        try&#xD;&#xA;                        {&#xD;&#xA;                            RealPlugin.plug.InvokeNamedCallback(name, param);&#xD;&#xA;                        }&#xD;&#xA;                        catch (Exception ex)&#xD;&#xA;                        {&#xD;&#xA;                            Log(RealPlugin.DebugLevelEnum.Warning, $&quot;批量调用回调时失败：{name} -&gt; {param} \n{ex}&quot;);&#xD;&#xA;                        }&#xD;&#xA;                    });&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetHeading(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            float h = float.Parse(args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            ExecuteWithLock(() =&gt; _SetHeading(objectPtr, h));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Target(string cmd)&#xD;&#xA;        {&#xD;&#xA;            cmd = cmd.Trim().ToUpper();&#xD;&#xA;            if (cmd == &quot;E0000000&quot;)&#xD;&#xA;            {&#xD;&#xA;                _Target(IntPtr.Zero);&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;            uint id = uint.Parse(cmd, NumberStyles.HexNumber, CultureInfo.InvariantCulture);&#xD;&#xA;            var entity = Triggernometry.FFXIV.Entity.GetEntityByID(id);&#xD;&#xA;            if (!entity.Exist)&#xD;&#xA;            {&#xD;&#xA;                throw new Exception($&quot;未找到实体：{id:X}&quot;);&#xD;&#xA;            }&#xD;&#xA;            _Target(entity.Address);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetModelStatus(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            // 0: &quot;visible&quot; 正常状态&#xD;&#xA;            // 512/1024: 玩家切换地图时会经历的两种状态，类似 16384&#xD;&#xA;            // 2048: 不重绘: 有模型无名牌、列表可选；重绘：恢复 0&#xD;&#xA;            // 4096: 不重绘: 有模型无名牌、列表可选；重绘：不变，刷新模型&#xD;&#xA;            // 8192: 不重绘：有模型无名牌、不可选；重绘/移动/攻击：恢复 0&#xD;&#xA;            // 16384: 不重绘：有模型无名牌、不可选；重绘：不变，刷新模型&#xD;&#xA;            int value = (int)MathParser.Parse(args[0]);&#xD;&#xA;            ExecuteWithLock(() =&gt; _SetModelStatus(objectPtr, value));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // 新方法 直接修改实体参数并重绘&#xD;&#xA;        public static void SetObjectScale(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            float scale = float.Parse(args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            ExecuteWithLock(() =&gt; _SetObjectScale(objectPtr, scale));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // 旧方法 临时修改&#xD;&#xA;        public static void ObjectScaling(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            float scaleX = float.Parse(args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            float scaleY = float.Parse(args.Length &gt; 1 ? args[1] : args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            float scaleZ = float.Parse(args.Length &gt; 2 ? args[2] : args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            ExecuteWithLock(() =&gt; _ObjectScalingTemp(objectPtr, scaleX, scaleY, scaleZ));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetOpacity(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            float opacity = float.Parse(args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            ExecuteWithLock(() =&gt; _SetOpacity(objectPtr, opacity));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetOpacityForOtherPlayers(string cmd)&#xD;&#xA;        {&#xD;&#xA;            float opacity = float.Parse(cmd, NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            var addresses = BridgeFFXIV.GetAllEntities()&#xD;&#xA;                .Where(c =&gt; (c.GetValue(&quot;id&quot;).ToString().StartsWith(&quot;10&quot;) &amp;&amp; c.GetValue(&quot;id&quot;).ToString() != BridgeFFXIV.PlayerHexId)&#xD;&#xA;                     || c.GetValue(&quot;ownerid&quot;).ToString().StartsWith(&quot;10&quot;))&#xD;&#xA;                .Select(c =&gt; (IntPtr)long.Parse(c.GetValue(&quot;address&quot;).ToString()));&#xD;&#xA;            ExecuteWithLock(() =&gt; {&#xD;&#xA;                foreach (var address in addresses)&#xD;&#xA;                {&#xD;&#xA;                    _SetOpacity(address, opacity);&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Hide(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            bool hide = bool.TryParse(args[0].ToLower(), out hide) ? hide : (!MathParser.IsZero(MathParser.Parse(args[0])));&#xD;&#xA;            ExecuteWithLock(() =&gt; _Hide(objectPtr, hide));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void HideOtherPlayers(string cmd)&#xD;&#xA;        {&#xD;&#xA;            bool hide = bool.TryParse(cmd.ToLower(), out hide) ? hide : (!MathParser.IsZero(MathParser.Parse(cmd)));&#xD;&#xA;&#xD;&#xA;            var addresses = BridgeFFXIV.GetAllEntities()&#xD;&#xA;                .Where(c =&gt; (c.GetValue(&quot;id&quot;).ToString().StartsWith(&quot;10&quot;) &amp;&amp; c.GetValue(&quot;id&quot;).ToString() != BridgeFFXIV.PlayerHexId)&#xD;&#xA;                     || c.GetValue(&quot;ownerid&quot;).ToString().StartsWith(&quot;10&quot;))&#xD;&#xA;                .Select(c =&gt; (IntPtr)long.Parse(c.GetValue(&quot;address&quot;).ToString()));&#xD;&#xA;&#xD;&#xA;            ExecuteWithLock(() =&gt; {&#xD;&#xA;                foreach (var address in addresses)&#xD;&#xA;                {&#xD;&#xA;                    _Hide(address, hide);&#xD;&#xA;                }&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetStatusLoopVfx(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            ushort vfxId = ushort.Parse(args[0]);&#xD;&#xA;            ExecuteWithLock(() =&gt; {&#xD;&#xA;                _SetStatusLoopVfx(objectPtr, vfxId);&#xD;&#xA;                _ReDraw(objectPtr);&#xD;&#xA;            });&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Redraw(string address)&#xD;&#xA;        {&#xD;&#xA;            IntPtr entityPtr = (IntPtr)long.Parse(address);&#xD;&#xA;            ExecuteWithLock(() =&gt; _ReDraw(entityPtr));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetHighlightColor(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            byte color = byte.Parse(args[0]);&#xD;&#xA;            ExecuteWithLock(() =&gt; _SetHighlightColor(objectPtr, color));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void RemoveStatus(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            ushort statusId = (ushort)MathParser.Parse(args[0]);&#xD;&#xA;            ExecuteWithLock(() =&gt; _RemoveStatus(objectPtr, statusId));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetPos(IntPtr objectAddress, float x, float y, float z)&#xD;&#xA;        {&#xD;&#xA;            Vector3 pos = new Vector3(x, z, y); // 注意 Y Z 轴交换&#xD;&#xA;            IntPtr modelAddress = Memory.Read&lt;IntPtr&gt;(objectAddress + 0x100);&#xD;&#xA;            Memory.Write(objectAddress + 0xB0, pos);&#xD;&#xA;            Memory.Write(modelAddress + 0x50, pos);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetHeading(IntPtr objectAddress, float h)&#xD;&#xA;        {&#xD;&#xA;            IntPtr modelAddress = Memory.Read&lt;IntPtr&gt;(objectAddress + 0x100);&#xD;&#xA;            Memory.Write(objectAddress + 0xC0, h);&#xD;&#xA;            // 两个数都和面向有关，公式是凑出来的，似乎是个四元数？&#xD;&#xA;            Memory.Write(modelAddress + 0x64, (float)Math.Sin(h / 2));&#xD;&#xA;            Memory.Write(modelAddress + 0x6C, (float)Math.Cos(h / 2));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _Target(IntPtr address)&#xD;&#xA;        {   // FFXIVClientStructs/FFXIV/Client/Game/Control/TargetSystem.cs&#xD;&#xA;            Memory.Write(TargetSystemPtr + 0x80, address);&#xD;&#xA;            Memory.Write(TargetSystemPtr + 0x88, address);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetModelStatus(IntPtr objectAddress, int status)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write(objectAddress + VersionHelper.ModelStatusOffset(), status);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _ObjectScalingTemp(IntPtr objectAddress, float scaleX, float scaleY, float scaleZ)&#xD;&#xA;        {&#xD;&#xA;            uint id = Memory.Read&lt;uint&gt;(objectAddress + 0x74);&#xD;&#xA;            if (BridgeFFXIV.PlayerId == id) // 调整视角高度&#xD;&#xA;            {&#xD;&#xA;                Memory.Write&lt;float&gt;(objectAddress + 0xC4, (scaleZ + 1) / 2f);&#xD;&#xA;            }&#xD;&#xA;            IntPtr drawObjectAddress = Memory.Read&lt;IntPtr&gt;(objectAddress + 0x100);&#xD;&#xA;            Memory.Write&lt;float&gt;(drawObjectAddress + 0x70, scaleX);&#xD;&#xA;            Memory.Write&lt;float&gt;(drawObjectAddress + 0x74, scaleZ);&#xD;&#xA;            Memory.Write&lt;float&gt;(drawObjectAddress + 0x78, scaleY);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetObjectScale(IntPtr objectAddress, float scale)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write&lt;float&gt;(objectAddress + 0xC4, scale);&#xD;&#xA;            _ReDraw(objectAddress);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetOpacity(IntPtr objectAddress, float opacity)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write&lt;float&gt;(objectAddress + VersionHelper.OpacityOffset(), opacity);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _Hide(IntPtr objectAddress, bool hide)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write&lt;byte&gt;(objectAddress + 0x118, (byte)(hide ? 2 : 0));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetStatusLoopVfx(IntPtr objectAddress, ushort id)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write&lt;ushort&gt;(objectAddress + VersionHelper.StatusLoopVfxOffset(), id);&#xD;&#xA;            _ReDraw(objectAddress);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _EnableDraw(IntPtr address)&#xD;&#xA;            =&gt; CallVirtualFunction(address, 12);&#xD;&#xA;&#xD;&#xA;        internal static void _DisableDraw(IntPtr address)&#xD;&#xA;            =&gt; CallVirtualFunction(address, 13);&#xD;&#xA;&#xD;&#xA;        internal static void _ReDraw(IntPtr address)&#xD;&#xA;        {&#xD;&#xA;            _DisableDraw(address);&#xD;&#xA;            _EnableDraw(address);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void _SetHighlightColor(IntPtr address, byte color)&#xD;&#xA;            =&gt; CallVirtualFunction(address, 26, color);&#xD;&#xA;&#xD;&#xA;        // FFXIVClientStructs/FFXIV/Client/Game/Character/Character.cs&#xD;&#xA;        // The GameObject must be a Character!&#xD;&#xA;        internal static IntPtr _GetStatusManagerPtr(IntPtr address)&#xD;&#xA;            =&gt; CallVirtualFunction&lt;IntPtr&gt;(address, 77);&#xD;&#xA;&#xD;&#xA;        internal static void _RemoveStatus(IntPtr address, ushort statusId)&#xD;&#xA;        {&#xD;&#xA;            IntPtr statusManagerPtr = _GetStatusManagerPtr(address);&#xD;&#xA;            if (statusManagerPtr == IntPtr.Zero) throw new Exception($&quot;StatusManagerPtr is null for entity at {(long)address:X}&quot;);&#xD;&#xA;            int statusIndex = Memory.CallInjected64&lt;int&gt;(GetStatusIndexPtr, statusManagerPtr, statusId, 0xE0000000);&#xD;&#xA;            if (statusIndex &lt; 0) throw new Exception($&quot;Status 0x{statusId:X} does not exist for entity at {(long)address:X}&quot;);&#xD;&#xA;            Memory.CallInjected64&lt;IntPtr&gt;(RemoveStatusPtr, statusManagerPtr, statusIndex, 0);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class VfxHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr ActorVfxCreatePtr;&#xD;&#xA;        public static IntPtr ActorVfxRemovePtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            ActorVfxCreatePtr = TryScan(&quot;E8 * * * * 48 8B D8 48 85 C0 74 ?? 0F B6 57 ?? 48 8B C8 C0 EA 02 80 E2 01&quot;, nameof(ActorVfxCreatePtr));&#xD;&#xA;            var actorVfxRemovePtrPtr = TryScan(&quot;0F 11 48 10 48 8D 05 * * * *&quot;, nameof(ActorVfxRemovePtr));&#xD;&#xA;            ActorVfxRemovePtr = Memory.Read&lt;IntPtr&gt;(actorVfxRemovePtrPtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            RegisterCallback(&quot;LockOn&quot;, VfxHelper.LockOn, ActorVfxCreatePtr);&#xD;&#xA;            RegisterCallback(&quot;Channeling&quot;, VfxHelper.Channeling, ActorVfxCreatePtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void LockOn(string cmd)&#xD;&#xA;        {&#xD;&#xA;            string[] args = ParseArgs_OutAddress(cmd, out IntPtr tgtAddress);&#xD;&#xA;            string vfxName = args[0];&#xD;&#xA;            ExecuteWithLock(() =&gt; _LockOn(tgtAddress, vfxName));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static IntPtr _LockOn(IntPtr tgtAddress, string vfxName)&#xD;&#xA;        {&#xD;&#xA;            string path = $&quot;vfx/lockon/eff/{vfxName}.avfx&quot;;&#xD;&#xA;            IntPtr pathPtr = IntPtr.Zero;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                pathPtr = Memory.AllocateMemory(256);&#xD;&#xA;                Memory.WriteString(pathPtr, path, Encoding.UTF8);&#xD;&#xA;                IntPtr vfxHandle = Memory.CallInjected64&lt;IntPtr&gt;(&#xD;&#xA;                    ActorVfxCreatePtr,&#xD;&#xA;                    pathPtr,    // vfx name&#xD;&#xA;                    tgtAddress, // caster &#xD;&#xA;                    tgtAddress, // target &#xD;&#xA;                    -1f, /*(char)*/(ushort)0, 0, /*(char)*/(ushort)0&#xD;&#xA;                );&#xD;&#xA;                return vfxHandle;&#xD;&#xA;            }&#xD;&#xA;            finally { if (pathPtr != IntPtr.Zero) Memory.FreeMemory(pathPtr); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Channeling(string cmd)&#xD;&#xA;        {&#xD;&#xA;            string[] args = ParseArgs_OutAddress2(cmd, out IntPtr srcAddress, out IntPtr tgtAddress);&#xD;&#xA;            string vfxName = args[0];&#xD;&#xA;            double duration = args.Length &gt; 1 ? double.Parse(args[1], NumberStyles.Float, CultureInfo.InvariantCulture) : 3.0;&#xD;&#xA;&#xD;&#xA;            IntPtr vfxHandle = ExecuteWithLock(() =&gt; _Channeling(srcAddress, tgtAddress, vfxName));&#xD;&#xA;            Thread.Sleep((int)(duration * 1000));&#xD;&#xA;            if (vfxHandle != IntPtr.Zero)&#xD;&#xA;            {&#xD;&#xA;                ExecuteWithLock(() =&gt; _ActorVfxRemove(vfxHandle));&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                throw new Exception($&quot;Remove channeling failed: {vfxName}&quot;);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static IntPtr _Channeling(IntPtr srcAddress, IntPtr tgtAddress, string vfxName)&#xD;&#xA;        {&#xD;&#xA;            string path = $&quot;vfx/channeling/eff/{vfxName}.avfx&quot;;&#xD;&#xA;            IntPtr pathPtr = IntPtr.Zero;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                pathPtr = Memory.AllocateMemory(256);&#xD;&#xA;                Memory.WriteString(pathPtr, path, Encoding.UTF8);&#xD;&#xA;                IntPtr vfxHandle = Memory.CallInjected64&lt;IntPtr&gt;(&#xD;&#xA;                    ActorVfxCreatePtr,&#xD;&#xA;                    pathPtr,    // vfx name&#xD;&#xA;                    srcAddress, // caster &#xD;&#xA;                    tgtAddress, // target &#xD;&#xA;                    -1f, /*(char)*/(ushort)0, 0, /*(char)*/(ushort)0&#xD;&#xA;                );&#xD;&#xA;                return vfxHandle;&#xD;&#xA;            }&#xD;&#xA;            finally { if (pathPtr != IntPtr.Zero) Memory.FreeMemory(pathPtr); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void _ActorVfxRemove(IntPtr vfxHandle)&#xD;&#xA;        {&#xD;&#xA;            Memory.CallInjected64&lt;IntPtr&gt;(ActorVfxRemovePtr, vfxHandle, /*(char)*/(ushort)1);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class EnvironmentEffectHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr MapEffectFunctionPtr;&#xD;&#xA;        public static IntPtr EventFrameworkPtrPtr;&#xD;&#xA;        public static IntPtr EnvManagerPtrPtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            MapEffectFunctionPtr = TryScan(&quot;E8 * * * * 48 8B 5C 24 ?? 48 83 C4 ?? 5F C3 CC CC CC CC CC CC CC CC CC CC CC CC CC CC 48 89 5C 24 ?? 57 48 83 EC ?? 0F B7 DA 33 C0&quot;, nameof(MapEffectFunctionPtr));&#xD;&#xA;            EventFrameworkPtrPtr = TryScan(&quot;4C 39 2D * * * * 74 14&quot;, nameof(EventFrameworkPtrPtr));&#xD;&#xA;            EnvManagerPtrPtr = TryScan(&quot;0F 28 F2 48 8B 05 * * * *&quot;, nameof(EnvManagerPtrPtr));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            RegisterCallback(&quot;MapEffect&quot;, MapEffect, EventFrameworkPtrPtr);&#xD;&#xA;            RegisterCallback(&quot;ChangeWeather&quot;, ChangeWeather, EnvManagerPtrPtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void MapEffect(string command)&#xD;&#xA;        {&#xD;&#xA;            CheckBeforeExecution(command);&#xD;&#xA;            uint position;&#xD;&#xA;            ushort data1, data2;&#xD;&#xA;&#xD;&#xA;            if (command.Contains(&quot;,&quot;)) // given 3 parameters&#xD;&#xA;            {&#xD;&#xA;                var rawArgs = Context.SplitArguments(command);&#xD;&#xA;                if (!uint.TryParse(rawArgs[0], NumberStyles.Integer, CultureInfo.InvariantCulture, out position))&#xD;&#xA;                {&#xD;&#xA;                    throw Context.ParseTypeError(&quot;string&quot;, rawArgs[0], &quot;uint&quot;, command);&#xD;&#xA;                }&#xD;&#xA;                if (!ushort.TryParse(rawArgs[1], NumberStyles.Integer, CultureInfo.InvariantCulture, out data1))&#xD;&#xA;                {&#xD;&#xA;                    throw Context.ParseTypeError(&quot;string&quot;, rawArgs[1], &quot;ushort&quot;, command);&#xD;&#xA;                }&#xD;&#xA;                if (!ushort.TryParse(rawArgs[2], NumberStyles.Integer, CultureInfo.InvariantCulture, out data2))&#xD;&#xA;                {&#xD;&#xA;                    throw Context.ParseTypeError(&quot;string&quot;, rawArgs[2], &quot;ushort&quot;, command);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else // given act or network log format&#xD;&#xA;            {&#xD;&#xA;                string pattern = @&quot;^(?&lt;data2&gt;[0-9A-Fa-f]{4})(?&lt;data1&gt;[0-9A-Fa-f]{4})[:|](?&lt;position&gt;[0-9A-Fa-f]{1,8})$&quot;;&#xD;&#xA;                var match = Regex.Match(command.Trim(), pattern);&#xD;&#xA;                if (match.Success)&#xD;&#xA;                {&#xD;&#xA;                    data2 = ushort.Parse(match.Groups[&quot;data2&quot;].Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture);&#xD;&#xA;                    data1 = ushort.Parse(match.Groups[&quot;data1&quot;].Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture);&#xD;&#xA;                    position = uint.Parse(match.Groups[&quot;position&quot;].Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture);&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    throw new Exception($&quot;Invalid mapeffect parameters: {command}&quot;);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            PostNamazuUi?.Log($&quot;MapEffect: position = {position}, data1 = {data1}, data2 = {data2} ({data2:X4}{data1:X4}:{position:X2})&quot;);&#xD;&#xA;            ExecuteWithLock(() =&gt; _MapEffect(position, data1, data2));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void _MapEffect(uint position, ushort data1, ushort data2)&#xD;&#xA;        {&#xD;&#xA;            var mapEffectModulePtr = Memory.Read&lt;IntPtr&gt;(Memory.Read&lt;IntPtr&gt;(EventFrameworkPtrPtr) + 0x158);&#xD;&#xA;            Memory.CallInjected64&lt;IntPtr&gt;(MapEffectFunctionPtr, mapEffectModulePtr, position, data1, data2);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void ChangeWeather(string command)&#xD;&#xA;        {&#xD;&#xA;            CheckBeforeExecution(command);&#xD;&#xA;            byte weatherId = byte.Parse(command, NumberStyles.Integer, CultureInfo.InvariantCulture);&#xD;&#xA;&#xD;&#xA;            PostNamazuUi?.Log($&quot;ChangeWeather: weatherId = {weatherId}&quot;);&#xD;&#xA;            ExecuteWithLock(() =&gt; _ChangeWeather(weatherId));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // FFXIVClientStructs/FFXIV/Client/Graphics/Environment/EnvManager.cs&#xD;&#xA;        static void _ChangeWeather(byte weatherId)&#xD;&#xA;        {&#xD;&#xA;            var envManagerPtr = Memory.Read&lt;IntPtr&gt;(EnvManagerPtrPtr);&#xD;&#xA;            Memory.Write&lt;byte&gt;(envManagerPtr + 0x27, weatherId); // ActiveWeather&#xD;&#xA;            Memory.Write&lt;float&gt;(envManagerPtr + 0x28, 1); // TransitionTime&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class CameraHelper&#xD;&#xA;    {&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            RegisterCallback(&quot;SetCameraParams&quot;, SetCameraParams);&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                // 01 行触发初始化的时候这行会报错？因为 CameraAddress 还没初始化？&#xD;&#xA;                RealPlugin.plug.InvokeNamedCallback(&quot;SetCameraParams&quot;, &quot;apply&quot;);&#xD;&#xA;            }&#xD;&#xA;            catch { }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static IntPtr CameraAddress = Triggernometry.Utilities.Memory.GetCameraAddress();&#xD;&#xA;        public static Dictionary&lt;string, int&gt; Offsets = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase)&#xD;&#xA;        {&#xD;&#xA;            { &quot;Distance&quot;, 0x114 },&#xD;&#xA;            { &quot;MinDistance&quot;, 0x118 },&#xD;&#xA;            { &quot;MaxDistance&quot;, 0x11C },&#xD;&#xA;            { &quot;FoV&quot;, 0x120 },&#xD;&#xA;            { &quot;MinFoV&quot;, 0x124 },&#xD;&#xA;            { &quot;MaxFoV&quot;, 0x128 },&#xD;&#xA;            { &quot;AngleH&quot;, 0x130 }, // 这个角度似乎不是底层的数值，手动修改（增加或减少）时，改变量的绝对值 dθ 会变为 max(dθ - pi/40, 0)&#xD;&#xA;            { &quot;AngleV&quot;, 0x134 }, // 上 -pi/2   下 pi/2&#xD;&#xA;            { &quot;MinAngleV&quot;, 0x148 },&#xD;&#xA;            { &quot;MaxAngleV&quot;, 0x14C },&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        // 游戏默认&#xD;&#xA;        public static Dictionary&lt;string, float&gt; OriginalParams = new Dictionary&lt;string, float&gt;(StringComparer.OrdinalIgnoreCase)&#xD;&#xA;        {&#xD;&#xA;            { &quot;MinDistance&quot;, 1.5f },&#xD;&#xA;            { &quot;MaxDistance&quot;, 20.0f },&#xD;&#xA;            { &quot;MinFoV&quot;, 0.68f },&#xD;&#xA;            { &quot;MaxFoV&quot;, 0.78f },&#xD;&#xA;            { &quot;MinAngleV&quot;, -1.483529806f },&#xD;&#xA;            { &quot;MaxAngleV&quot;, 0.7853981853f },&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        public static Dictionary&lt;string, float&gt; DefaultEditedParams = new Dictionary&lt;string, float&gt;(StringComparer.OrdinalIgnoreCase)&#xD;&#xA;        {&#xD;&#xA;            { &quot;MinDistance&quot;, 0.5f },&#xD;&#xA;            { &quot;MaxDistance&quot;, 9999f },&#xD;&#xA;            { &quot;MinFoV&quot;, 0.68f },&#xD;&#xA;            { &quot;MaxFoV&quot;, 0.78f },&#xD;&#xA;            { &quot;MinAngleV&quot;, -1.569f }, // 超过这个数值时第一人称视角难以旋转&#xD;&#xA;            { &quot;MaxAngleV&quot;, 1.569f },  // 超过这个数值时视角会反转&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        public static float AngleV&#xD;&#xA;        {&#xD;&#xA;            get =&gt; Memory.Read&lt;float&gt;(CameraAddress + Offsets[&quot;AngleV&quot;]);&#xD;&#xA;            set =&gt; Memory.Write&lt;float&gt;(CameraAddress + Offsets[&quot;AngleV&quot;], value);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static float AngleH // 和游戏的角度（南 = 0）是反的，补偿 pi&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                var actualValue = Memory.Read&lt;float&gt;(CameraAddress + Offsets[&quot;AngleH&quot;]);&#xD;&#xA;                var convertedValue = MathParser.ModFunction(actualValue, 2 * Math.PI) - Math.PI;&#xD;&#xA;                return (float)convertedValue;&#xD;&#xA;            }&#xD;&#xA;            set // 这个角度似乎不是底层的数值，手动修改（增加或减少）时，改变量的绝对值 θ 会变为 max(θ - pi/40, 0)&#xD;&#xA;            {&#xD;&#xA;                double errθ = Math.PI / 40;&#xD;&#xA;                double oldθ = Memory.Read&lt;float&gt;(CameraAddress + Offsets[&quot;AngleH&quot;]);&#xD;&#xA;                double newθ = MathParser.ModFunction(value, 2 * Math.PI) - Math.PI;  // 补偿&#xD;&#xA;                double dθ = MathParser.ModFunction(newθ - oldθ + Math.PI, 2 * Math.PI) - Math.PI;&#xD;&#xA;                if (Math.Abs(dθ) &gt;= 3.05)&#xD;&#xA;                {&#xD;&#xA;                    Memory.Write&lt;float&gt;(CameraAddress + Offsets[&quot;AngleH&quot;], (float)oldθ + Math.Sign(dθ));&#xD;&#xA;                    oldθ += Math.Sign(dθ) * (1 - errθ); // 实际变化的量&#xD;&#xA;                    dθ = MathParser.ModFunction(newθ - oldθ + Math.PI, 2 * Math.PI) - Math.PI;&#xD;&#xA;                }&#xD;&#xA;                double writeValue = newθ + Math.Sign(dθ) * errθ;&#xD;&#xA;                Memory.Write&lt;float&gt;(CameraAddress + Offsets[&quot;AngleH&quot;], (float)writeValue);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static float GetCameraParam(string param)&#xD;&#xA;        {&#xD;&#xA;            if (Offsets.TryGetValue(param, out int offset))&#xD;&#xA;            {&#xD;&#xA;                return Memory.Read&lt;float&gt;(CameraAddress + offset);&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                Log(DebugLevelEnum.Error, $&quot;错误的相机参数 ({param})。&quot;);&#xD;&#xA;                return default;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void SetCameraParam(string param, float newValue)&#xD;&#xA;        {&#xD;&#xA;            switch (param.ToLower())&#xD;&#xA;            {&#xD;&#xA;                case &quot;angleh&quot;: AngleH = newValue; break;&#xD;&#xA;                case &quot;anglev&quot;: AngleV = newValue; break;&#xD;&#xA;                default:&#xD;&#xA;                    if (Offsets.TryGetValue(param, out int offset))&#xD;&#xA;                    {&#xD;&#xA;                        IntPtr address = CameraAddress + offset;&#xD;&#xA;                        Memory.Write&lt;float&gt;(address, newValue);&#xD;&#xA;                        Log(DebugLevelEnum.Custom, $&quot;成功设置相机参数 {param} = {newValue}&quot;);&#xD;&#xA;                    }&#xD;&#xA;                    else&#xD;&#xA;                    {&#xD;&#xA;                        Log(DebugLevelEnum.Error, $&quot;错误的相机参数 ({param})。&quot;);&#xD;&#xA;                    };&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        /// &lt;summary&gt; 接收单个关键词：reset apply clearconfig initconfig; &lt;br /&gt;&#xD;&#xA;        /// 或每行一个指定修改的数据，如 Distance = 10 &lt;/summary&gt;&#xD;&#xA;        public static void SetCameraParams(string cmd)&#xD;&#xA;        {&#xD;&#xA;            switch (cmd.Trim().ToLower())&#xD;&#xA;            {&#xD;&#xA;                case &quot;reset&quot;: // 临时重置当前视距、视角及其范围为游戏默认值&#xD;&#xA;                    foreach (var kvp in OriginalParams)&#xD;&#xA;                    {&#xD;&#xA;                        SetCameraParam(kvp.Key, kvp.Value);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;apply&quot;: // 将配置中的当前视距、视角及其范围应用到游戏&#xD;&#xA;                    foreach (var kvp in OriginalParams)&#xD;&#xA;                    {&#xD;&#xA;                        var rawValue = GetConfig().GetValue($&quot;camera_{kvp.Key}&quot;).ToString();&#xD;&#xA;                        if (string.IsNullOrWhiteSpace(rawValue)) continue;&#xD;&#xA;                        var newValue = float.Parse(rawValue, NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;                        SetCameraParam(kvp.Key, newValue);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;clearconfig&quot;: // 清除相关配置，并恢复游戏默认值&#xD;&#xA;                    foreach (var kvp in OriginalParams)&#xD;&#xA;                    {&#xD;&#xA;                        GetConfig().Values.Remove($&quot;camera_{kvp.Key}&quot;);&#xD;&#xA;                        SetCameraParam(kvp.Key, kvp.Value);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                case &quot;initconfig&quot;: // 初始化相关配置并应用到游戏&#xD;&#xA;                    foreach (var kvp in DefaultEditedParams)&#xD;&#xA;                    {&#xD;&#xA;                        GetConfig().SetValue($&quot;camera_{kvp.Key}&quot;, kvp.Value);&#xD;&#xA;                        SetCameraParam(kvp.Key, kvp.Value);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                default:&#xD;&#xA;                    var kvps = cmd.Split('\n').Select(data =&gt; data.Split(new char[] { '=' }, 2)).Where(data =&gt; data.Length == 2);&#xD;&#xA;                    foreach (var kvp in kvps)&#xD;&#xA;                    {&#xD;&#xA;                        var key = kvp[0].Trim();&#xD;&#xA;                        if (!Offsets.ContainsKey(key)) continue;&#xD;&#xA;                        var value = (float)MathParser.Parse(kvp[1]);&#xD;&#xA;                        SetCameraParam(key, value);&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class UseActionHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr UseActionPtr;&#xD;&#xA;        public static IntPtr UseActionLocationPtr;&#xD;&#xA;        public static IntPtr ActionManagerPtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            UseActionPtr = TryScan(&quot;E8 * * * * B0 01 EB B6&quot;, nameof(UseActionPtr));&#xD;&#xA;            UseActionLocationPtr = TryScan(&quot;E8 * * * * 41 3A C5 0F 85&quot;, nameof(UseActionLocationPtr));&#xD;&#xA;            ActionManagerPtr = TryScan(&quot;48 8D 0D * * * * F3 0F 10 13&quot;, nameof(ActionManagerPtr));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            RegisterCallback(&quot;UseAction&quot;, UseAction, UseActionPtr);&#xD;&#xA;            RegisterCallback(&quot;UseActionLocation&quot;, UseActionLocation, UseActionLocationPtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public enum ActionType : byte&#xD;&#xA;        {&#xD;&#xA;            None = 0,&#xD;&#xA;            Normal = 1, Action = 1, // Spell, Weaponskill, Ability. Confusing name, I know.&#xD;&#xA;            Item = 2,&#xD;&#xA;            KeyItem = 3,&#xD;&#xA;            Ability = 4, // Not in UseActionHelper (??)&#xD;&#xA;            General = 5, GeneralAction = 5,&#xD;&#xA;            Buddy = 6, BuddyAction = 6,&#xD;&#xA;            Main = 7, MainCommand = 7,&#xD;&#xA;            Companion = 8,&#xD;&#xA;            Craft = 9, CraftAction = 9,&#xD;&#xA;            Unk_10 = 10, // Fishing per Sapphire? Something to do with items.&#xD;&#xA;            Pet = 11, PetAction = 11,&#xD;&#xA;            Unk_12 = 12, // Not in UseActionHelper. Sapphire says CompanyAction, but not actually triggered.&#xD;&#xA;            Mount = 13,&#xD;&#xA;            PvP = 14, PvPAction = 14,&#xD;&#xA;            Waymark = 15, FieldMarker = 15,&#xD;&#xA;            ChocoboRaceAbility = 16,&#xD;&#xA;            ChocoboRaceItem = 17,&#xD;&#xA;            Unk_18 = 18, // Not in UseActionHelper (?)&#xD;&#xA;            BgcArmyAction = 0x19,&#xD;&#xA;            Ornament = 0x20,&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public enum UseActionMode&#xD;&#xA;        {&#xD;&#xA;            None = 0, // usual action execution, e.g. a hotbar button press&#xD;&#xA;            Queue = 1, // previously queued action is now ready and is being executed (=&gt; will ignore queue)&#xD;&#xA;            Macro = 2, // action execution originating from a macro (=&gt; won't be queued)&#xD;&#xA;            Combo = 3, // action execution is from a single-button combo&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void UseAction(string command)&#xD;&#xA;        {&#xD;&#xA;            CheckBeforeExecution(command);&#xD;&#xA;&#xD;&#xA;            var args = Context.SplitArguments(command);&#xD;&#xA;            ActionType actionType = Enum.TryParse(args[0], out actionType) ? actionType : (ActionType)(int)MathParser.Parse(args[0]);&#xD;&#xA;            uint actionId = (uint)MathParser.Parse(args[1]);&#xD;&#xA;            ulong targetId = (ulong)MathParser.Parse(Context.GetArgument(args, 2, &quot;0xE0000000&quot;, true));&#xD;&#xA;            uint extraParam = (uint)(actionType == ActionType.Item ? 0xFFFF : 0);&#xD;&#xA;            UseActionMode mode = Enum.TryParse(Context.GetArgument(args, 3, &quot;0&quot;), out mode) ? mode&#xD;&#xA;                : (UseActionMode)(int)MathParser.Parse(Context.GetArgument(args, 3, &quot;0&quot;));&#xD;&#xA;            uint comboRouteID = 0;&#xD;&#xA;&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                if (Memory.CallInjected64&lt;bool&gt;(UseActionPtr, ActionManagerPtr, (int)actionType, actionId, targetId, extraParam, (int)mode, comboRouteID, 0))&#xD;&#xA;                {&#xD;&#xA;                    PostNamazuUi?.Log($&quot;UseAction: {actionType} ({(int)actionType}), id = {actionId} (0x{actionId:X}), target = {targetId:X}, mode = {mode} ({(int)mode})&quot;);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            finally&#xD;&#xA;            {&#xD;&#xA;                if (flag) Monitor.Exit(assemblyLock);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void UseActionLocation(string command)&#xD;&#xA;        {&#xD;&#xA;            CheckBeforeExecution(command);&#xD;&#xA;&#xD;&#xA;            var args = Context.SplitArguments(command);&#xD;&#xA;            ActionType actionType = Enum.TryParse(args[0], out actionType) ? actionType : (ActionType)(int)MathParser.Parse(args[0]);&#xD;&#xA;            uint actionId = (uint)MathParser.Parse(args[1]);&#xD;&#xA;            ulong targetId = 0xE0000000;&#xD;&#xA;            var pos = new Vector3((float)MathParser.Parse(args[2]), (float)MathParser.Parse(args[4]), (float)MathParser.Parse(args[3]));&#xD;&#xA;            uint extraParam = (uint)MathParser.Parse(Context.GetArgument(args, 5, &quot;0&quot;, true));&#xD;&#xA;&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                IntPtr posPtr = Memory.AllocateMemory(0x10);&#xD;&#xA;                Memory.Write(posPtr, pos);&#xD;&#xA;                if (Memory.CallInjected64&lt;bool&gt;(UseActionLocationPtr, ActionManagerPtr, (int)actionType, actionId, targetId, posPtr, extraParam))&#xD;&#xA;                {&#xD;&#xA;                    PostNamazuUi?.Log($&quot;UseAction (Ground): {actionType} ({(int)actionType}); id = {actionId} (0x{actionId:X}); Pos = ({pos.X:0.##}, {pos.Z:0.##}), {pos.Y:0.##}&quot;);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            finally&#xD;&#xA;            {&#xD;&#xA;                if (flag) Monitor.Exit(assemblyLock);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class ExecuteCommandHelper&#xD;&#xA;    {&#xD;&#xA;        public static IntPtr ExecuteCommandPtr;&#xD;&#xA;        public static IntPtr ExecuteCommandTgtPtr;&#xD;&#xA;        public static IntPtr ExecuteCommandPosPtr;&#xD;&#xA;&#xD;&#xA;        public static void Scan()&#xD;&#xA;        {&#xD;&#xA;            ExecuteCommandPtr = TryScan(&quot;E8 * * * * 48 83 C4 ? C3 CC CC CC CC CC CC CC CC CC CC CC CC 48 83 EC ? 45 0F B6 C0&quot;, nameof(ExecuteCommandPtr));&#xD;&#xA;            ExecuteCommandTgtPtr = TryScan(&quot;E8 * * * * 80 7D ? ? 74 ? 41 0F B6 45&quot;, nameof(ExecuteCommandTgtPtr)); // DR: ExecuteCommandComplex&#xD;&#xA;            ExecuteCommandPosPtr = TryScan(&quot;E8 * * * * EB ? 48 8B 53 ? 33 C0&quot;, nameof(ExecuteCommandPosPtr)); // DR: ExecuteCommandComplexLocation&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Register()&#xD;&#xA;        {&#xD;&#xA;            Triggernometry.Interpreter.StaticHelpers.Storage[&quot;_ExecuteCommand&quot;] = (object)_ExecuteCommand;&#xD;&#xA;            Triggernometry.Interpreter.StaticHelpers.Storage[&quot;_ExecuteCommandTgt&quot;] = (object)_ExecuteCommandTgt;&#xD;&#xA;            Triggernometry.Interpreter.StaticHelpers.Storage[&quot;_ExecuteCommandPos&quot;] = (object)_ExecuteCommandPos;&#xD;&#xA;            RegisterCallback(&quot;StatusOff&quot;, StatusOff, ExecuteCommandPtr);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static bool _ExecuteCommand(uint command, uint param1, uint param2, uint param3, uint param4)&#xD;&#xA;        {&#xD;&#xA;            return Memory.CallInjected64&lt;bool&gt;(ExecuteCommandPtr, command, param1, param2, param3, param4);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static bool _ExecuteCommandTgt(uint command, uint targetId, uint param1, uint param2, uint param3, uint param4)&#xD;&#xA;        {&#xD;&#xA;            return Memory.CallInjected64&lt;bool&gt;(ExecuteCommandTgtPtr, command, targetId, param1, param2, param3, param4);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static bool _ExecuteCommandPos(uint command, double x, double y, double z, uint param1, uint param2, uint param3, uint param4)&#xD;&#xA;        {&#xD;&#xA;            var pos = new Vector3((float)x, (float)z, (float)y);&#xD;&#xA;            IntPtr posPtr = Memory.AllocateMemory(0x10);&#xD;&#xA;            Memory.Write(posPtr, pos);&#xD;&#xA;            return Memory.CallInjected64&lt;bool&gt;(ExecuteCommandPosPtr, command, posPtr, param1, param2, param3, param4);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void StatusOff(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = Context.SplitArguments(cmd);&#xD;&#xA;            ushort statusID = (ushort)MathParser.Parse(args[0]);&#xD;&#xA;            uint srcID = uint.Parse(Context.GetArgument(args, 1, &quot;E0000000&quot;, true), NumberStyles.HexNumber, CultureInfo.InvariantCulture);&#xD;&#xA;            StatusOff(statusID, srcID);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        internal static void StatusOff(uint statusID, uint srcID = 0xE0000000)&#xD;&#xA;        {&#xD;&#xA;            _ExecuteCommand(104, statusID, 0, srcID, 0);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    #region Utils&#xD;&#xA;&#xD;&#xA;    public static void ExecuteWithLock(System.Action action) =&gt; NamazuModule.ExecuteWithLock(action);&#xD;&#xA;    public static T ExecuteWithLock&lt;T&gt;(Func&lt;T&gt; function) =&gt; NamazuModule.ExecuteWithLock(function);&#xD;&#xA;&#xD;&#xA;    static IntPtr TryScan(string pattern, string name)&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            return Scanner.ScanText(pattern, name);&#xD;&#xA;        }&#xD;&#xA;        catch (Exception ex)&#xD;&#xA;        {&#xD;&#xA;            RealPlugin.plug.FilteredAddToLog(RealPlugin.DebugLevelEnum.Error, ex.Message);&#xD;&#xA;            return IntPtr.Zero;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static IntPtr TryScanMultiple(IEnumerable&lt;string&gt; patterns, string name)&#xD;&#xA;    {&#xD;&#xA;        Exception ex = null;&#xD;&#xA;        foreach (var pattern in patterns)&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                return Scanner.ScanText(pattern, name);&#xD;&#xA;            }&#xD;&#xA;            catch (Exception e)&#xD;&#xA;            {&#xD;&#xA;                ex = e;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        RealPlugin.plug.FilteredAddToLog(RealPlugin.DebugLevelEnum.Error, ex?.Message ?? &quot;&quot;);&#xD;&#xA;        return IntPtr.Zero;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static string[] ParseArgs_OutAddress(string cmd, out IntPtr address)&#xD;&#xA;    {&#xD;&#xA;        var args = Context.SplitArguments(cmd);&#xD;&#xA;        address = (IntPtr)long.Parse(args[0]);&#xD;&#xA;        return args.Skip(1).ToArray();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static string[] ParseArgs_OutAddress2(string cmd, out IntPtr address1, out IntPtr address2)&#xD;&#xA;    {&#xD;&#xA;        var args = Context.SplitArguments(cmd);&#xD;&#xA;        address1 = (IntPtr)long.Parse(args[0]);&#xD;&#xA;        address2 = (IntPtr)long.Parse(args[1]);&#xD;&#xA;        return args.Skip(2).ToArray();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void CallVirtualFunction(IntPtr objAddress, int vFuncIndex, params object[] args)&#xD;&#xA;        =&gt; CallVirtualFunction&lt;IntPtr&gt;(objAddress, vFuncIndex, args);&#xD;&#xA;&#xD;&#xA;    public static T CallVirtualFunction&lt;T&gt;(IntPtr objAddress, int vFuncIndex, params object[] args) where T : struct&#xD;&#xA;    {&#xD;&#xA;        IntPtr vTablePtr = Memory.Read&lt;IntPtr&gt;(objAddress);&#xD;&#xA;        IntPtr vFuncPtr = Memory.Read&lt;IntPtr&gt;(vTablePtr + 8 * vFuncIndex);&#xD;&#xA;        return Memory.CallInjected64&lt;T&gt;(vFuncPtr, new object[] { objAddress }.Concat(args).ToArray());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Echo(string msg) =&gt; RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e {msg}&quot;);&#xD;&#xA;&#xD;&#xA;    public static void Log(RealPlugin.DebugLevelEnum level, string msg) =&gt; Interpreter.StaticHelpers.Log(level, msg);&#xD;&#xA;&#xD;&#xA;    #endregion Utils&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public static class VersionHelper&#xD;&#xA;{&#xD;&#xA;    public static bool IsCN =&gt; !Triggernometry.FFXIV.Entity.GetMyself().Name.Contains(&quot; &quot;);&#xD;&#xA;&#xD;&#xA;    public static int ModelStatusOffset() =&gt; 0x118; // 7.1&#xD;&#xA;&#xD;&#xA;    // FFXIVClientStructs/FFXIV/Client/Game/Character/Character.cs   public float Alpha;&#xD;&#xA;    public static int OpacityOffset() =&gt; 0x2268; // 7.1&#xD;&#xA;&#xD;&#xA;    public static int StatusLoopVfxOffset() =&gt; 0x1C8; // 7.1&#xD;&#xA;&#xD;&#xA;}" ActionType="ExecuteScript" Description="鲶鱼精邮差扩展【注册回调】" DescriptionOverride="True">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:hint}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:hint}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="false" Source="None" Name="鲶鱼精邮差扩展 说明/自检" Id="902aa5bc-55b7-466b-9c7f-27948d23f80a" RegularExpression="">
<Actions>
<Action OrderNumber="1" Enabled="False" ActionType="Placeholder" Asynchronous="False" Description="CafeACT 无法使用此工具。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="2" Enabled="False" ActionType="Placeholder" Asynchronous="False" Description="鲶鱼精邮差扩展" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="3" Enabled="False" ActionType="Placeholder" Asynchronous="False" Description="　利用鲶鱼精邮差的内存相关工具，向触发器注册以下回调。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="4" Enabled="False" ActionType="Placeholder" Asynchronous="False" Description="　注：这些功能与鲶鱼精邮差本身无关。不要去鲶鱼精邮差的频道或 GitHub 提问相关问题。" DescBgColor="f0f8ff" DescTextColor="800" DescriptionOverride="True" />
<Action OrderNumber="5" Enabled="False" ActionType="Placeholder" Asynchronous="False" Description="　如果你开了卫月不知名插件导致炸游戏，建议结合自检排查问题。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="6" LaunchProcessPathExpression="https://github.com/MnFeN/ACT_Tech_Guide/blob/main/PostNamazuExtension" Enabled="False" ActionType="LaunchProcess" Asynchronous="False" Description="　【右键此行测试可打开 GitHub 查看详细说明】" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="7" Enabled="False" ActionType="Placeholder" Asynchronous="False" Description="　【右键点击下方绿色文本行可以测试动作】" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="8" NamedCallbackName="Warn" NamedCallbackParam="3&#xD;&#xA;我是 Honey Bee 小姐的狗！" Enabled="False" ActionType="NamedCallback" Description="· [Hint] 提示文本" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="9" NamedCallbackName="quit" Enabled="False" ActionType="NamedCallback" Description="· [Quit] 退出副本" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="10" NamedCallbackName="Target" NamedCallbackParam="${_entity[Distance &gt; 15 &amp;&amp; Distance &lt; 50].id}" Enabled="False" ActionType="NamedCallback" Description="· [Target] 选择实体" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="11" NamedCallbackName="ObjectScaling" NamedCallbackParam="${_me.address}, 3" Enabled="False" ActionType="NamedCallback" Description="· [ObjectScaling] 实体缩放" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="12" NamedCallbackName="SetOpacity" NamedCallbackParam="${_me.address}, 0.2" Enabled="False" ActionType="NamedCallback" Description="· [SetOpacity] 透明度" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="13" NamedCallbackName="SetStatusLoopVfx" NamedCallbackParam="${_me.address}, 683" Enabled="False" ActionType="NamedCallback" Description="· [SetStatusLoopVfx] 状态特效" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="14" NamedCallbackName="LockOn" NamedCallbackParam="${_me.address}, m0857_stop_s5t1" Enabled="False" ActionType="NamedCallback" Description="· [LockOn] 点名特效" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="15" NamedCallbackName="Channeling" NamedCallbackParam="${_me.address}, ${_entity[${_me.targetid}].address}, chn_m0906_ht02k2, 5" Enabled="False" ActionType="NamedCallback" Description="· [Channeling] 连线特效 【注：选中一个玩家或敌人测试】" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="16" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="· [SetCameraParams] 调整视距、视场、相机角度范围等参数" DescBgColor="f0f8ff" DescTextColor="000" DescriptionOverride="True" />
<Action OrderNumber="17" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="    目前未提供 UI 修改配置参数的方式，如果要修改参数，在变量查看器 - 永久字典变量 - PNE_cfg 中编辑数值" DescBgColor="f0f8ff" DescTextColor="000" DescriptionOverride="True" />
<Action OrderNumber="18" NamedCallbackName="SetCameraParams" NamedCallbackParam="initconfig" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="  - 解锁视距及俯仰视角范围限制（此后将保持生效）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="19" NamedCallbackName="SetCameraParams" NamedCallbackParam="clearconfig" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="  - 关闭此功能并还原为游戏默认设置" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="20" NamedCallbackName="SetCameraParams" NamedCallbackParam="FoV = 1" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="  - 自定义设置（单次有效，仅供参考写法，想改的话复制这个动作到本地触发器里改）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="21" NamedCallbackName="MapEffect" NamedCallbackParam="00020001:00" Enabled="False" ActionType="NamedCallback" Description="· [MapEffect] 场地特效 【注：解限进入极火天王副本测试 地图错误可能无效甚至炸游戏】" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="22" NamedCallbackName="ChangeWeather" NamedCallbackParam="187" Enabled="False" ActionType="NamedCallback" Description="· [ChangeWeather] 切换天气 【注：在 7.0 最后一张地图测试可恢复原本的天气】" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="23" NamedCallbackName="RemoveStatus" NamedCallbackParam="${_me.address}, 0x32" Enabled="False" ActionType="NamedCallback" Description="· [RemoveStatus] 本地取消状态   使用冲刺后测试动作" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="24" NamedCallbackName="StatusOff" NamedCallbackParam="0x32 " Enabled="False" ActionType="NamedCallback" Description="· [StatusOff] 取消状态   使用冲刺后测试动作" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="25" NamedCallbackName="UseActionLocation" NamedCallbackParam="Action, 0xdf1, ${_me.x}, ${_me.y} - 10, ${_me.z}" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="· [UseAction] [UseActionLocation] 使用技能  切换白魔，在自己北侧 10 米使用庇护所" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="4f86b7e3-6b4c-4fda-94a1-feca20e5dea3" Name="调试工具" Enabled="true">
<Folders>
<Folder Id="a5196ef2-848b-4b66-89fd-c94061b361d4" Name="查询实体信息" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="查询" Id="10519962-87d6-439a-babe-ff08a827d607" RegularExpression="^EntityInfo:(.+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="command" NamedCallbackParam="/e 【—————查询实体信息—————】&#xD;&#xA;实体：${_ffxiventity[$1].name}（${_ffxiventity[$1].id}）&#xD;&#xA;BNpcID = ${_ffxiventity[$1].BNpcID}  BNpcNameID = ${_ffxiventity[$1].BNpcNameID}&#xD;&#xA;@ (${n:round(${_entity[$1].x}, 3)}, ${n:round(${_entity[$1].y}, 3)}), ${n:round(${_entity[$1].z}, 3)}&#xD;&#xA;→ ${n:round(${_entity[$1].heading}, 3)} = ${n:round(${_entity[$1].heading}/pi, 3)}π (${f:pick(${n: roundir(${_entity[$1].heading}, 8)}): 上北, 左上, 左西, 左下, 下南, 右下, 右东, 右上}）&#xD;&#xA;水平距离：${n: distance(${_entity[$1].xy}, ${_me.xy})} m&#xD;&#xA;HP：${_entity[$1].currenthp} / ${_ffxiventity[$1].maxhp}&#xD;&#xA;》${_entity[${_entity[$1].targetid}].name}（${_entity[$1].targetid}）" ActionType="NamedCallback" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="/e entity （未指定目标：查询自身/选中的目标）" Id="d9f195ac-d514-48a2-ac01-3b4e000be1b2" RegularExpression="^.{15}\S+ 00:0038::(?i)en(?:tity)? ?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="选中正常目标时：查询目标信息" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="EntityInfo:${_me.targetid}" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${_me.targetid}" ExpressionTypeL="String" ExpressionR="^[14].{7}$" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
<Action OrderNumber="3" ActionType="Placeholder" Description="选中 NPC 类目标时：报错" DescriptionOverride="True" />
<Action OrderNumber="4" LogProcess="True" NamedCallbackName="command" NamedCallbackParam="/e 无法查询 NPC。（ID: ${_me.targetid}）" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${_me.targetid}" ExpressionTypeL="String" ExpressionR="^0.{7}$" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
<Action OrderNumber="5" ActionType="Placeholder" Description="选中自身或未选中任何目标时：targetid 返回 0，查询自身信息" DescriptionOverride="True" />
<Action OrderNumber="6" LogMessageText="EntityInfo:${_me.id}" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0x0${_me.targetid}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
</Actions>
</Trigger>
<Trigger Enabled="true" Name="/e entity [name/id]" Id="746095fd-09b7-4415-9240-8ff501bc2c4b" RegularExpression="^.{15}\S+ 00:0038::(?i)en(?:tity)? +(.*)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="指定的名字/id存在：查询目标信息" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="EntityInfo:$1" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${_ffxiventity[$1].id}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringNotEqualNocase" />
</Condition>
</Action>
<Action OrderNumber="3" ActionType="Placeholder" Description="指定的名字/id不存在：报错" DescriptionOverride="True" />
<Action OrderNumber="4" NamedCallbackName="command" NamedCallbackParam="/e 指定查询的实体 [$1] 不存在。" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0x0${_ffxiventity[$1].id}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Name="ACT Combat Log Filter" Id="358b88e0-09cf-44ad-9129-675e6ee4bad4" RegularExpression="^(.{15}\S+ 00:0038:: *)?(?i:filter) *$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="by 阿洛 MnFeN" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Description="使用说明" DescBgColor="acf" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Description="1. 在 ACT 战斗记录中复制所有战斗日志；" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Description="2. 在游戏内输入 &quot;/e filter&quot;，或在触发器测试输入界面输入 &quot;filter&quot; (Ctrl + T)" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Description="3. 过滤后的日志会写入剪贴板（移除垃圾日志）。" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" Description="Instructions" DescBgColor="acf" DescriptionOverride="True" />
<Action OrderNumber="7" ActionType="Placeholder" Description="1. Copy all ACT loglines from ACT combat log; " DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="8" ActionType="Placeholder" Description="2. Enter &quot;/e filter&quot; in game, or enter &quot;filter&quot; in Triggernometry Test Input (Ctrl + T)" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Description="3. The filtered logs would be set to the clipboard. (junk data removed)" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="10" ExecScriptExpression="using System;&#xD;&#xA;using System.Text.RegularExpressions;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Threading;&#xD;&#xA;using System.Globalization;&#xD;&#xA;using Triggernometry;&#xD;&#xA;&#xD;&#xA;public static class LogFilter&#xD;&#xA;{&#xD;&#xA;    private static readonly HashSet&lt;string&gt; junkEntities = new HashSet&lt;string&gt;&#xD;&#xA;    {&#xD;&#xA;        // 召唤&#xD;&#xA;        &quot;宝石兽&quot;, &quot;Carbuncle&quot;, &quot;カーバンクル&quot;, &#xD;&#xA;        &quot;红宝石兽&quot;, &quot;Ruby Carbuncle&quot;, &quot;カーバンクル・ルビー&quot;, &#xD;&#xA;        &quot;黄宝石兽&quot;, &quot;Topaz Carbuncle&quot;, &quot;カーバンクル・トパーズ&quot;, &#xD;&#xA;        &quot;绿宝石兽&quot;, &quot;Emerald Carbuncle&quot;, &quot;カーバンクル・エメラルド&quot;, &#xD;&#xA;        &quot;伊弗利特之灵&quot;, &quot;Ifrit-Egi&quot;, &quot;イフリート・エギ&quot;,   // 英语有没有 - ？&#xD;&#xA;        &quot;泰坦之灵&quot;, &quot;Titan-Egi&quot;, &quot;タイタン・エギ&quot;, &#xD;&#xA;        &quot;迦楼罗之灵&quot;, &quot;Garuda-Egi&quot;, &quot;ガルーダ・エギ&quot;, &#xD;&#xA;        &quot;红宝石伊弗利特&quot;, &quot;Ruby Ifrit&quot;, &quot;イフリート・ルビー&quot;, &#xD;&#xA;        &quot;黄宝石泰坦&quot;, &quot;Topaz Titan&quot;, &quot;タイタン・トパーズ&quot;, &#xD;&#xA;        &quot;绿宝石迦楼罗&quot;, &quot;Emerald Garuda&quot;, &quot;ガルーダ・エメラルド&quot;, &#xD;&#xA;        &quot;亚灵神巴哈姆特&quot;, &quot;Demi-Bahamut&quot;, &quot;デミ・バハムート&quot;, &#xD;&#xA;        &quot;亚灵神不死鸟&quot;, &quot;Demi-Phoenix&quot;, &quot;デミ・フェニックス&quot;, &#xD;&#xA;        &quot;光龙巴哈姆特？&quot;, &quot;Solar Bahamut&quot;, &quot;ソル・バハムート&quot;, &#xD;&#xA;        // 黑骑&#xD;&#xA;        &quot;英雄的掠影&quot;, &quot;Esteem&quot;, &quot;英雄の影身&quot;, &#xD;&#xA;        // 机工&#xD;&#xA;        &quot;车式浮空炮塔&quot;, &quot;Rook Autoturret&quot;, &quot;オートタレット・ルーク&quot;,&#xD;&#xA;        &quot;后式自走人偶&quot;, &quot;Automaton Queen&quot;, &quot;オートマトン・クイーン&quot;, &#xD;&#xA;        // 占星&#xD;&#xA;        &quot;地星&quot;, &quot;Earthly Star&quot;, &quot;アーサリースター&quot;, &#xD;&#xA;        // 学者&#xD;&#xA;        &quot;朝日小仙女&quot;, &quot;Eos&quot;, &quot;フェアリー・エオス&quot;, &#xD;&#xA;        &quot;夕月小仙女&quot;, &quot;Selene&quot;, &quot;フェアリー・セレネ&quot;, &#xD;&#xA;        &quot;炽天使&quot;, &quot;Seraph&quot;, &quot;セラフィム&quot;,&#xD;&#xA;        // 白魔&#xD;&#xA;        &quot;礼仪之铃&quot;, &quot;Liturgy of the Bell&quot;, &quot;リタージー・オブ・ベル&quot;,&#xD;&#xA;        // 忍者&#xD;&#xA;        &quot;分身&quot;, &quot;Bunshin&quot;, &quot;分身&quot;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private static readonly List&lt;Regex&gt; junkPatterns = new List&lt;Regex&gt;&#xD;&#xA;    {&#xD;&#xA;        new Regex(@&quot;^.{15}\S+ (1[4-9]|2[67]|10[578]|105:[^:]+|1[AE]:[^:]*:[^:]*:[^:]*):1.{7}:&quot;, RegexOptions.Compiled),&#xD;&#xA;        new Regex(@&quot;^.{15}\S+ 00:(?!003[89]|0044|0839)&quot;, RegexOptions.Compiled),&#xD;&#xA;        new Regex(@&quot;^.{15}\S+ (1[8F]|2[45]|F[BE]|10E):&quot;, RegexOptions.Compiled),&#xD;&#xA;        new Regex(@&quot;^.{15}\S+ 26:.{50}.+$&quot;, RegexOptions.Compiled),&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    public static void FilterLogs()&#xD;&#xA;    {&#xD;&#xA;        string clipboardData = Clipboard.GetText();&#xD;&#xA;&#xD;&#xA;        string junkEntitiesPattern = string.Join(&quot;|&quot;, junkEntities.Select(Regex.Escape));&#xD;&#xA;        Regex idPattern = new Regex($@&quot;:(40.{{6}}):({junkEntitiesPattern}):&quot;);&#xD;&#xA;        HashSet&lt;string&gt; idsToRemove = idPattern.Matches(clipboardData).Cast&lt;Match&gt;().Select(m =&gt; $&quot;:{m.Groups[1].Value}:&quot;).ToHashSet();&#xD;&#xA;&#xD;&#xA;        string[] lines = clipboardData.Split(new[] { &quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot; }, StringSplitOptions.RemoveEmptyEntries);&#xD;&#xA;        var filteredLines = lines.Where(line =&gt; &#xD;&#xA;            !idsToRemove.Any(id =&gt; line.Contains(id)) &amp;&amp; &#xD;&#xA;            !junkPatterns.Any(pattern =&gt; pattern.IsMatch(line))&#xD;&#xA;        ).ToArray();&#xD;&#xA;        var result = string.Join(&quot;\r\n&quot;, filteredLines);&#xD;&#xA;        if (string.IsNullOrEmpty(result))&#xD;&#xA;        {&#xD;&#xA;            Clipboard.Clear();&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            Clipboard.SetText(result);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    [STAThread]&#xD;&#xA;    public static void Main()&#xD;&#xA;    {&#xD;&#xA;        Thread thread = new Thread(() =&gt;&#xD;&#xA;        {&#xD;&#xA;            FilterLogs();&#xD;&#xA;            //MessageBox.Show(&quot;Filtered.&quot;, &quot;&quot;, MessageBoxButtons.OK, MessageBoxIcon.Information);&#xD;&#xA;        });&#xD;&#xA;        thread.SetApartmentState(ApartmentState.STA);&#xD;&#xA;        thread.Start();&#xD;&#xA;        thread.Join();&#xD;&#xA;        string result = CultureInfo.CurrentUICulture.TwoLetterISOLanguageName == &quot;zh&quot; ? &quot;筛选完成&quot; : &quot;Filtered&quot;;&#xD;&#xA;        Triggernometry.Interpreter.StaticHelpers.SetScalarVariable(false, &quot;tmp_tts&quot;, result);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Triggernometry.RealPlugin.plug.RegisterNamedCallback(&quot;LogFilter&quot;, new System.Action&lt;object, string&gt;((_, __) =&gt; LogFilter.Main()), &quot;MnFeN 阿洛&quot;);" ActionType="ExecuteScript" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:LogFilter}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="11" NamedCallbackName="LogFilter" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="12" UseTTSTextExpression="${v:tmp_tts}" ActionType="UseTTS" Asynchronous="False" />
<Action OrderNumber="13" VariableName="tmp_tts" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="ACT Combat Log Anonymizer" Id="a0fc42d0-66b7-4c01-82e8-40cca1cac238" RegularExpression="^(.{15}\S+ 00:0038:: *)?(?i:anonymizer|匿名|niming|nm) *$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="by 阿洛 MnFeN" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Description="使用说明" DescBgColor="acf" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Description="用于配合触发器的调试日志生成器" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Description="1. 在 ACT 战斗记录中复制所需的战斗日志片段；" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Description="2. 在游戏内输入 &quot;/e anonymizer/匿名&quot;，或在触发器测试输入界面输入 &quot;anonymizer&quot; / &quot;匿名&quot; (Ctrl + T)" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" Description="3. 所有队员的 id 和名称会转为占位符 &quot;${l:party[n]}:队员n&quot;，并写入剪贴板，这会在测试日志时自动填入当前的小队成员 id。" DescBgColor="def" DescriptionOverride="True" />
<Action OrderNumber="7" ExecScriptExpression="using System;&#xD;&#xA;using System.Text.RegularExpressions;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Threading;&#xD;&#xA;using System.Globalization;&#xD;&#xA;using Triggernometry;&#xD;&#xA;&#xD;&#xA;public static class LogAnonymizer&#xD;&#xA;{&#xD;&#xA;    private static Regex RegexId = new Regex(@&quot;(?&lt;=:)(?&lt;id&gt;10[0-9A-F]{6})(?=:|$)&quot;);&#xD;&#xA;    private static Regex RegexName = new Regex(@&quot;\G:(?&lt;name&gt;[A-Z][a-z'-]{1,14} [A-Z][a-z'-]{1,14}|[^a-z:\d][^A-Z:\d]{0,5})(?=:|$)&quot;);&#xD;&#xA;&#xD;&#xA;    public static void Anonymize()&#xD;&#xA;    {&#xD;&#xA;        string clipboardData = Clipboard.GetText();&#xD;&#xA;        var id2Name = new Dictionary&lt;string, string&gt;();&#xD;&#xA;&#xD;&#xA;        // 从当前复制的日志中提取所有 id，并尝试对应到后面的名字&#xD;&#xA;        foreach (Match match in RegexId.Matches(clipboardData))&#xD;&#xA;        {&#xD;&#xA;            if (!match.Success) continue; // 以防万一&#xD;&#xA;&#xD;&#xA;            string id = match.Groups[&quot;id&quot;].Value;&#xD;&#xA;            int searchStart = match.Index + match.Length;&#xD;&#xA;            // 正则 \G 用于确保仅从 searchStart 位置开始匹配紧随其后的名字&#xD;&#xA;            Match nameMatch = RegexName.Match(clipboardData, searchStart);&#xD;&#xA;&#xD;&#xA;            if (nameMatch.Success)&#xD;&#xA;            {&#xD;&#xA;                string name = nameMatch.Groups[&quot;name&quot;].Value;&#xD;&#xA;                if (!id2Name.TryGetValue(id, out string currentName) || currentName == &quot;&quot;)&#xD;&#xA;                {&#xD;&#xA;                    id2Name[id] = name;&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    if (currentName != name)&#xD;&#xA;                    {&#xD;&#xA;                        MessageBox.Show($&quot;ID {id} name inconsistent: '{currentName}' vs '{name}'&quot;);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                if (!id2Name.ContainsKey(id))&#xD;&#xA;                {&#xD;&#xA;                    id2Name[id] = &quot;&quot;;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // 读取当前小队列表，如果记录的所有 id 均在小队列表中，则用小队列表的顺序替换&#xD;&#xA;        var party = Triggernometry.Interpreter.StaticHelpers.GetListVariable(false, &quot;party&quot;)?.Values?.Select(v =&gt; v.ToString())?.ToList();&#xD;&#xA;        Dictionary&lt;string, int&gt; id2Idx;&#xD;&#xA;        if (party != null &amp;&amp; id2Name.Keys.All(id =&gt; party.Contains(id)))&#xD;&#xA;        {&#xD;&#xA;            id2Idx = id2Name.Keys.ToDictionary(id =&gt; id, id =&gt; party.IndexOf(id) + 1);&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            id2Idx = id2Name.Keys&#xD;&#xA;                .Select((id, idx) =&gt; (id, idx))&#xD;&#xA;                .ToDictionary(pair =&gt; pair.id, pair =&gt; pair.idx + 1);&#xD;&#xA;            &#xD;&#xA;            // 试图修正自己的 idx&#xD;&#xA;            do&#xD;&#xA;            {&#xD;&#xA;                // 获取自己在当前小队列表的序号&#xD;&#xA;                var myId = Triggernometry.FFXIV.Entity.MyHexID;&#xD;&#xA;                var myIdx = party?.IndexOf(Triggernometry.FFXIV.Entity.MyHexID) ?? -1;&#xD;&#xA;                myIdx++;&#xD;&#xA;                RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e myIdx = {myIdx}&quot;);&#xD;&#xA;                if (myIdx &lt;= 0) break;&#xD;&#xA;&#xD;&#xA;                // 查找当前占用了自身 idx 的 id&#xD;&#xA;                var otherPair = id2Idx.FirstOrDefault(pair =&gt; pair.Value == myIdx);&#xD;&#xA;                if (!otherPair.Equals(default(KeyValuePair&lt;string, int&gt;))) // 有人占用了自身 idx&#xD;&#xA;                {&#xD;&#xA;                    if (id2Name.ContainsKey(myId)) // 日志包含自己：二人对换&#xD;&#xA;                    {&#xD;&#xA;                        id2Idx[otherPair.Key] = id2Idx[myId];&#xD;&#xA;                        id2Idx[myId] = myIdx;&#xD;&#xA;                    }&#xD;&#xA;                    else if (id2Idx.Count &lt;= party.Count) // 日志没包含自己，且日志不满小队人数&#xD;&#xA;                    {&#xD;&#xA;                        id2Idx[otherPair.Key] = id2Idx.Count + 1;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                else // 没有人占用了自身 idx&#xD;&#xA;                {&#xD;&#xA;                    if (id2Name.ContainsKey(myId)) // 日志包含自己&#xD;&#xA;                    {&#xD;&#xA;                        id2Idx[myId] = myIdx;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            } while (false);&#xD;&#xA;        }&#xD;&#xA;/*&#xD;&#xA;        // 替换自身 id 与名字&#xD;&#xA;        if (Triggernometry.FFXIV.Entity.MyID != 0)&#xD;&#xA;        {&#xD;&#xA;            var id = Triggernometry.FFXIV.Entity.MyHexID;&#xD;&#xA;            var name = Triggernometry.FFXIV.Entity.MyName;&#xD;&#xA;            clipboardData = clipboardData.Replace($&quot;{id}:{name}&quot;, &quot;$&quot; + &quot;{_me.id}:自身&quot;);&#xD;&#xA;            clipboardData = clipboardData.Replace(id, &quot;$&quot; + &quot;{_me.id}&quot;);&#xD;&#xA;            if (clipboardData.Contains(name)) // 自己的 id 变动了&#xD;&#xA;            { &#xD;&#xA;                var regexMe = new Regex(@&quot;(?&lt;id&gt;10[0-9A-F]{6}):&quot; + Regex.Escape(name) + @&quot;(?=:|$)&quot;);&#xD;&#xA;                var myIds = regexMe.Matches(clipboardData).Cast&lt;Match&gt;().Select(m =&gt; m.Groups[&quot;id&quot;].Value).ToList();&#xD;&#xA;                var hashset = new HashSet&lt;string&gt;(myIds);&#xD;&#xA;                if (hashset.Count &gt; 1)&#xD;&#xA;                { &#xD;&#xA;                    MessageBox.Show($&quot;发现自身名字 \&quot;{name}\&quot; 对应多个 ID：\n{string.Join(&quot;\n&quot;, hashset)}&quot;);&#xD;&#xA;                }&#xD;&#xA;                id = hashset.FirstOrDefault();&#xD;&#xA;                if (id != null)&#xD;&#xA;                {&#xD;&#xA;                    clipboardData = clipboardData.Replace(id, &quot;$&quot; + &quot;{_me.id}&quot;); &#xD;&#xA;                }&#xD;&#xA;                clipboardData = clipboardData.Replace(name, &quot;自身&quot;);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;*/&#xD;&#xA;        // 替换小队 id 与名字&#xD;&#xA;        foreach (var pair in id2Idx)&#xD;&#xA;        {&#xD;&#xA;            string id = pair.Key;&#xD;&#xA;            int idx = pair.Value;&#xD;&#xA;            if (id2Name.TryGetValue(id, out string name) &amp;&amp; name != &quot;&quot;)&#xD;&#xA;            {&#xD;&#xA;                clipboardData = clipboardData.Replace($&quot;{id}:{name}&quot;, &quot;$&quot; + $&quot;{{l:party[{idx}]}}:队员&quot;);&#xD;&#xA;            }&#xD;&#xA;            clipboardData = clipboardData.Replace(id, &quot;$&quot; + $&quot;{{l:party[{idx}]}}&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // 输出&#xD;&#xA;        if (string.IsNullOrEmpty(clipboardData))&#xD;&#xA;        {&#xD;&#xA;            Clipboard.Clear();&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            Clipboard.SetText(clipboardData);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    [STAThread]&#xD;&#xA;    public static void Main()&#xD;&#xA;    {&#xD;&#xA;        Thread thread = new Thread(() =&gt;&#xD;&#xA;        {&#xD;&#xA;            Anonymize();&#xD;&#xA;        });&#xD;&#xA;        thread.SetApartmentState(ApartmentState.STA);&#xD;&#xA;        thread.Start();&#xD;&#xA;        thread.Join();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Triggernometry.RealPlugin.plug.RegisterNamedCallback(nameof(LogAnonymizer), new System.Action&lt;object, string&gt;((_, __) =&gt; LogAnonymizer.Main()), &quot;MnFeN 阿洛&quot;);" ActionType="ExecuteScript" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:LogAnonymizer}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="8" NamedCallbackName="LogAnonymizer" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="9" UseTTSTextExpression="处理完成" ActionType="UseTTS" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="查询表达式 /e 数学表达式 =?   /e 文本表达式 ==?" Id="69773161-db58-49d5-ab22-567d618d5d68" RegularExpression="^.{15}\S+ 00:0038::(?&lt;what&gt;.+?) *(?&lt;eq&gt;={1,2}) *[\?？] *$">
<Actions>
<Action OrderNumber="1" JsonEndpointExpression="http://127.0.0.1:2019/command" NamedCallbackName="command" NamedCallbackParam="/e == ${what}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${eq}" ExpressionTypeL="String" ExpressionR="==" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Action>
<Action OrderNumber="2" JsonEndpointExpression="http://127.0.0.1:2019/command" NamedCallbackName="command" NamedCallbackParam="/e = ${n:${what}}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${eq}" ExpressionTypeL="String" ExpressionR="=" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Action>
</Actions>
</Trigger>
<Trigger Enabled="true" Name="内存检索/修改" Id="aa77f167-61b1-462a-9142-96430ede9323" RegularExpression="^.{15}\S+ 00:0038::(?&lt;type&gt;byte|u?short|u?int|u?long|float|double) (?&lt;offset&gt;[^=]+?)( *= *(?&lt;val&gt;.+))?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="查询或修改自己选中的实体（或没选中时：自己）的内存中某处的值" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="查询：/e float 0xc4 （查询自己实体后 0xC4 位置的 float 值）" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="写入：/e float 0xc4 = 2 （自己实体后 0xC4 位置的 float 值写为 2）" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Asynchronous="False" Description="多级指针 如：/e float 0x100, 0x50 意为 Read&lt;IntPtr&gt;(entityAddress + 0x100) + 0x50" DescriptionOverride="True" />
<Action OrderNumber="5" ExecScriptExpression="using System;&#xD;&#xA;using System.Linq;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using Triggernometry.Utilities;&#xD;&#xA;&#xD;&#xA;static void Log(string msg) =&gt; Triggernometry.RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, &quot;/e \n&quot; + msg);&#xD;&#xA;&#xD;&#xA;string s = &quot;${_entity[${_me.targetid}].address}&quot;;&#xD;&#xA;var tgtaddress = s.Length &lt;= 1 ? ${_me.address} : 0${_entity[${_me.targetid}].address};&#xD;&#xA;var offsets = &quot;${offset}&quot;.Split(',').Select(str =&gt; (int)MathParser.Parse(str)).ToList();&#xD;&#xA;var address = (IntPtr)tgtaddress + offsets[0];&#xD;&#xA;&#xD;&#xA;for (int i = 1; i &lt; offsets.Count; i++)&#xD;&#xA;{&#xD;&#xA;    address = Memory.Read&lt;IntPtr&gt;(Memory.XivProcHandle, address) + offsets[i];&#xD;&#xA;}&#xD;&#xA;string tgtValueStr = &quot;${val}&quot;.Trim();&#xD;&#xA;var current = Memory.Read&lt;${type}&gt;(Memory.XivProcHandle, address);&#xD;&#xA;string msg = $&quot;{tgtaddress.ToString(&quot;X&quot;)} + {string.Join(&quot;, &quot;, offsets.Select(o =&gt; o.ToString(&quot;X&quot;)))} =&gt; {address.ToString(&quot;X&quot;)}:\n    Prev: (${type}){current}&quot;;&#xD;&#xA;&#xD;&#xA;if (&quot;${type}&quot; == &quot;byte&quot;)&#xD;&#xA;{&#xD;&#xA;    msg += $&quot; ({Convert.ToString((byte)current, 2).PadLeft(8, '0')})&quot;;&#xD;&#xA;}&#xD;&#xA;if (!string.IsNullOrEmpty(tgtValueStr))&#xD;&#xA;{&#xD;&#xA;    ${type} value = (${type})MathParser.Parse(tgtValueStr);&#xD;&#xA;    Memory.Write&lt;${type}&gt;(Memory.XivProcHandle, address, value);&#xD;&#xA;    msg += $&quot;\n    Set to: {value}&quot;;&#xD;&#xA;    if (&quot;${type}&quot; == &quot;byte&quot;)&#xD;&#xA;    {&#xD;&#xA;        msg += $&quot; ({Convert.ToString((byte)value, 2).PadLeft(8, '0')})&quot;;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;Log(msg);" ActionType="ExecuteScript" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="进制转换：10→16  /e 数学表达式 = 0x?" Id="cd820da9-c21c-4e67-b7f1-9993883c1c71" RegularExpression="^.{15}\S+ 00:0038::(?&lt;what&gt;.+?) *= *0x[?？] *$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="command" NamedCallbackParam="/e $1 = 0x${f:dec2hex:$1}" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="模拟区域切换" Id="8514312a-0095-4417-bae4-84c4b3b8b346" RegularExpression="^.{15}\S+ 00:0038::(?i) *zone +(?&lt;zoneId&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="e.g. /e zone 1238    /e zone 0x4D6" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="可以将触发器内部的当前区域 ID 设置为指定 ID，使限制区域 ID 的触发器临时可工作，用于调试触发器" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="目前只能换 id，同时建议不要用 name 限制以免适配多客户端带来不必要的麻烦" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Asynchronous="False" Description="想重置时游戏内正常切换区域即可" DescriptionOverride="True" />
<Action OrderNumber="5" ExecScriptExpression="Triggernometry.RealPlugin.plug.ZoneChangeDelegate(${n: ${zoneId}}, &quot;TestZone&quot;);" ActionType="ExecuteScript" />
<Action OrderNumber="6" NamedCallbackName="command" NamedCallbackParam="/e Simulating Zone: ${_ffxivzoneid} (0x${f:dec2hex:${_ffxivzoneid}})" ActionType="NamedCallback" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="b4abd59c-4554-4afe-97fd-ca967d15035f" DisableRemoteToggle="True" Name="高级标点工具箱 AdvWm v4.7.1" Enabled="true" RawEnvironmentVariables="version = 4.7.1">
<Folders>
<Folder Id="6b0de899-f15f-4274-8287-f6b7c1461a95" DisableRemoteExpand="True" DisableRemoteToggle="True" Name="core" Enabled="true">
<Folders>
<Folder Id="fc38c328-5121-45af-80c4-b2414dca87b2" Name="WaymarkEncoder" Enabled="true">
<Folders>
<Folder Id="18f9df43-177e-4ae8-9f3e-a574639433d7" Name="user" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="2. 应答 + 播报" Id="6b34bf54-57ba-427d-add9-0dd61d500486" RegularExpression="^.{15}\S+ 1C:Add:0:.{8}:[^:]*:(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="Action: Answer" ActionType="NamedCallback" />
<Action OrderNumber="2" NamedCallbackName="AdvWm" NamedCallbackParam="Action: GetUsers" ActionType="NamedCallback" ExecutionDelayExpression="2000" />
<Action OrderNumber="3" ListVariableName="AdvWm_users" ActionType="ListVariable" />
<Action OrderNumber="4" NamedCallbackName="AdvWm" NamedCallbackParam="A: ${v:AdvWm_A}&#xD;&#xA;public: true" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ev:AdvWm_A}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="5" VariableName="AdvWm_A" ActionType="Variable" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="abs(${z})" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="3. 接收" Id="814e7f84-6f65-4b31-9201-d14d2d65b13a" RegularExpression="^.{15}\S+ 1C:Add:0:.{8}:[^:]*:(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" ListVariableOp="Push" ListVariableName="AdvWm_users" ListVariableExpression="${f:dec2hex8:${n: (round(${x} * 100) - 8000) * 0x1000 + (round(${y} * 100) - 8000) + 0x10000000}}, ${n: round(${z}, 2)}" ActionType="ListVariable" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="abs(${z})" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="abs(${z})" ExpressionTypeL="Numeric" ExpressionR="0.14" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="1. 询问" Id="4e73bc73-6034-45b1-9030-2c01d7458c6f" RegularExpression="^.{15}\S+ 00:0038::(?&lt;user&gt;[!?！？]user)$">
<Actions>
<Action OrderNumber="1" TriggerOp="EnableTrigger" TriggerId="6b34bf54-57ba-427d-add9-0dd61d500486" ActionType="Trigger" Description="? 是匿名" DescriptionOverride="True" />
<Action OrderNumber="2" TriggerOp="EnableTrigger" TriggerId="814e7f84-6f65-4b31-9201-d14d2d65b13a" ActionType="Trigger" Description="! 是实名" DescriptionOverride="True" />
<Action OrderNumber="3" VariableOp="SetString" VariableName="AdvWm_A" VariableExpression="${if: ${_wm[A].active} ? ${_wm[A].pos} : clear}" ActionType="Variable" />
<Action OrderNumber="4" NamedCallbackName="AdvWm" NamedCallbackParam="Action: ${if: ${f:startwith(?):${f:tohalfwidth:${user}}} ? AskAnonymous : Ask }" ActionType="NamedCallback" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="4cc7f4b0-79a5-4f91-b2f2-714b4bffbb5c" Name="tell" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="2. 接收" Id="32d371ce-48a1-49d4-8676-9846ebd8d57a" RegularExpression="^.{15}\S+ 1C:Add:0:(?&lt;id&gt;.{8}):(?&lt;name&gt;[^:]*):(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="Action: Decode&#xD;&#xA;Sender: ${name} (${_entity[${id}].jobEN3})" ActionType="NamedCallback" ExecutionDelayExpression="500" />
</Actions>
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${x}" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${y}" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="1. 发送" Id="31409b0e-0d0f-44fa-a5e4-510d27b5d29d" RegularExpression="^.{15}\S+ 00:0038::(?&lt;tell&gt;[!?！？]tell) (?&lt;msg&gt;.+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="Action: ${if: ${f:startwith(?):${f:tohalfwidth:${tell}}} ? EncodeAnonymous : Encode }&#xD;&#xA;Data: ${msg}" ActionType="NamedCallback" />
<Action OrderNumber="2" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers />
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="注册回调" Id="ac677599-01db-4f97-8807-6047ec302591" RegularExpression="^.{15}\S+ 01:">
<Actions>
<Action OrderNumber="1" ExecScriptExpression="using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Text;&#xD;&#xA;using System.Text.RegularExpressions;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using static System.Math;&#xD;&#xA;using Triggernometry.PluginBridges;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;&#xD;&#xA;public struct Info&#xD;&#xA;{&#xD;&#xA;    public const string Name = &quot;AdvWm&quot;;&#xD;&#xA;    public const string NameCN = &quot;高级标点工具箱&quot;;&#xD;&#xA;    public const string Version = &quot;${env:version}&quot;;&#xD;&#xA;    public const string Author = &quot;阿洛 MnFeN&quot;;&#xD;&#xA;&#xD;&#xA;    public static string InitInfo =&gt; $&quot;{Name}：{NameCN} v{Version} by {Author} 已成功初始化。&quot;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;RealPlugin.plug.RegisterNamedCallback(&quot;AdvWm&quot;, new Action&lt;object, string&gt;(AdvWm.NamedCallback), null, registrant: $&quot;{Info.NameCN} v{Info.Version}&quot;);&#xD;&#xA;RealPlugin.plug.InvokeNamedCallback(&quot;NamazuLog&quot;, Info.InitInfo);&#xD;&#xA;Interpreter.StaticHelpers.Log(RealPlugin.DebugLevelEnum.Custom, Info.InitInfo);&#xD;&#xA;&#xD;&#xA;public class AdvWm&#xD;&#xA;{&#xD;&#xA;    string _command;&#xD;&#xA;    /// &lt;summary&gt; All keys are in lowercase. &lt;/summary&gt;&#xD;&#xA;    Dictionary&lt;string, string&gt; _argsDict;&#xD;&#xA;    string _action = &quot;&quot;;&#xD;&#xA;    bool _log = true;&#xD;&#xA;    bool _local = true;&#xD;&#xA;&#xD;&#xA;    public AdvWm(string command)&#xD;&#xA;    {&#xD;&#xA;        _command = command;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Log(string message) =&gt; RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e {message}&quot;);&#xD;&#xA;&#xD;&#xA;    public static void NamedCallback(object _, string input)&#xD;&#xA;    {&#xD;&#xA;        var commands = input.Split(new string[] { &quot;---&quot; }, StringSplitOptions.None);&#xD;&#xA;        foreach (var command in commands)&#xD;&#xA;        {&#xD;&#xA;            new AdvWm(command).Execute();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static readonly HashSet&lt;string&gt; postNamazuWaymarkKeywords = new HashSet&lt;string&gt; {&#xD;&#xA;        &quot;save&quot;, &quot;backup&quot;, &quot;load&quot;, &quot;restore&quot;, &quot;reset&quot;, &quot;clear&quot;, &quot;public&quot;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private void Execute()&#xD;&#xA;    {&#xD;&#xA;        string simpleCmd = _command.ToLower().Trim();&#xD;&#xA;        if (postNamazuWaymarkKeywords.Contains(simpleCmd))&#xD;&#xA;        {&#xD;&#xA;            RealPlugin.plug.InvokeNamedCallback(&quot;place&quot;, simpleCmd);&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        _argsDict = _command.Split('\n')&#xD;&#xA;            .Where(line =&gt; line.Contains(&quot;:&quot;) &amp;&amp; !line.StartsWith(&quot;//&quot;))&#xD;&#xA;            .ToDictionary(&#xD;&#xA;                line =&gt; line.Substring(0, line.IndexOf(':')).Trim().ToLower(),&#xD;&#xA;                line =&gt; line.Substring(line.IndexOf(':') + 1).Trim()&#xD;&#xA;            );&#xD;&#xA;&#xD;&#xA;        // 解析共通参数&#xD;&#xA;        TryGetArg(&quot;Action&quot;, out _action);&#xD;&#xA;        _log = !TryGetArg(&quot;Log&quot;, out string log) || bool.Parse(log.ToLower());&#xD;&#xA;        _local = !TryGetArg(&quot;Local&quot;, &quot;LocalOnly&quot;, out string local) || bool.Parse(local.ToLower());&#xD;&#xA;&#xD;&#xA;        Waymarks waymarks;&#xD;&#xA;        switch (_action?.ToLower() ?? &quot;&quot;)&#xD;&#xA;        {&#xD;&#xA;            case &quot;getversion&quot;:&#xD;&#xA;                Interpreter.StaticHelpers.SetScalarVariable(isPersistent: false, $&quot;{Info.Name}_version&quot;, Info.Version); return;&#xD;&#xA;            case &quot;encode&quot;:&#xD;&#xA;                WaymarksEncoder.EncodeAndSendWaymarks(GetArg(&quot;data&quot;), false); return;&#xD;&#xA;            case &quot;encodeanonymous&quot;:&#xD;&#xA;                WaymarksEncoder.EncodeAndSendWaymarks(GetArg(&quot;data&quot;), true); return;&#xD;&#xA;            case &quot;decode&quot;:&#xD;&#xA;                string sender = GetArg(&quot;sender&quot;);&#xD;&#xA;                WaymarksEncoder.DecodeFromWaymarksAndShow(); return;&#xD;&#xA;            case &quot;ask&quot;:&#xD;&#xA;                WaymarksEncoder.Ask(false); return;&#xD;&#xA;            case &quot;askanonymous&quot;:&#xD;&#xA;                WaymarksEncoder.Ask(true); return;&#xD;&#xA;            case &quot;answer&quot;:&#xD;&#xA;                WaymarksEncoder.Answer(); return;&#xD;&#xA;            case &quot;getusers&quot;:&#xD;&#xA;                WaymarksEncoder.GetUsersResult(); return;&#xD;&#xA;            case &quot;polar&quot;: // 不推荐使用，仅为兼容旧版本，可被 default 模式完全替代&#xD;&#xA;                waymarks = ParseWaymarksPolar(); break;&#xD;&#xA;            case &quot;circle&quot;:&#xD;&#xA;                waymarks = ParseWaymarksCircle(); break;&#xD;&#xA;            case &quot;arc&quot;:&#xD;&#xA;                waymarks = ParseWaymarksArc(); break;&#xD;&#xA;            case &quot;linear&quot;:&#xD;&#xA;            case &quot;connect&quot;:&#xD;&#xA;            case &quot;linearconnect&quot;:&#xD;&#xA;                waymarks = ParseWaymarksLinearConnect(); break;&#xD;&#xA;            // case &quot;absolute&quot;:  case &quot;relative&quot;:  case &quot;place&quot;: 旧版本的指令全部整合为默认的标点模式&#xD;&#xA;            default:&#xD;&#xA;                waymarks = ParseWaymarksDefault(); break;&#xD;&#xA;        }&#xD;&#xA;        // Log($&quot;初始：\n{waymarks}&quot;);&#xD;&#xA;        TryApplyScales(waymarks);&#xD;&#xA;        // Log($&quot;伸缩：\n{waymarks}&quot;);&#xD;&#xA;        TryApplyRotation(waymarks);&#xD;&#xA;        // Log($&quot;旋转：\n{waymarks}&quot;);&#xD;&#xA;        TryApplyCenter(waymarks);&#xD;&#xA;        // Log($&quot;平移：\n{waymarks}&quot;);&#xD;&#xA;        waymarks.LocalOnly = _local;&#xD;&#xA;        waymarks.Log = _log;&#xD;&#xA;        waymarks.Mark();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的所有坐标，生成一组初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksDefault()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        foreach (string name in Waymark.WaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (TryGetArg(name, out string rawCoord))&#xD;&#xA;            {&#xD;&#xA;                waymarks.Add(Waymark.Parse(name, rawCoord));&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的所有极坐标，生成一组初始标点。建议使用 Default 替代。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksPolar()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        foreach (string name in Waymark.WaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (TryGetArg(name, out string rawPolarCoord))&#xD;&#xA;            {   // 已重构为接近正常方法的处理逻辑&#xD;&#xA;                XIVCoord polarCoord = XIVCoord.ParseRawData(rawPolarCoord.StartsWith(&quot;polar &quot;) ? rawPolarCoord : $&quot;polar {rawPolarCoord}&quot;);&#xD;&#xA;                waymarks.Add(new Waymark(name, polarCoord.ToCartesian()));&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的半径和标点名，生成一组排列成圆周的初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksCircle()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        double rCardinal = MathParser.Parse(GetArg(&quot;R&quot;));&#xD;&#xA;        double rIntercard = TryGetArg(&quot;R2&quot;, out string rawR2) ? MathParser.Parse(rawR2) : rCardinal;&#xD;&#xA;        string[] usedWaymarkNames = GetArg(&quot;Waymarks&quot;).Select(c =&gt; char.ToLower(c).ToString()).ToArray(); // 用哪些点 相对正北逆时针 如 A4D3C2B1&#xD;&#xA;        double step = 2 * PI / usedWaymarkNames.Length; // 相邻标点的角度差&#xD;&#xA;        int count = 0;&#xD;&#xA;        foreach (string name in usedWaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (Waymark.WaymarkNames.Contains(name))&#xD;&#xA;            {&#xD;&#xA;                var r = (count &amp; 1) == 0 ? rCardinal : rIntercard;&#xD;&#xA;                var θ = count * step - PI;&#xD;&#xA;                waymarks.Add(new Waymark(name, new PolarCoord(r, θ, 0)));&#xD;&#xA;            }&#xD;&#xA;            count++;&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的半径、标点名、圆心角，生成一组排列成弧线的初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksArc()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        double r = MathParser.Parse(GetArg(&quot;R&quot;));   // 半径&#xD;&#xA;        string[] usedWaymarkNames = GetArg(&quot;Waymarks&quot;).Select(c =&gt; char.ToLower(c).ToString()).ToArray(); // 用哪些点 相对正北逆时针 如 A4D3C2B1&#xD;&#xA;        int stepCount = usedWaymarkNames.Length - 1;&#xD;&#xA;&#xD;&#xA;        // 圆弧的圆心角，不提供的时候默认为使标点紧邻的角度（弧长约 2.6）&#xD;&#xA;        double dθ = TryGetArg(&quot;dθ&quot;, &quot;dTheta&quot;, out string rawdθ) ? MathParser.Parse(rawdθ) : (stepCount &gt;= 1) ? 2.6 / r * stepCount : 0;&#xD;&#xA;        double θStep = (stepCount &gt;= 1) ? dθ / stepCount : 0; // 相邻标点的角度差&#xD;&#xA;        int count = 0;&#xD;&#xA;        foreach (string name in usedWaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (Waymark.WaymarkNames.Contains(name)) // 允许使用非标点名的字符占位等分点，不会生成标点&#xD;&#xA;            {&#xD;&#xA;                PolarCoord polarCoord = new PolarCoord(r, (count - stepCount / 2.0) * θStep - PI, 0);&#xD;&#xA;                waymarks.Add(new Waymark(name, polarCoord));&#xD;&#xA;            }&#xD;&#xA;            count++;&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的起点、终点、标点名，生成线性插值的初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksLinearConnect()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        string[] usedWaymarkNames = GetArg(&quot;Waymarks&quot;).Select(c =&gt; char.ToLower(c).ToString()).ToArray(); // 用哪些点 起点到终点 如 A4D3C2B1&#xD;&#xA;        if (usedWaymarkNames.Length &lt; 2)&#xD;&#xA;        {&#xD;&#xA;            throw new Exception(&quot;AdvWm: LinearConnect 模式下，提供的标点数量不足 2&quot;);&#xD;&#xA;        }&#xD;&#xA;        XIVCoord startCoord = XIVCoord.ParseRawData(GetArg(&quot;start&quot;));&#xD;&#xA;        XIVCoord endCoord = XIVCoord.ParseRawData(GetArg(&quot;end&quot;));&#xD;&#xA;        XIVCoord vector = endCoord - startCoord;&#xD;&#xA;        double totalDistance = vector.Length;&#xD;&#xA;        // Log($&quot;{vector}&quot;);&#xD;&#xA;        int count = 0;&#xD;&#xA;        foreach (string name in usedWaymarkNames)  // A B C D 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (Waymark.WaymarkNames.Contains(name))&#xD;&#xA;            {&#xD;&#xA;                double percentage = (double)count / (usedWaymarkNames.Length - 1);  // 标点默认等分&#xD;&#xA;                if (TryGetArg(name, out string rawDistance))   // 也可以不等分，自定义标点位置&#xD;&#xA;                {&#xD;&#xA;                    if (rawDistance.EndsWith(&quot; m&quot;))      // 以 A: 5 m 形式提供的距离&#xD;&#xA;                    {&#xD;&#xA;                        // @d 代表总长度，如 A: @d - 5 m 意为终点前 5 m&#xD;&#xA;                        string strTotalDistance = totalDistance.ToString(MathParser.CultureInfo);&#xD;&#xA;                        rawDistance = rawDistance.Replace(&quot;@d&quot;, strTotalDistance);&#xD;&#xA;                        double distance = MathParser.Parse(rawDistance.Substring(0, rawDistance.Length - 2));&#xD;&#xA;                        percentage = distance / totalDistance;&#xD;&#xA;                    }&#xD;&#xA;                    else                                // 以 A: 0.125 形式提供的百分比&#xD;&#xA;                    {&#xD;&#xA;                        percentage = MathParser.Parse(rawDistance);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                XIVCoord coord = startCoord + percentage * vector;&#xD;&#xA;                waymarks.Add(new Waymark(name, coord));&#xD;&#xA;            }&#xD;&#xA;            count++;&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 如果当前指令提供了任何伸缩，将伸缩变换应用到给定的一组标点坐标。 &lt;/summary&gt;&#xD;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xD;&#xA;    private void TryApplyScales(Waymarks waymarks)&#xD;&#xA;    {&#xD;&#xA;        // 首先尝试解析 Scale 和具体的 ScaleX, ScaleY, ScaleZ 参数&#xD;&#xA;        bool hasScale = TryGetArg(&quot;Scale&quot;, out string rawScale);&#xD;&#xA;        bool hasScaleX = TryGetArg(&quot;ScaleX&quot;, out string rawScaleX);&#xD;&#xA;        bool hasScaleY = TryGetArg(&quot;ScaleY&quot;, out string rawScaleY);&#xD;&#xA;        bool hasScaleZ = TryGetArg(&quot;ScaleZ&quot;, out string rawScaleZ);&#xD;&#xA;&#xD;&#xA;        // 未给定参数则免去解析直接返回&#xD;&#xA;        if (!hasScale &amp;&amp; !hasScaleX &amp;&amp; !hasScaleY &amp;&amp; !hasScaleZ) return;&#xD;&#xA;&#xD;&#xA;        // 如果存在 scale 参数，按照 scaleX ?? scale ?? 1 的优先级解析&#xD;&#xA;        double defaultScale = hasScale ? MathParser.Parse(rawScale) : 1;&#xD;&#xA;&#xD;&#xA;        double scaleX = hasScaleX ? MathParser.Parse(rawScaleX) : defaultScale;&#xD;&#xA;        double scaleY = hasScaleY ? MathParser.Parse(rawScaleY) : defaultScale;&#xD;&#xA;        double scaleZ = hasScaleZ ? MathParser.Parse(rawScaleZ) : defaultScale;&#xD;&#xA;&#xD;&#xA;        // 如果任一缩放倍率不是 1，则缩放&#xD;&#xA;        if (Abs(scaleX - 1) &gt; 1e-5 || Abs(scaleY - 1) &gt; 1e-5 || Abs(scaleZ - 1) &gt; 1e-5)&#xD;&#xA;        {&#xD;&#xA;            foreach (Waymark wm in waymarks)&#xD;&#xA;            {&#xD;&#xA;                wm.Coord = wm.Coord.ScaleBy(scaleX, scaleY, scaleZ);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 如果当前指令提供了旋转，将伸缩变换应用到给定的一组标点坐标。 &lt;/summary&gt;&#xD;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xD;&#xA;    private void TryApplyRotation(Waymarks waymarks)&#xD;&#xA;    {&#xD;&#xA;        if (TryGetArg(&quot;θ&quot;, &quot;Theta&quot;, out string rawθ))&#xD;&#xA;        {&#xD;&#xA;            double θ = MathParser.Parse(rawθ);&#xD;&#xA;            foreach (Waymark wm in waymarks)&#xD;&#xA;            {&#xD;&#xA;                wm.Coord = wm.Coord.RotateTo(θ);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 如果当前指令提供了场地中心，将场地中心应用到给定的一组标点坐标。 &lt;/summary&gt;&#xD;&#xA;    void TryApplyCenter(Waymarks waymarks)&#xD;&#xA;    {&#xD;&#xA;        if (TryGetArg(&quot;O&quot;, &quot;Center&quot;, out string rawCenter))&#xD;&#xA;        {&#xD;&#xA;            XIVCoord centerCoord = XIVCoord.ParseRawData(rawCenter);&#xD;&#xA;            foreach (Waymark wm in waymarks)&#xD;&#xA;            {&#xD;&#xA;                wm.Coord = wm.Coord.MoveTo(centerCoord);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    string GetArg(params string[] keys)&#xD;&#xA;    {&#xD;&#xA;        string key = keys.Select(k =&gt; k.ToLower()).FirstOrDefault(k =&gt; _argsDict.ContainsKey(k))&#xD;&#xA;            ?? throw new ArgumentException($&quot;AdvWm: 未提供指定的必需参数 {string.Join(&quot; / &quot;, keys)}。&quot;);&#xD;&#xA;        return _argsDict[key];&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    bool TryGetArg(string key, out string value)&#xD;&#xA;    {&#xD;&#xA;        key = key.ToLower();&#xD;&#xA;        return _argsDict.TryGetValue(key, out value);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    bool TryGetArg(string key, string alternativeKey, out string value)&#xD;&#xA;    {&#xD;&#xA;        if (TryGetArg(key, out value))&#xD;&#xA;        {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;        return TryGetArg(alternativeKey, out value);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#region XIVCoord&#xD;&#xA;&#xD;&#xA;public abstract class XIVCoord&#xD;&#xA;{&#xD;&#xA;    //public abstract XIVCoord Copy();&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 将初始坐标视为相对坐标。&lt;br/&gt;&#xD;&#xA;    /// 将相对坐标系的正北（θ = ±pi）在平面内旋转至给定方向 &lt;paramref str=&quot;θ&quot;/&gt;。&lt;br/&gt;&lt;br/&gt;&#xD;&#xA;    /// 方向角度 &lt;paramref str=&quot;θ&quot;/&gt; 为游戏内标准，如：&lt;br/&gt;&#xD;&#xA;    /// · 正北（不旋转）= ±pi；&lt;br/&gt;&#xD;&#xA;    /// · 正南（旋转 180 度）= 0；&lt;br/&gt;&#xD;&#xA;    /// · 正东（顺时针旋转 90 度）= pi/2。&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    /// &lt;param str=&quot;theta&quot;&gt;将初始相对坐标系的正北（-pi）旋转到的方向角度。&lt;/param&gt;&#xD;&#xA;    public abstract XIVCoord RotateTo(double θ);&#xD;&#xA;    public abstract XIVCoord MoveTo(double dx, double dy, double dz);&#xD;&#xA;    public XIVCoord MoveTo(XIVCoord center) =&gt; this + center;&#xD;&#xA;    public abstract XIVCoord ScaleBy(double scaleX, double scaleY, double scaleZ);&#xD;&#xA;    public abstract CartesianCoord ToCartesian();&#xD;&#xA;    public abstract PolarCoord ToPolar();&#xD;&#xA;    public abstract double Length { get; }&#xD;&#xA;    public abstract string Jsonify();&#xD;&#xA;    public abstract override string ToString();&#xD;&#xA;&#xD;&#xA;    public static CartesianCoord operator +(XIVCoord a, XIVCoord b)&#xD;&#xA;    {&#xD;&#xA;        CartesianCoord cartesianA = a.ToCartesian();&#xD;&#xA;        CartesianCoord cartesianB = b.ToCartesian();&#xD;&#xA;&#xD;&#xA;        return new CartesianCoord(&#xD;&#xA;            cartesianA.X + cartesianB.X,&#xD;&#xA;            cartesianA.Y + cartesianB.Y,&#xD;&#xA;            cartesianA.Z + cartesianB.Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static CartesianCoord operator -(XIVCoord a, XIVCoord b)&#xD;&#xA;    {&#xD;&#xA;        CartesianCoord cartesianA = a.ToCartesian();&#xD;&#xA;        CartesianCoord cartesianB = b.ToCartesian();&#xD;&#xA;&#xD;&#xA;        return new CartesianCoord(&#xD;&#xA;            cartesianA.X - cartesianB.X,&#xD;&#xA;            cartesianA.Y - cartesianB.Y,&#xD;&#xA;            cartesianA.Z - cartesianB.Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator -(XIVCoord a)&#xD;&#xA;    {&#xD;&#xA;        if (a is CartesianCoord cartesianA)&#xD;&#xA;        {&#xD;&#xA;            return new CartesianCoord(-cartesianA.X, -cartesianA.Y, -cartesianA.Z);&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            PolarCoord polarA = (PolarCoord)a;&#xD;&#xA;            return new PolarCoord(polarA.R, polarA.θ + PI, polarA.Z);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator *(XIVCoord a, double n)&#xD;&#xA;    {&#xD;&#xA;        if (a is CartesianCoord cartesianA)&#xD;&#xA;        {&#xD;&#xA;            return new CartesianCoord(cartesianA.X * n, cartesianA.Y * n, cartesianA.Z * n);&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            PolarCoord polarA = (PolarCoord)a;&#xD;&#xA;            return new PolarCoord(polarA.R * n, polarA.θ, polarA.Z);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator *(double n, XIVCoord a) =&gt; a * n;&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator /(XIVCoord a, double n) =&gt; a * (1.0 / n);&#xD;&#xA;&#xD;&#xA;    private static Regex rexOpKeywords = new Regex(@&quot;\b(plus|minus|polar|minuspolar)\b&quot;, RegexOptions.IgnoreCase | RegexOptions.Compiled);&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 将一串直角坐标、极坐标、或混合方式指定的坐标解析并叠加，如：&lt;br /&gt;&lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;: 10, -10, 0 &lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;: &lt;paramref str=&quot;polar&quot;/&gt; 20, -45°, 0&lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;: 10, -10, 0 &lt;paramref str=&quot;polar&quot;/&gt; 20, -45°（在直角坐标基础上叠加极坐标结果）&lt;br /&gt;&lt;br /&gt;&#xD;&#xA;    /// 字符串格式详见 &lt;paramref str=&quot;rawCoords&quot;/&gt;。&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    /// &lt;param str=&quot;rawCoords&quot;&gt;&#xD;&#xA;    /// 一串坐标字符串，可包含多组坐标。&lt;br /&gt;&#xD;&#xA;    /// 每组坐标之间以关键字连接，坐标分量之间以逗号连接。如：&lt;br /&gt;&lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;:     x, y, z  &#xD;&#xA;    /// &lt;paramref str=&quot;plus&quot;/&gt;   x2, y2  &#xD;&#xA;    /// &lt;paramref str=&quot;minus&quot;/&gt;  x3, y3, z3  &#xD;&#xA;    /// &lt;paramref str=&quot;polar&quot;/&gt;  r1, θ1&#xD;&#xA;    /// &lt;paramref str=&quot;minuspolar&quot;/&gt; r2, θ2, z2&lt;br /&gt;&#xD;&#xA;    /// &lt;/param&gt;&#xD;&#xA;    public static XIVCoord ParseRawData(string rawCoords)&#xD;&#xA;    {&#xD;&#xA;        // 例：x, y, z plus x2, y2 minus x3, y3, z3 polar r1, θ1 minuspolar r2, θ2, z2&#xD;&#xA;&#xD;&#xA;        List&lt;string&gt; parts = new List&lt;string&gt;();&#xD;&#xA;        string currentPart = &quot;&quot;;&#xD;&#xA;        int depth = 0;&#xD;&#xA;        foreach (char c in rawCoords)&#xD;&#xA;        {&#xD;&#xA;            switch (c)&#xD;&#xA;            {&#xD;&#xA;                case ',':&#xD;&#xA;                    if (depth == 0)&#xD;&#xA;                    {&#xD;&#xA;                        parts.Add(currentPart);&#xD;&#xA;                        currentPart = &quot;&quot;;&#xD;&#xA;                        continue;&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                case '(': depth++; break;&#xD;&#xA;                case ')': depth--; break;&#xD;&#xA;            }&#xD;&#xA;            currentPart += c;&#xD;&#xA;        }&#xD;&#xA;        parts.Add(currentPart);&#xD;&#xA;&#xD;&#xA;        if (depth != 0)&#xD;&#xA;        {&#xD;&#xA;            throw new Exception($&quot;AdvWm: 标点参数存在 {Abs(depth)} 个未闭合的{(depth &gt; 0 ? &quot;左&quot; : &quot;右&quot;)}括号。表达式：{rawCoords}&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // 此时：[x] [y] [z plus x2] [y2 minus x3] [y3] [z3 polar r] [θ] [z]&#xD;&#xA;&#xD;&#xA;        List&lt;XIVCoord&gt; coords = new List&lt;XIVCoord&gt;();&#xD;&#xA;        bool isCurrentPolar = false;&#xD;&#xA;        bool isCurrentPlus = true;&#xD;&#xA;        List&lt;string&gt; currentParams = new List&lt;string&gt;();&#xD;&#xA;&#xD;&#xA;        foreach (string part in parts)&#xD;&#xA;        {&#xD;&#xA;            string[] splitParts = rexOpKeywords.Split(part);&#xD;&#xA;&#xD;&#xA;            if (splitParts.Length == 3) // 找到操作符，拆分解析&#xD;&#xA;            {&#xD;&#xA;                string beforeOp = splitParts[0].Trim();&#xD;&#xA;                string operation = splitParts[1].Trim();&#xD;&#xA;                string afterOp = splitParts[2].Trim();&#xD;&#xA;&#xD;&#xA;                // 处理前部分&#xD;&#xA;                if (currentParams.Count != 0 || !string.IsNullOrEmpty(beforeOp)) // 不是形如 &quot;polar ...&quot; 的字符串开始位置&#xD;&#xA;                {&#xD;&#xA;                    currentParams.Add(beforeOp);&#xD;&#xA;                    XIVCoord coord = isCurrentPolar&#xD;&#xA;                        ? (XIVCoord)PolarCoord.Parse(currentParams.ToArray())&#xD;&#xA;                        : (XIVCoord)CartesianCoord.Parse(currentParams.ToArray());&#xD;&#xA;                    coords.Add(isCurrentPlus ? coord : -coord);&#xD;&#xA;                    currentParams.Clear();&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                // 处理操作符：是否是加法/极坐标操作&#xD;&#xA;                isCurrentPlus = !operation.StartsWith(&quot;minus&quot;);&#xD;&#xA;                isCurrentPolar = operation.EndsWith(&quot;polar&quot;);&#xD;&#xA;&#xD;&#xA;                // 处理后部分&#xD;&#xA;                currentParams.Add(afterOp);&#xD;&#xA;            }&#xD;&#xA;            else if (splitParts.Length == 1) // 未找到操作符，直接添加&#xD;&#xA;            {&#xD;&#xA;                currentParams.Add(splitParts[0].Trim());&#xD;&#xA;            }&#xD;&#xA;            else // 偷个懒，坐标最少两个参数，而只要有两个就会被逗号预先拆分，所以正常不会出现 1 3 以外的情况&#xD;&#xA;            {&#xD;&#xA;                throw new Exception($&quot;AdvWm: 标点参数解析时，关键字之间参数过少。\n表达式：{rawCoords}；\n出错位置：{part}&quot;);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        XIVCoord finalCoord = isCurrentPolar&#xD;&#xA;            ? (XIVCoord)PolarCoord.Parse(currentParams.ToArray())&#xD;&#xA;            : (XIVCoord)CartesianCoord.Parse(currentParams.ToArray());&#xD;&#xA;        coords.Add(isCurrentPlus ? finalCoord : -finalCoord);&#xD;&#xA;&#xD;&#xA;        // 此时：[Cartesian1] [Cartesian2] [Cartesian3] [Polar1]&#xD;&#xA;        return coords.Aggregate((c1, c2) =&gt; c1 + c2);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class CartesianCoord : XIVCoord&#xD;&#xA;{&#xD;&#xA;    public double X;&#xD;&#xA;    public double Y;&#xD;&#xA;    public double Z;&#xD;&#xA;&#xD;&#xA;    public string X_3 =&gt; X.ToString(&quot;0.###&quot;, System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;    public string Y_3 =&gt; Y.ToString(&quot;0.###&quot;, System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;    public string Z_3 =&gt; Z.ToString(&quot;0.###&quot;, System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;&#xD;&#xA;    public CartesianCoord(double x, double y, double z)&#xD;&#xA;    {&#xD;&#xA;        X = x; Y = y; Z = z;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord RotateTo(double θ)&#xD;&#xA;    {&#xD;&#xA;        var sin = Sin(θ);&#xD;&#xA;        var cos = Cos(θ);&#xD;&#xA;        (X, Y) = (-X * cos - Y * sin, X * sin - Y * cos);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord MoveTo(double dx, double dy, double dz)&#xD;&#xA;    {&#xD;&#xA;        X += dx;&#xD;&#xA;        Y += dy;&#xD;&#xA;        Z += dz;&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord ScaleBy(double scaleX, double scaleY, double scaleZ)&#xD;&#xA;    {&#xD;&#xA;        X *= scaleX;&#xD;&#xA;        Y *= scaleY;&#xD;&#xA;        Z *= scaleZ;&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override CartesianCoord ToCartesian() =&gt; new CartesianCoord(X, Y, Z);&#xD;&#xA;&#xD;&#xA;    public override PolarCoord ToPolar()&#xD;&#xA;    {&#xD;&#xA;        double r = Sqrt(X * X + Y * Y);&#xD;&#xA;        double θ = Atan2(X, Y);&#xD;&#xA;        return new PolarCoord(r, θ, Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override double Length =&gt; Sqrt(X * X + Y * Y + Z * Z);&#xD;&#xA;&#xD;&#xA;    public override string ToString() =&gt; $&quot;({X_3}, {Y_3}, {Z_3})&quot;;&#xD;&#xA;&#xD;&#xA;    public override string Jsonify() =&gt; $&quot;\&quot;X\&quot;: {X_3}, \&quot;Z\&quot;: {Y_3}, \&quot;Y\&quot;: {Z_3}, \&quot;Active\&quot;: true&quot;;&#xD;&#xA;&#xD;&#xA;    public static CartesianCoord Parse(params string[] coords)&#xD;&#xA;    {&#xD;&#xA;        switch (coords.Length)&#xD;&#xA;        {&#xD;&#xA;            case 2:&#xD;&#xA;                return ParseCoordsString(coords[0], coords[1]);&#xD;&#xA;            case 3:&#xD;&#xA;                return ParseCoordsString(coords[0], coords[1], coords[2]);&#xD;&#xA;            default:&#xD;&#xA;                throw Context.ArgCountError(&quot;CartesianCoord: 坐标构造函数&quot;, &quot;2-3&quot;, coords.Length, &quot;[&quot; + string.Join(&quot;], [&quot;, coords) + &quot;]&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static CartesianCoord ParseCoordsString(string rawX, string rawY, string rawZ = null)&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            return new CartesianCoord(&#xD;&#xA;                MathParser.Parse(rawX),&#xD;&#xA;                MathParser.Parse(rawY),&#xD;&#xA;                rawZ == null ? 0 : MathParser.Parse(rawZ));&#xD;&#xA;        }&#xD;&#xA;        catch (Exception ex)&#xD;&#xA;        {&#xD;&#xA;            throw new ArgumentException($&quot;AdvWm: 直角坐标解析错误：{ex.Message}\n&quot; +&#xD;&#xA;                $&quot;原始数据：\nx = ({rawX}), \ny = ({rawY}), \nz = ({rawZ ?? &quot;null&quot;})&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class PolarCoord : XIVCoord&#xD;&#xA;{&#xD;&#xA;    public double R;&#xD;&#xA;    public double θ;&#xD;&#xA;    public double Z;&#xD;&#xA;&#xD;&#xA;    public PolarCoord(double r, double θ, double z)&#xD;&#xA;    {&#xD;&#xA;        R = r; this.θ = θ; Z = z;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord RotateTo(double θ)&#xD;&#xA;    {&#xD;&#xA;        this.θ += θ + PI;&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord MoveTo(double dx, double dy, double dz)&#xD;&#xA;        =&gt; ToCartesian().MoveTo(dx, dy, dz);&#xD;&#xA;&#xD;&#xA;    public override XIVCoord ScaleBy(double scaleX, double scaleY, double scaleZ)&#xD;&#xA;    {&#xD;&#xA;        if (Abs(scaleX - scaleY) &lt; 1e-5 &amp;&amp; scaleX &gt;= 1e-4)&#xD;&#xA;        {&#xD;&#xA;            R *= scaleX;&#xD;&#xA;            Z *= scaleZ;&#xD;&#xA;            return this;&#xD;&#xA;        }&#xD;&#xA;        else return ToCartesian().ScaleBy(scaleX, scaleY, scaleZ);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override CartesianCoord ToCartesian()&#xD;&#xA;    {&#xD;&#xA;        double x = R * Sin(θ);&#xD;&#xA;        double y = R * Cos(θ);&#xD;&#xA;        return new CartesianCoord(x, y, Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override PolarCoord ToPolar() =&gt; new PolarCoord(R, θ, Z);&#xD;&#xA;&#xD;&#xA;    public override double Length =&gt; Sqrt(R * R + Z * Z);&#xD;&#xA;&#xD;&#xA;    public override string ToString() =&gt; $&quot;(R={R}, θ={θ}, Z={Z})&quot;;&#xD;&#xA;&#xD;&#xA;    public override string Jsonify() =&gt; ToCartesian().Jsonify();&#xD;&#xA;&#xD;&#xA;    public static PolarCoord Parse(params string[] coords)&#xD;&#xA;    {&#xD;&#xA;        switch (coords.Length)&#xD;&#xA;        {&#xD;&#xA;            case 2:&#xD;&#xA;                return ParsePolarCoordsString(coords[0], coords[1]);&#xD;&#xA;            case 3:&#xD;&#xA;                return ParsePolarCoordsString(coords[0], coords[1], coords[2]);&#xD;&#xA;            default:&#xD;&#xA;                throw Context.ArgCountError(&quot;AdvWm: 极坐标构造函数&quot;, &quot;2-3&quot;, coords.Length, &quot;[&quot; + string.Join(&quot;], [&quot;, coords) + &quot;]&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static PolarCoord ParsePolarCoordsString(string rawR, string rawθ, string rawZ = null)&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            return new PolarCoord(&#xD;&#xA;                MathParser.Parse(rawR),&#xD;&#xA;                MathParser.Parse(rawθ),&#xD;&#xA;                rawZ == null ? 0 : MathParser.Parse(rawZ));&#xD;&#xA;        }&#xD;&#xA;        catch (Exception ex)&#xD;&#xA;        {&#xD;&#xA;            throw new ArgumentException($&quot;AdvWm: 极坐标解析错误：{ex.Message}\n\n&quot; +&#xD;&#xA;                $&quot;原始数据：\nr = ({rawR}), \nθ = ({rawθ}), \nz = ({rawZ})&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#endregion XIVCoord&#xD;&#xA;&#xD;&#xA;#region Waymark(s)&#xD;&#xA;&#xD;&#xA;public enum WaymarkType { A, B, C, D, One, Two, Three, Four }&#xD;&#xA;public class Waymark&#xD;&#xA;{&#xD;&#xA;    public WaymarkType Type { get; set; }&#xD;&#xA;    public XIVCoord Coord { get; set; }&#xD;&#xA;    public bool Ignore { get; set; }&#xD;&#xA;    public bool Active { get; set; }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 用于遍历时保证输出顺序&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    public static readonly string[] WaymarkNames = new string[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; };&#xD;&#xA;    public static readonly WaymarkType[] WaymarkTypes = new WaymarkType[]&#xD;&#xA;    {&#xD;&#xA;        WaymarkType.A, WaymarkType.B, WaymarkType.C, WaymarkType.D,&#xD;&#xA;        WaymarkType.One, WaymarkType.Two, WaymarkType.Three, WaymarkType.Four&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 从用户输入的标点类型转化为实际 Type&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    public static readonly Dictionary&lt;string, WaymarkType&gt; TypeMap = Enumerable.Range(0, 8)&#xD;&#xA;        .ToDictionary(i =&gt; WaymarkNames[i], i =&gt; WaymarkTypes[i]);&#xD;&#xA;&#xD;&#xA;    public Waymark(WaymarkType type, XIVCoord coord = null, bool ignore = false)&#xD;&#xA;    {&#xD;&#xA;        Type = type;&#xD;&#xA;        Coord = coord ?? new CartesianCoord(0, 0, 0);&#xD;&#xA;        Active = coord != null;&#xD;&#xA;        Ignore = ignore;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public Waymark(string rawType, XIVCoord coord = null, bool ignore = false)&#xD;&#xA;    {&#xD;&#xA;        if (TypeMap.TryGetValue(rawType, out var mappedType))&#xD;&#xA;        {&#xD;&#xA;            Type = mappedType;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            throw new Exception($&quot;AdvWm: {rawType} 不是合法的标点名之一（A B C D 1 2 3 4）。&quot;);&#xD;&#xA;        }&#xD;&#xA;        Coord = coord ?? new CartesianCoord(0, 0, 0);&#xD;&#xA;        Active = coord != null;&#xD;&#xA;        Ignore = ignore;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static Waymark Parse(string rawType, string rawCoord, bool ignore = false)&#xD;&#xA;    {&#xD;&#xA;        Waymark wm = new Waymark(rawType, null, ignore);&#xD;&#xA;&#xD;&#xA;        switch (rawCoord.Trim().ToLower())&#xD;&#xA;        {&#xD;&#xA;            // 清除标点&#xD;&#xA;            case &quot;clear&quot;:&#xD;&#xA;                wm.Active = false;&#xD;&#xA;                wm.Coord = new CartesianCoord(0, 0, 0);&#xD;&#xA;                break;&#xD;&#xA;            // 变相地“清除”标点  不会有淡入淡出动画&#xD;&#xA;            case &quot;fakeclear&quot;:&#xD;&#xA;                wm.Active = true;&#xD;&#xA;                wm.Coord = new CartesianCoord(0, 0, 1000);&#xD;&#xA;                break;&#xD;&#xA;            default:&#xD;&#xA;                wm.Active = true;&#xD;&#xA;                wm.Coord = XIVCoord.ParseRawData(rawCoord);&#xD;&#xA;                break;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        return wm;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public string Jsonify() // 脚本调用不了 Json 的方法。。？&#xD;&#xA;    {&#xD;&#xA;        if (Ignore)&#xD;&#xA;            return &quot;&quot;;&#xD;&#xA;        if (Active)&#xD;&#xA;            return $&quot;\&quot;{Type}\&quot;: {{ {Coord.Jsonify()}, \&quot;Active\&quot;: true }}&quot;;&#xD;&#xA;        else&#xD;&#xA;            return $&quot;\&quot;{Type}\&quot;: {{}}&quot;;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override string ToString() =&gt; Jsonify();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public sealed class Waymarks : IEnumerable&lt;Waymark&gt;&#xD;&#xA;{&#xD;&#xA;    private readonly Dictionary&lt;WaymarkType, Waymark&gt; _waymarks;&#xD;&#xA;    public bool Log = true;&#xD;&#xA;    public bool LocalOnly = true;&#xD;&#xA;&#xD;&#xA;    public Waymarks()&#xD;&#xA;    {&#xD;&#xA;        _waymarks = new Dictionary&lt;WaymarkType, Waymark&gt;();&#xD;&#xA;        foreach (var type in Waymark.WaymarkTypes)&#xD;&#xA;        {&#xD;&#xA;            _waymarks[type] = new Waymark(type, ignore: true);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public Waymark this[WaymarkType type]&#xD;&#xA;    {&#xD;&#xA;        get =&gt; _waymarks[type];&#xD;&#xA;        set =&gt; _waymarks[type] = value;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();&#xD;&#xA;    public IEnumerator&lt;Waymark&gt; GetEnumerator()&#xD;&#xA;    {&#xD;&#xA;        foreach (var type in Waymark.WaymarkTypes)&#xD;&#xA;        {&#xD;&#xA;            if (_waymarks.TryGetValue(type, out Waymark waymark))&#xD;&#xA;            {&#xD;&#xA;                yield return waymark;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Add(Waymark wm)&#xD;&#xA;    {&#xD;&#xA;        if (wm == null || wm.Ignore) return;&#xD;&#xA;        else _waymarks[wm.Type] = wm;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public string Jsonify()&#xD;&#xA;    {&#xD;&#xA;        var jsonList = _waymarks.Values.Where(wm =&gt; wm?.Ignore == false)&#xD;&#xA;            .Select(wm =&gt; &quot;    &quot; + wm.Jsonify()).ToList();&#xD;&#xA;        if (!Log)&#xD;&#xA;            jsonList.Add($&quot;    \&quot;Log\&quot;: false&quot;);&#xD;&#xA;        if (!LocalOnly)&#xD;&#xA;            jsonList.Add($&quot;    \&quot;LocalOnly\&quot;: false&quot;);&#xD;&#xA;        string data = string.Join(&quot;,\n&quot;, jsonList);&#xD;&#xA;        return $&quot;{{\n{string.Join(&quot;,\n&quot;, jsonList)}\n}}&quot;;&#xD;&#xA;    }&#xD;&#xA;    public override string ToString() =&gt; Jsonify();&#xD;&#xA;&#xD;&#xA;    public void Mark()&#xD;&#xA;    {&#xD;&#xA;        RealPlugin.plug.InvokeNamedCallback(&quot;place&quot;, this.Jsonify());&#xD;&#xA;        //RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e {this}&quot;);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#endregion Waymark(s)&#xD;&#xA;&#xD;&#xA;public static class WaymarksEncoder&#xD;&#xA;{&#xD;&#xA;    static bool IsSelfAnonymous =&gt; Interpreter.StaticHelpers.GetScalarVariable(true, &quot;AdvWm_Anonymous&quot;) != null;&#xD;&#xA;&#xD;&#xA;    private static int CoordToInt(float coord)&#xD;&#xA;    {&#xD;&#xA;        // 标点数据只有三位精度。&#xD;&#xA;        // float 在 ±16384 内时可保证第三位小数准确，小于这个阈值的最大 2^n / 1000 为 ±8388.608，恰好 24 bit&#xD;&#xA;        int encodedInt = (int)Round((double)coord * 1000);&#xD;&#xA;        if (encodedInt &lt; 0)            // -8388608 ~ -1&#xD;&#xA;            encodedInt += 0xFFFFFF;    // 转换为 8388608 (0x800000) ~ 16777215 (0xFFFFFF)&#xD;&#xA;        return encodedInt;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static float IntToCoord(int encodedInt) =&gt; (encodedInt &gt; 0x7FFFFF ? encodedInt - 0xFFFFFF : encodedInt) / 1000f;&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 通过 6 字节 int 解码 10XXXXXX ID &lt;/summary&gt;&#xD;&#xA;    static uint? CoordToId(float coord) =&gt; coord == 0 ? null : (uint?)(CoordToInt(coord) + 0x10000000);&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 将 id 编码为两个 3 字节精度的坐标：80.00 - 120.95 &lt;/summary&gt;&#xD;&#xA;    static (float, float) IdToCoords(uint id)&#xD;&#xA;    {&#xD;&#xA;        id -= 0x10000000;&#xD;&#xA;        return (80 + ((id &gt;&gt; 12) &amp; 0xFFF) / 100f, 80 + (id &amp; 0xFFF) / 100f);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 解码当前标点为文本，并检测发送者 &lt;/summary&gt;&#xD;&#xA;    public static void DecodeFromWaymarksAndShow()&#xD;&#xA;    {&#xD;&#xA;        List&lt;byte&gt; byteList = new List&lt;byte&gt;();&#xD;&#xA;        var waymarks = Triggernometry.Utilities.Memory.Waymarks.Read();&#xD;&#xA;        uint? senderId = CoordToId(waymarks.A.Z);&#xD;&#xA;        string senderDesc = &quot;Someone&quot;;&#xD;&#xA;        if (senderId != null)&#xD;&#xA;        {&#xD;&#xA;            var sender = BridgeFFXIV.GetIdEntity(senderId.Value.ToString(&quot;X&quot;));&#xD;&#xA;            senderDesc = $&quot;{sender.GetValue(&quot;name&quot;)} ({sender.GetValue(&quot;jobEN3&quot;)})&quot;;&#xD;&#xA;        }&#xD;&#xA;        foreach (var waymark in waymarks.Skip(1)) // 跳过用于表明密语消息的 A 点&#xD;&#xA;        {&#xD;&#xA;            if (!waymark.Active) break;&#xD;&#xA;            foreach (var coord in new[] { waymark.X, waymark.Y, waymark.Z })&#xD;&#xA;            {&#xD;&#xA;                int encodedInt = CoordToInt(coord);&#xD;&#xA;                // 从而将 ±8388.608 以内的 float 转换为 24 bit 数据，再分解为 3 字节&#xD;&#xA;                byteList.Add((byte)((encodedInt &gt;&gt; 16) &amp; 0xFF));   // 高8位&#xD;&#xA;                byteList.Add((byte)((encodedInt &gt;&gt; 8) &amp; 0xFF));    // 中8位&#xD;&#xA;                byteList.Add((byte)(encodedInt &amp; 0xFF));           // 低8位&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        string msg = Encoding.UTF8.GetString(byteList.ToArray());&#xD;&#xA;        AdvWm.Log($&quot;[AdvWm] Secret Message:\n{senderDesc} says:\n{msg}&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 编码一串文本，以标点形式发送 &lt;/summary&gt;&#xD;&#xA;    public static void EncodeAndSendWaymarks(string msg, bool anonymous)&#xD;&#xA;    {&#xD;&#xA;        bool waymarkChkEnabled = true;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            waymarkChkEnabled = PostNamazuController.DetectAndEnableWaymarkChk();&#xD;&#xA;            byte[] byteArray = Encoding.UTF8.GetBytes(msg);&#xD;&#xA;            if (byteArray.Length &gt; 63)&#xD;&#xA;                throw new Exception(&quot;输入字符串过长，不能超过 63 字节。&quot;);&#xD;&#xA;&#xD;&#xA;            Array.Resize(ref byteArray, 63);&#xD;&#xA;&#xD;&#xA;            List&lt;int&gt; integers = new List&lt;int&gt;();&#xD;&#xA;            for (int i = 0; i &lt; 21; i++)&#xD;&#xA;            {&#xD;&#xA;                integers.Add((byteArray[i * 3] &lt;&lt; 16) | (byteArray[i * 3 + 1] &lt;&lt; 8) | (byteArray[i * 3 + 2]));&#xD;&#xA;            }&#xD;&#xA;            string advWm = $&quot;Local: false&quot;;&#xD;&#xA;            float az = anonymous ? 0 : IntToCoord((int)(BridgeFFXIV.PlayerId - 0x10000000));&#xD;&#xA;            advWm += $&quot;\nA: {0xFF14 / 1000f}, {0xFF14 / 1000f}, {az}&quot;;&#xD;&#xA;            string[] names = new string[] { &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; };&#xD;&#xA;            for (int i = 0; i &lt; 7; i++)&#xD;&#xA;            {&#xD;&#xA;                if (integers[i * 3] == 0 &amp;&amp; integers[i * 3 + 1] == 0 &amp;&amp; integers[i * 3 + 2] == 0)&#xD;&#xA;                    advWm += $&quot;\n{names[i]}: clear&quot;;&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    float x = IntToCoord(integers[i * 3]);&#xD;&#xA;                    float y = IntToCoord(integers[i * 3 + 1]);&#xD;&#xA;                    float z = IntToCoord(integers[i * 3 + 2]);&#xD;&#xA;                    advWm += $&quot;\n{names[i]}: {x}, {y}, {z}&quot;;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            RealPlugin.plug.InvokeNamedCallback(&quot;AdvWm&quot;, advWm);&#xD;&#xA;        }&#xD;&#xA;        catch (Exception e) { AdvWm.Log($&quot;发送失败：{e.Message}&quot;); }&#xD;&#xA;        finally { PostNamazuController.ResetWaymarkChk(waymarkChkEnabled); }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Ask(bool wantAnonymous)&#xD;&#xA;        =&gt; AskOrAnswerByWaymarkA(0xFF14 / 1000f * (wantAnonymous ? -1 : 1), true);&#xD;&#xA;&#xD;&#xA;    public static void Answer()&#xD;&#xA;        =&gt; AskOrAnswerByWaymarkA(0.14f, false);&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; &#xD;&#xA;    /// 通过改变标点 A，发起关于谁在使用此工具箱的询问或应答。&#xD;&#xA;    /// x, y 各三字节精度，用于存储 ID；&#xD;&#xA;    /// z = ±0xff14 / 1000 代表发起询问（负值代表希望匿名）；±0.14 代表应答（负值代表没开启标点）。&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    private static void AskOrAnswerByWaymarkA(float z, bool isAsk)&#xD;&#xA;    {&#xD;&#xA;        bool waymarkChkEnabled = true;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            waymarkChkEnabled = PostNamazuController.DetectAndEnableWaymarkChk();&#xD;&#xA;            string advWm = $&quot;Local: false&quot;;&#xD;&#xA;            (float ax, float ay) = IdToCoords(BridgeFFXIV.PlayerId);&#xD;&#xA;            if (IsSelfAnonymous) // real anonymous&#xD;&#xA;                (ax, ay) = (80, 80);&#xD;&#xA;            if (!isAsk &amp;&amp; !waymarkChkEnabled)&#xD;&#xA;                z *= -1;&#xD;&#xA;            advWm += $&quot;\nA: {ax}, {ay}, {z}&quot;;&#xD;&#xA;            RealPlugin.plug.InvokeNamedCallback(&quot;AdvWm&quot;, advWm);&#xD;&#xA;        }&#xD;&#xA;        catch (Exception e) { AdvWm.Log($&quot;发送失败：{e.Message}&quot;); }&#xD;&#xA;        finally { PostNamazuController.ResetWaymarkChk(waymarkChkEnabled); }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void GetUsersResult()&#xD;&#xA;    {&#xD;&#xA;        var users = Interpreter.StaticHelpers.GetListVariable(false, &quot;AdvWm_users&quot;)?.Values?.Select(v =&gt; new UserEntry(v.ToString())).ToList();&#xD;&#xA;        if (users == null) return;&#xD;&#xA;        var ask = users?.FirstOrDefault(u =&gt; u.Asked);&#xD;&#xA;        // 查询者非自己且要求匿名时，不显示结果&#xD;&#xA;        if (ask?.Id != BridgeFFXIV.PlayerId &amp;&amp; (ask?.WantAnonymous ?? true) &amp;&amp; !IsSelfAnonymous) return;&#xD;&#xA;        var answers = users?.Where(u =&gt; !u.Asked).ToList();&#xD;&#xA;        string msg = $&quot;[AdvWm] 看看誰是挂友！&lt;se.10&gt;\nAsked by: \n  · {ask}\nUsers:\n  · {string.Join(&quot;\n  · &quot;, answers)}&quot;;&#xD;&#xA;        AdvWm.Log(msg);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public class UserEntry&#xD;&#xA;    {&#xD;&#xA;        public uint Id;&#xD;&#xA;        public float Z;&#xD;&#xA;        public bool Asked =&gt; Abs(Abs(Z) - 0xFF14 / 1000f) &lt; 0.001;&#xD;&#xA;        public bool EnabledWaymark =&gt; Asked || Z &gt; 0;&#xD;&#xA;        public bool WantAnonymous =&gt; Asked &amp;&amp; Z &lt; 0;&#xD;&#xA;        /// &lt;summary&gt; 接收如 10ABCDEF, -0.14 的输入，前面是 id，后面是标点的 z 坐标&lt;/summary&gt;&#xD;&#xA;        public UserEntry(string data)&#xD;&#xA;        {&#xD;&#xA;            var d = data.Split(',');&#xD;&#xA;            Id = uint.Parse(d[0], System.Globalization.NumberStyles.HexNumber);&#xD;&#xA;            Z = float.Parse(d[1], System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;        }&#xD;&#xA;        public override string ToString()&#xD;&#xA;        {&#xD;&#xA;            bool anonymous = IsSelfAnonymous ? false : WantAnonymous;&#xD;&#xA;            var entity = BridgeFFXIV.GetIdEntity(Id.ToString(&quot;X&quot;));&#xD;&#xA;            string str = anonymous ? &quot;&quot; : entity.GetValue(&quot;name&quot;).ToString();&#xD;&#xA;            if (str == &quot;&quot;)&#xD;&#xA;                str = &quot;匿名&quot;;&#xD;&#xA;            else&#xD;&#xA;                str += $&quot; ({entity.GetValue(&quot;jobEN3&quot;)})&quot;;&#xD;&#xA;            if (!EnabledWaymark)&#xD;&#xA;                str += &quot; [未使用標点]&quot;;&#xD;&#xA;            return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public static class PostNamazuController&#xD;&#xA;{&#xD;&#xA;    private static CheckBox _waymarkCbx;&#xD;&#xA;    private static CheckBox WaymarkCbx =&gt; _waymarkCbx ?? GetWayMarkCbx();&#xD;&#xA;    private static TabPage TabPage =&gt; RealPlugin.InstanceHook(null, &quot;PostNamazu.PostNamazu&quot;).TabPage;&#xD;&#xA;    private static CheckBox GetWayMarkCbx() =&gt; SearchWayMarkCbxIn(TabPage);&#xD;&#xA;    private static CheckBox SearchWayMarkCbxIn(Control parent)&#xD;&#xA;    {&#xD;&#xA;        foreach (Control ctrl in parent.Controls)&#xD;&#xA;        {&#xD;&#xA;            if (ctrl is CheckBox checkBox &amp;&amp; checkBox.Text.ToLower() == &quot;waymark&quot;)&#xD;&#xA;            {&#xD;&#xA;                return checkBox;&#xD;&#xA;            }&#xD;&#xA;            else if (ctrl?.HasChildren == true)&#xD;&#xA;            {&#xD;&#xA;                CheckBox foundCbx = SearchWayMarkCbxIn(ctrl);&#xD;&#xA;                if (foundCbx != null) return foundCbx;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static bool DetectAndEnableWaymarkChk()&#xD;&#xA;    {&#xD;&#xA;        if (WaymarkCbx.InvokeRequired)&#xD;&#xA;        {&#xD;&#xA;            return (bool)WaymarkCbx.Invoke(new Func&lt;bool&gt;(DetectAndEnableWaymarkChk));&#xD;&#xA;        }&#xD;&#xA;        bool current = WaymarkCbx.Checked;&#xD;&#xA;        if (WaymarkCbx.Checked == false)&#xD;&#xA;            WaymarkCbx.Checked = true;&#xD;&#xA;        return current;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void ResetWaymarkChk(bool previousChecked)&#xD;&#xA;    {&#xD;&#xA;        if (WaymarkCbx.InvokeRequired)&#xD;&#xA;        {&#xD;&#xA;            WaymarkCbx.Invoke(new Action&lt;bool&gt;(ResetWaymarkChk), previousChecked);&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        if (!previousChecked) WaymarkCbx.Checked = false;&#xD;&#xA;    }&#xD;&#xA;}" ActionType="ExecuteScript" Description="【代码】" DescBgColor="acf" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="AdvWm_Init" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:AdvWm}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" FolderId="fc38c328-5121-45af-80c4-b2414dca87b2" TriggerOp="EnableTrigger" TriggerId="4e73bc73-6034-45b1-9030-2c01d7458c6f" ActionType="Folder" />
<Action OrderNumber="4" FolderId="4cc7f4b0-79a5-4f91-b2f2-714b4bffbb5c" TriggerOp="EnableTrigger" TriggerId="4e73bc73-6034-45b1-9030-2c01d7458c6f" ActionType="Folder" />
<Action OrderNumber="5" FolderId="18f9df43-177e-4ae8-9f3e-a574639433d7" TriggerOp="EnableTrigger" TriggerId="4e73bc73-6034-45b1-9030-2c01d7458c6f" ActionType="Folder" />
<Action OrderNumber="6" TriggerOp="EnableTrigger" TriggerId="4e73bc73-6034-45b1-9030-2c01d7458c6f" ActionType="Trigger" />
<Action OrderNumber="7" TriggerOp="EnableTrigger" TriggerId="6b34bf54-57ba-427d-add9-0dd61d500486" ActionType="Trigger" />
<Action OrderNumber="8" TriggerOp="EnableTrigger" TriggerId="814e7f84-6f65-4b31-9201-d14d2d65b13a" ActionType="Trigger" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:AdvWm}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="版本" Id="e3c51aac-0cf2-48bd-9774-eb43e84b66ea" RegularExpression="^AdvWm_getVersion">
<Actions>
<Action OrderNumber="1" ListVariableOp="Push" ListVariableName="AdvWm_version" ListVariableExpression="${env:version}" ActionType="ListVariable" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="场地标点：/e mk [正点半径] [斜点半径]?    如 &quot;/e mk 15&quot;  &quot;/e mk 18 10&quot;" Id="33d2edb1-e0bc-4164-ac26-0d3c9c313fd5" RegularExpression="^.{15}\S+ 00:0038:: *mk +(?&lt;card&gt;[^ ]+)(?: +(?&lt;intercard&gt;[^ ]+))? *(?&lt;center&gt;@ *(?&lt;x0&gt;[^ ]+) +(?&lt;y0&gt;[^ ]+)(?: +(?&lt;z0&gt;[^ ]+))? *)?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="需求：高级标点工具箱，没有的在远程触发器 - 自检 里找" DescriptionOverride="True" />
<Action OrderNumber="2" NamedCallbackName="AdvWm" NamedCallbackParam="action: circle&#xD;&#xA;waymarks: ADCB&#xD;&#xA;r: ${card}&#xD;&#xA;center: ${n: ${x0} ?? 100}, ${n: ${y0} ?? 100}, ${n: ${z0} ?? ${_me.z}}" ActionType="NamedCallback" Asynchronous="False" Description="ABCD" DescriptionOverride="True" />
<Action OrderNumber="3" NamedCallbackName="AdvWm" NamedCallbackParam="action: circle&#xD;&#xA;waymarks: 4321&#xD;&#xA;θ: -3/4 * π&#xD;&#xA;r: (${intercard} ?? ${card})&#xD;&#xA;center: ${n: ${x0} ?? 100}, ${n: ${y0} ?? 100}, ${n: ${z0} ?? ${_me.z}}" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="1234（北侧从左到右 4A1）" DescriptionOverride="True" />
<Action OrderNumber="4" NamedCallbackName="AdvWm" NamedCallbackParam="action: circle&#xD;&#xA;waymarks: 4321&#xD;&#xA;θ: -1/4 * π&#xD;&#xA;r: (${intercard} ?? ${card})&#xD;&#xA;center: ${n: ${x0} ?? 100}, ${n: ${y0} ?? 100}, ${n: ${z0} ?? ${_me.z}}" ActionType="NamedCallback" Asynchronous="False" Description="1234（北侧从左到右 1A2）" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Asynchronous="False" Description="应用本地标点（使全队可见）： " DescriptionOverride="True" />
<Action OrderNumber="6" NamedCallbackName="command" NamedCallbackParam="/waymark save 30" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="7" NamedCallbackName="command" NamedCallbackParam="/waymark preset 30" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="8" LogMessageText="[00:00:00.000] 0 00:0038::mk 15 10" LogProcess="True" Enabled="False" ActionType="LogMessage" Description="如果解析插件真的完全不工作，双击这行在 mk 之后输入标点参数，右键测试这行（左面的对号不要点）" DescBgColor="fdd" DescTextColor="000" DescriptionOverride="True" />
</Actions>
</Trigger>
<Trigger Enabled="false" Name="导入提示" Id="6bfe9cc5-3421-4032-82f6-09e2291bed68" RegularExpression="^." PrevActionsRefire="Deny" PeriodRefire="Deny" RefirePeriodExpression="30000">
<Actions>
<Action OrderNumber="1" MessageBoxIconType="Information" MessageBoxText="高级标点工具箱已更新 v${env:version}。&#xD;&#xA;如果你有本地版本，请删除本地版本，以免冲突。&#xD;&#xA;如果你是开发者，可以查看使用说明中的新功能介绍。&#xD;&#xA;&#xD;&#xA;本条消息只会提示一次。" ActionType="MessageBox" />
<Action OrderNumber="2" TriggerOp="DisableTrigger" TriggerId="6bfe9cc5-3421-4032-82f6-09e2291bed68" ActionType="Trigger" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="手动标点： /e pl/place A/B/C/D/1/2/3/4 (x) (y) (z)" Id="aa1ccb66-3c1e-49bb-a588-df251e123f2d" RegularExpression="^.{15}\S+ 00:0038:: *[Pp][Ll]([Aa][Cc][Ee])? +(?&lt;wm&gt;[A-Da-d1-4])(?&lt;x&gt; +[^ ]+)?(?&lt;y&gt; +[^ ]+)?(?&lt;z&gt; +[^ ]+)? *$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="action: place&#xD;&#xA;${wm}: (${x} ?? ${_me.x}), (${y} ?? ${_me.y}), (${z} ?? ${_me.z})" ActionType="NamedCallback" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="false" Sequential="True" Name="启动时文本提示" Id="d7c8998b-47b3-4ae1-a66b-5bc0f22c8d1b" RegularExpression="^AdvWm_Init">
<Actions>
<Action OrderNumber="1" NamedCallbackName="command" NamedCallbackParam="/e ${if: ${f:contain(&quot; &quot;):${_me.name}} ? &quot;已激活：高級標点工具箱&quot; : &quot;已激活：高级标点工具箱&quot; } AdvWm v${env:version}" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="false" Name="本分组不可关闭，否则影响基础功能。如需关闭本地标点，在鲶鱼精邮差插件页面关闭 Waymark。" Id="038b655f-9b22-4717-935f-2cba6df5ab40" RegularExpression="">
<Actions />
</Trigger>
</Triggers>
</Folder>
<Folder Id="f1cb57f3-1d3a-4039-86c6-28853397c9fe" DisableRemoteExpand="True" DisableRemoteToggle="True" Name="日志转录" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="1B Tether" Id="b76001fa-c4e6-46fc-9c6f-95c2a56f42d6" RegularExpression="^(?&lt;time&gt;.{14}) \S+ 23:(?&lt;sid&gt;.{8}):(?&lt;sn&gt;[^:]*):(?&lt;tid&gt;.{8}):(?&lt;tn&gt;[^:]*):[^:]*:[^:]*:(?&lt;type&gt;[^:]*)">
<Actions>
<Action OrderNumber="1" DictVariableOp="GetEntity" DictVariableName="tmp_src" DictVariableValue="${sid}" ActionType="DictVariable" Asynchronous="False" />
<Action OrderNumber="2" DictVariableOp="GetEntity" DictVariableName="tmp_tgt" DictVariableValue="${tid}" ActionType="DictVariable" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="如果是 10xxxxxx =&gt; 40xxxxxx 则交换两者" DescriptionOverride="True" />
<Action OrderNumber="4" LogMessageText="${time} _Tether AAA:23:${type}:${sid}:${sn}:${d:tmp_src[bnpcnameid]}:${d:tmp_src[bnpcid]}:${d:tmp_src[x]}:${d:tmp_src[y]}:${d:tmp_src[z]}:${d:tmp_src[h]}:${tid}:${tn}:${d:tmp_tgt[bnpcnameid]}:${d:tmp_tgt[bnpcid]}:${d:tmp_tgt[x]}:${d:tmp_tgt[y]}:${d:tmp_tgt[z]}:${d:tmp_tgt[h]}:0" LogProcess="True" LogProcessACT="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${f:startwith(40):${sid}}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="5" LogMessageText="${time} _Tether AAA:23:${type}:${tid}:${tn}:${d:tmp_tgt[bnpcnameid]}:${d:tmp_tgt[bnpcid]}:${d:tmp_tgt[x]}:${d:tmp_tgt[y]}:${d:tmp_tgt[z]}:${d:tmp_tgt[h]}:${sid}:${sn}:${d:tmp_src[bnpcnameid]}:${d:tmp_src[bnpcid]}:${d:tmp_src[x]}:${d:tmp_src[y]}:${d:tmp_src[z]}:${d:tmp_src[h]}:1" LogProcess="True" LogProcessACT="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${f:startwith(40):${sid}}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="6" DictVariableValueType="Numeric" DictVariableName="tmp_src" ActionType="DictVariable" Asynchronous="False" />
<Action OrderNumber="7" DictVariableName="tmp_tgt" ActionType="DictVariable" Asynchronous="False" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${f:startwith(40):${sid}} || ${f:startwith(40):${tid}}" ExpressionTypeL="Numeric" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="10F ActorSetPos" Id="afea2cfe-0e85-4bc6-8424-cc23c26b3350" RegularExpression="^(?&lt;time&gt;.{14}) \S+ 10F:(?&lt;id&gt;4.{7}):(?&lt;h&gt;[^:]+):[^:]+:[^:]+:(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)$">
<Actions>
<Action OrderNumber="1" DictVariableOp="GetEntity" DictVariableName="tmp_entity" DictVariableValue="${id}" ActionType="DictVariable" Asynchronous="False" />
<Action OrderNumber="2" LogMessageText="${time} _ActorSetPos AAA:10F:${id}:${d:tmp_entity[name]}:${d:tmp_entity[bnpcnameid]}:${d:tmp_entity[bnpcid]}:${x}:${y}:${z}:${h}" LogProcess="True" LogProcessACT="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="false" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:tmp_entity[bnpcid]}" ExpressionTypeL="String" ExpressionR="9020" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" DictVariableName="tmp_entity" ActionType="DictVariable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="111 ActorControl" Id="09154dac-37c2-49e0-a42f-a5e10a4eae82" RegularExpression="^(?&lt;time&gt;.{14}) \S+ 111:(?&lt;id&gt;4.{7}):(?&lt;type&gt;[^:]*):(?&lt;param1&gt;[^:]*):(?&lt;param2&gt;[^:]*)">
<Actions>
<Action OrderNumber="1" DictVariableOp="Build" DictVariableTarget="ProcessedLog_ActorControl" DictVariableValue="=&#xD;&#xA;0031=Unknown49 AAA:200:¤{param1}&#xD;&#xA;003E=AnimationState AAA:201:¤{param1}:¤{param2}&#xD;&#xA;003F=WeaponId AAA:202:¤{param1}&#xD;&#xA;0197=PlayActionTimeline AAA:203:¤{param1}&#xD;&#xA;019D=EObjAnimation AAA:204:¤{param1}:¤{param2}&#xD;&#xA;01F8=StatusUpdate AAA:205:¤{param1}" ActionType="DictVariable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ed:ProcessedLog_ActorControl}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="2" DictVariableOp="GetEntity" DictVariableName="tmp_entity" DictVariableValue="${id}" ActionType="DictVariable" Asynchronous="False" />
<Action OrderNumber="3" LogMessageText="${time} _${d:ProcessedLog_ActorControl[${type}]}:${id}:${d:tmp_entity[name]}:${d:tmp_entity[bnpcnameid]}:${d:tmp_entity[bnpcid]}:${d:tmp_entity[x]}:${d:tmp_entity[y]}:${d:tmp_entity[z]}:${d:tmp_entity[h]}" LogProcess="True" LogProcessACT="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="false" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:tmp_entity[bnpcid]}" ExpressionTypeL="String" ExpressionR="9020" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
</Condition>
</Action>
<Action OrderNumber="4" DictVariableName="tmp_entity" ActionType="DictVariable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="110 ActorSpawnExtra" Id="44640587-e1d3-44a0-aa19-b4449cfb65f5" RegularExpression="^(?&lt;time&gt;.{14}) \S+ 110:(?&lt;id&gt;4.{7}):(?!E0000000:0000:00)(?&lt;params&gt;.+)">
<Actions>
<Action OrderNumber="1" DictVariableOp="GetEntity" DictVariableName="tmp_entity" DictVariableValue="${id}" ActionType="DictVariable" Asynchronous="False" />
<Action OrderNumber="2" LogMessageText="${time} _ActorSpawnExtra AAA:110:${id}:${d:tmp_entity[name]}:${d:tmp_entity[bnpcnameid]}:${d:tmp_entity[bnpcid]}:${d:tmp_entity[x]}:${d:tmp_entity[y]}:${d:tmp_entity[z]}:${d:tmp_entity[h]}:${params}" LogProcess="True" LogProcessACT="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="false" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:tmp_entity[bnpcid]}" ExpressionTypeL="String" ExpressionR="9020" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" DictVariableName="tmp_entity" ActionType="DictVariable" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="a529e01d-a121-4391-bfef-0b52951eb3b8" Name="小队框架 PartyList v2.1" Enabled="true">
<Folders>
<Folder Id="0184b79d-f3d6-490f-adaa-b0cf486ab458" DisableRemoteToggle="True" Name="记录完整小队" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="[F] 注册区域      PartyList:Register:[zoneid]:[playerDescs]" Id="804216a2-d4ab-417e-b58b-591f3f5836bf" RegularExpression="^PartyList:Register:(?&lt;zoneid&gt;\d+):(?&lt;playerDescs&gt;.+)">
<Actions>
<Action OrderNumber="1" DictVariableOp="Set" DictVariableName="PartyListPlayerDescs" DictVariableKey="${zoneid}" DictVariableValue="${playerDescs}" ActionType="DictVariable" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="如果当前处于要注册的地图：触发检查" DescriptionOverride="True" />
<Action OrderNumber="3" LogMessageText="PartyList:Show:1:1:0:${zoneid}" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${zoneid}" ExpressionTypeL="String" ExpressionR="${_ffxivzoneid}" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${playerDescs}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringNotEqualNocase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="接收：倒计时" Id="755696a8-6cb0-4dc0-b362-783adf5c145d" RegularExpression="^.{15}\S+ 10C:">
<Actions>
<Action OrderNumber="1" LogMessageText="PartyList:Show:0:1:0" LogProcess="True" ActionType="LogMessage" />
</Actions>
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${el:party}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="接收：文本指令　　/e party　（非全队模式下提示错误）" Id="ad7c7abc-f5b0-48f9-b3f7-80940bf71bf2" RegularExpression="^.{15}\S+ 00:0038:: *[Pp][Aa][Rr][Tt][Yy] *$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="条件：当前地图未注册为全队模式" DescriptionOverride="True" />
<Action OrderNumber="2" UseTTSTextExpression="当前地图区域未注册小队类型。" ActionType="UseTTS" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="[F][C] 开启窗口   PartyList:Show:..." Id="48f1e88c-2ae6-4d9e-9123-02e5695db901" RegularExpression="^PartyList:Show:(?&lt;successTTS&gt;[01]):(?&lt;failTTS&gt;[01]):(?&lt;forceOpen&gt;[01])(?::(?&lt;zoneid&gt;[^:]*))?">
<Actions>
<Action OrderNumber="1" UseTTSTextExpression="正在开启小队配置" ActionType="UseTTS">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${successTTS}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionGroup Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ev:PartyListForm_isRunning}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${forceOpen}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</ConditionGroup>
</Condition>
</Action>
<Action OrderNumber="2" UseTTSTextExpression="请检查后台窗口" ActionType="UseTTS">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${ev:PartyListForm_isRunning}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${successTTS}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${forceOpen}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" ExecScriptExpression="using System;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Drawing;&#xD;&#xA;using System.Globalization;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Threading;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using Triggernometry.CustomControls;&#xD;&#xA;using static Triggernometry.Interpreter;&#xD;&#xA;&#xD;&#xA;public struct Info&#xD;&#xA;{&#xD;&#xA;    public const string Name = &quot;小队列表&quot;;&#xD;&#xA;    public const string Version = &quot;0.3&quot;; // 2024.11.25&#xD;&#xA;    public const string Author = &quot;阿洛 MnFeN&quot;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;RealPlugin.plug.RegisterNamedCallback(&quot;PartyList&quot;, new Action&lt;object, string&gt;(PartyListHelper.Start), null);&#xD;&#xA;&#xD;&#xA;public static class PartyListHelper&#xD;&#xA;{&#xD;&#xA;    public static void Start(object _, string rawPlayerDescriptions)&#xD;&#xA;    {&#xD;&#xA;        StaticHelpers.SetScalarVariable(false, &quot;PartyListForm_isRunning&quot;, &quot;1&quot;);&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            string[] playerDescriptions = Context.SplitArguments(rawPlayerDescriptions);&#xD;&#xA;            if (playerDescriptions.Length &lt; 1) throw new ArgumentException(&quot;PartyList: 未提供初始化小队列表所需的描述文本参数。&quot;);&#xD;&#xA;            Thread staThread = new Thread(() =&gt; new PartyListForm(playerDescriptions).Run());&#xD;&#xA;            staThread.SetApartmentState(ApartmentState.STA);&#xD;&#xA;            staThread.Start();&#xD;&#xA;            staThread.Join();&#xD;&#xA;        }&#xD;&#xA;        finally&#xD;&#xA;        {&#xD;&#xA;            StaticHelpers.SetScalarVariable(false, &quot;PartyListForm_isRunning&quot;, null);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#region PartyListForm&#xD;&#xA;public class PartyListForm : Form&#xD;&#xA;{&#xD;&#xA;    public static Font UserFont = CreateFont(10, &quot;Microsoft YaHei&quot;, &quot;Microsoft JhengHei&quot;);&#xD;&#xA;&#xD;&#xA;    PartyListPanel partyListPanel;&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; The Panel that contains all the option groups on the form, scrollable. &lt;/summary&gt;&#xD;&#xA;    Panel mainPanel = new Panel()&#xD;&#xA;    {&#xD;&#xA;        AutoSize = true,&#xD;&#xA;        AutoSizeMode = AutoSizeMode.GrowAndShrink,&#xD;&#xA;        Dock = DockStyle.Top,&#xD;&#xA;        AutoScroll = true,&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; The TableLayoutPanel which contains buttons and other controls at the bottom of the form. &lt;/summary&gt;&#xD;&#xA;    TableLayoutPanel bottomPanel = new BottomTableLayoutPanel();&#xD;&#xA;&#xD;&#xA;    public Button btnSave = new MyButton { Text = &quot;保存&quot; };&#xD;&#xA;&#xD;&#xA;    public PartyListForm(params string[] playerDescriptions)&#xD;&#xA;    {&#xD;&#xA;        // SuspendLayout until Run()&#xD;&#xA;        SuspendLayout();&#xD;&#xA;        // basic&#xD;&#xA;        Text = Info.Name;&#xD;&#xA;        Font = UserFont;&#xD;&#xA;        TopMost = true;&#xD;&#xA;        StartPosition = FormStartPosition.CenterScreen;&#xD;&#xA;        int width = (TextRenderer.MeasureText(&quot;啊啊啊啊啊&quot;, Font).Width) * 8;&#xD;&#xA;        MinimumSize = new Size(width, width * 3 / 5); // To-do：添加一个根据所有控件总高度调节最小高度的逻辑&#xD;&#xA;&#xD;&#xA;        // Controls&#xD;&#xA;        Controls.Add(mainPanel);&#xD;&#xA;        Controls.Add(bottomPanel);&#xD;&#xA;        bottomPanel.Controls.Add(btnSave);&#xD;&#xA;        bottomPanel.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize));&#xD;&#xA;&#xD;&#xA;        // Events&#xD;&#xA;        Shown += (sender, e) =&gt; RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, &quot;/e &lt;se.9&gt;\n正在开启小队列表控件。\n如果没有看到，请检查后台窗口。&quot;);&#xD;&#xA;        Shown += (sender, e) =&gt; mainPanel.AutoScrollPosition = new Point(0, 0);&#xD;&#xA;        btnSave.Click += btnSave_Click;&#xD;&#xA;&#xD;&#xA;        // PartyListPanel&#xD;&#xA;        partyListPanel = new PartyListPanel(playerDescriptions);&#xD;&#xA;        var group = new MyGroupBox { Text = &quot; 小队顺序（拖拽调整）&quot; };&#xD;&#xA;        var panel = new GroupPanel();&#xD;&#xA;        mainPanel.Controls.Add(panel);&#xD;&#xA;        panel.Controls.Add(group);&#xD;&#xA;        group.Controls.Add(partyListPanel);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static Font CreateFont(float size, params string[] fontFamilies)&#xD;&#xA;    {&#xD;&#xA;        foreach (var fontFamily in fontFamilies)&#xD;&#xA;        {&#xD;&#xA;            try { return new Font(fontFamily, size); }&#xD;&#xA;            catch (ArgumentException) { }&#xD;&#xA;        }&#xD;&#xA;        return SystemFonts.DefaultFont;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void btnSave_Click(object sender, EventArgs e)&#xD;&#xA;    {&#xD;&#xA;        partyListPanel.SaveToConfig();&#xD;&#xA;        RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, &quot;/e &lt;se.10&gt;\n已保存小队列表。&quot;);&#xD;&#xA;        Close();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 读取配置，恢复表单布局，显示表单。&lt;/summary&gt;&#xD;&#xA;    public void Run()&#xD;&#xA;    {&#xD;&#xA;        partyListPanel.LoadFromConfig();&#xD;&#xA;        ResumeLayout();&#xD;&#xA;        ShowDialog();&#xD;&#xA;        Dispose();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    class BottomTableLayoutPanel : TableLayoutPanel&#xD;&#xA;    {&#xD;&#xA;        public BottomTableLayoutPanel() : base()&#xD;&#xA;        {&#xD;&#xA;            Dock = DockStyle.Bottom;&#xD;&#xA;            RowCount = 1;&#xD;&#xA;            ColumnCount = 1;&#xD;&#xA;            ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    class MyGroupBox : GroupBox&#xD;&#xA;    {&#xD;&#xA;        public MyGroupBox() : base()&#xD;&#xA;        {&#xD;&#xA;            Dock = DockStyle.Top;&#xD;&#xA;            AutoSize = true;&#xD;&#xA;            AutoSizeMode = AutoSizeMode.GrowAndShrink;&#xD;&#xA;            Margin = new Padding(20);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    class MyButton : Button&#xD;&#xA;    {&#xD;&#xA;        public MyButton() : base()&#xD;&#xA;        {&#xD;&#xA;            Anchor = AnchorStyles.None;&#xD;&#xA;            AutoSize = true;&#xD;&#xA;            Margin = new Padding(5);&#xD;&#xA;            Padding = new Padding(5);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    class BackgroundPanel : Panel&#xD;&#xA;    {&#xD;&#xA;        public BackgroundPanel() : base()&#xD;&#xA;        {&#xD;&#xA;            AutoSize = true;&#xD;&#xA;            AutoSizeMode = AutoSizeMode.GrowAndShrink;&#xD;&#xA;            Dock = DockStyle.Fill;&#xD;&#xA;            AutoScroll = true;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    class GroupPanel : Panel&#xD;&#xA;    {&#xD;&#xA;        public GroupPanel() : base()&#xD;&#xA;        {&#xD;&#xA;            AutoSize = true;&#xD;&#xA;            AutoSizeMode = AutoSizeMode.GrowAndShrink;&#xD;&#xA;            Dock = DockStyle.Top;&#xD;&#xA;            Padding = new Padding(20, 20, 20, 0);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#endregion&#xD;&#xA;" ActionType="ExecuteScript">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:小队列表}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${forceOpen}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="4" NamedCallbackName="PartyList" NamedCallbackParam="${d:PartyListPlayerDescs[${n: ${zoneid} ?? ${_ffxivzoneid} }]}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ev:PartyListForm_isRunning}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${forceOpen}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="5" LogMessageText="PartyList:MyIdx8:${v:myIdx}" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ev:myIdx}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
</Actions>
</Trigger>
<Trigger Enabled="true" Name="接收：团灭" Id="30acc2df-14f8-4c0b-a24f-2dacfcd68f73" RegularExpression="^.{15}\S+ 21:.{8}:4000000(?&lt;type&gt;[16])">
<Actions>
<Action OrderNumber="1" LogMessageText="PartyList:Show:0:1:0" LogProcess="True" ActionType="LogMessage" />
</Actions>
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${el:party}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="接收：文本指令　　/e party　（正确）" Id="2fd9d97a-3046-496c-9fb0-5c6b4312747e" RegularExpression="^.{15}\S+ 00:0038:: *[Pp][Aa][Rr][Tt][Yy] *(?&lt;force&gt; force)?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="条件：当前地图注册为全队模式（或使用 force 强制开启）" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="PartyList:Show:1:1:${if: len(${force}) &gt; 0 ? 1 : 0 }" LogProcess="True" ActionType="LogMessage" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${force}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
<ConditionGroup Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringNotEqualNocase" />
</ConditionGroup>
</Condition>
</Trigger>
</Triggers>
</Folder>
<Folder Id="fddd5d0f-0ff8-4f51-8c61-f4f058289eb5" DisableRemoteToggle="True" Name="记录自身位置" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="[F] Setter        PartyList:MyIdx8:[1-8]" Id="c5492c8b-d3b5-424a-a875-8c76eb1420e8" RegularExpression="^PartyList:MyIdx8:(?&lt;idx&gt;\d)">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="MyIdx8:序号" DescriptionOverride="True" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="myIdx" VariableExpression="${idx}" ActionType="Variable" />
<Action OrderNumber="3" VariableOp="SetNumeric" VariableName="myIdx_isG1" VariableExpression="${v:myIdx} % 2 = 1" ActionType="Variable" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="myIdx_isTH" VariableExpression="${v:myIdx} &lt;= 4" ActionType="Variable" />
<Action OrderNumber="5" VariableOp="SetNumeric" VariableName="myIdx_isTM" VariableExpression="${v:myIdx} % 4 % 3 != 0" ActionType="Variable" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="接收：团灭" Id="ca01efff-fa50-433d-9c36-a327f5135aff" RegularExpression="^.{15}\S+ 21:.{8}:4000000(?&lt;type&gt;[16])">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="条件：已注册 zoneId =&gt; Self" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="PartyList:MyIdxCheck:0:1:0:1:0:10::&lt;se.11&gt;" LogProcess="True" ActionType="LogMessage" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="接收：文本指令　　/e MT 　　（正确）" Id="02e85511-99d6-483b-a278-dbaad00ac70e" RegularExpression="^.{15}\S+ 00:0038:: *([MmSs][Tt]|[TtHhDd][1-4]) *$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="条件：当前地图未注册为全队模式" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="PartyList:MyIdx8:${?d: &#xD;&#xA;  MT = 1, T1 = 1,  &#xD;&#xA;  ST = 2, T2 = 2, &#xD;&#xA;  H1 = 3, &#xD;&#xA;  H2 = 4, &#xD;&#xA;  D1 = 5, &#xD;&#xA;  D2 = 6, &#xD;&#xA;  D3 = 7, &#xD;&#xA;  D4 = 8  &#xD;&#xA;  [${f:toupper:$1}]&#xD;&#xA;}" LogProcess="True" ActionType="LogMessage" />
<Action OrderNumber="3" />
<Action OrderNumber="4" LogMessageText="PartyList:MyIdxCheck:1:1:1:1:5:10:&lt;se.10&gt;:&lt;se.11&gt;" LogProcess="True" LogProcessACT="True" ActionType="LogMessage" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="[F] 注册区域      PartyList:Register:[zoneid]:Self" Id="b800fe7b-baef-43e1-9e68-f40bae8fc8fb" RegularExpression="^PartyList:Register:(?&lt;zoneid&gt;\d+):Self">
<Actions>
<Action OrderNumber="1" DictVariableOp="Set" DictVariableName="PartyListPlayerDescs" DictVariableKey="${zoneid}" DictVariableValue="Self" ActionType="DictVariable" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="如果当前处于要注册的地图：触发检查" DescriptionOverride="True" />
<Action OrderNumber="3" LogMessageText="PartyList:MyIdxCheck:1:1:1:1:10:10:&lt;se.9&gt;:&lt;se.9&gt;" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${zoneid}" ExpressionTypeL="String" ExpressionR="${_ffxivzoneid}" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
</Actions>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="[F] 检查或播报    PartyList:MyIdxCheck:..." Id="048572fa-78be-45ec-b48d-dcd26ab3d985" RegularExpression="^PartyList:MyIdxCheck:(?&lt;successTTS&gt;[01]):(?&lt;failTTS&gt;[01]):(?&lt;successEcho&gt;[01]):(?&lt;failEcho&gt;[01]):(?&lt;successHintTime&gt;[^:]+):(?&lt;failHintTime&gt;[^:]+):(?&lt;successSound&gt;[^:]*):(?&lt;failSound&gt;[^:]*)">
<Actions>
<Action OrderNumber="1" VariableOp="SetNumeric" VariableName="tmp_success" VariableExpression="(0${v:myIdx} &gt; 0) &amp;&amp; (0${v:myIdx} &lt;= 8) &amp;&amp; (0${v:myIdx} % 1 = 0)" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="fail" DescriptionOverride="True" />
<Action OrderNumber="3" VariableOp="SetString" VariableName="tmp_hint" VariableExpression="尚未设置自身职能。&#xD;&#xA;可输入文本指令设置，大小写不限。&#xD;&#xA;如：　/e mt　　/e h1　　/e d4" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${f:contain(&quot; &quot;):${_me.name}}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="4" VariableOp="SetString" VariableName="tmp_hint" VariableExpression="尚未設置自身職能。&#xD;&#xA;可輸入文本指令設置，大小写不限。&#xD;&#xA;如：　/e mt　　/e h1　　/e d4" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${f:contain(&quot; &quot;):${_me.name}}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="5" UseTTSTextExpression="尚未设置职能，请查看聊天栏默语提示。" ActionType="UseTTS" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_success}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${failTTS}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="6" NamedCallbackName="command" NamedCallbackParam="/e ${failSound}&#xD;&#xA;${v:tmp_hint}" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${failEcho}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_success}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="7" NamedCallbackName="warn" NamedCallbackParam="${failHintTime}&#xD;&#xA;${v:tmp_hint}" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="0${failHintTime}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericGreater" />
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_success}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="8" ActionType="Placeholder" Asynchronous="False" Description="success" DescriptionOverride="True" />
<Action OrderNumber="9" VariableOp="SetString" VariableName="tmp_hint" VariableExpression="已设置自身职能：${?l: MT, ST, H1, H2, D1, D2, D3, D4 [0${v:myIdx}]}&#xD;&#xA;如有误，可输入文本指令设置，大小写不限。&#xD;&#xA;如：　/e mt　　/e h1　　/e d4" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${f:contain(&quot; &quot;):${_me.name}}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="10" VariableOp="SetString" VariableName="tmp_hint" VariableExpression="已設置自身職能：${?l: MT, ST, H1, H2, D1, D2, D3, D4 [0${v:myIdx}]}&#xD;&#xA;如有誤，可輸入文本指令設置，大小写不限。&#xD;&#xA;如：　/e mt　　/e h1　　/e d4" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${f:contain(&quot; &quot;):${_me.name}}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="11" UseTTSTextExpression="已设置职能：${?l: MT, ST, H1, H2, D1, D2, D3, D4 [${v:myIdx}]}" ActionType="UseTTS" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_success}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${successTTS}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="12" NamedCallbackName="command" NamedCallbackParam="/e ${successSound}&#xD;&#xA;${v:tmp_hint}" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${successEcho}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_success}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="13" NamedCallbackName="hint" NamedCallbackParam="${successHintTime}&#xD;&#xA;${v:tmp_hint}" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="0${successHintTime}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericGreater" />
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_success}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="14" VariableName="tmp_hint" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="15" VariableName="tmp_success" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="接收：倒计时" Id="73514acd-de69-4d09-aac8-240afd508bad" RegularExpression="^.{15}\S+ 10C:">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="条件：已注册 zoneId =&gt; Self" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="PartyList:MyIdxCheck:0:1:0:1:0:10::&lt;se.11&gt;" LogProcess="True" ActionType="LogMessage" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="接收：文本指令　　/e MT 　  （全队模式下提示错误）" Id="824c6d6d-6a67-4c47-bea6-02c448a065df" RegularExpression="^.{15}\S+ 00:0038:: *([MmSs][Tt]|[TtHhDd][1-4]) *$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="条件：当前地图注册为全队模式" DescriptionOverride="True" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_hint" VariableExpression="当前地图需要设置全队顺序，而非自身职能顺序。&#xD;&#xA;请使用 /e party（应该会自动弹出窗口）。" ActionType="Variable">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${f:contain(&quot; &quot;):${_me.name}}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" VariableOp="SetString" VariableName="tmp_hint" VariableExpression="当前地圖需要設置全隊順序，而非自身職能順序。&#xD;&#xA;請使用 /e party（應該会自動彈出窗口）。" ActionType="Variable">
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${f:contain(&quot; &quot;):${_me.name}}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="4" NamedCallbackName="command" NamedCallbackParam="/e &lt;se.11&gt;&#xD;&#xA;${v:tmp_hint}" ActionType="NamedCallback" />
<Action OrderNumber="5" NamedCallbackName="warn" NamedCallbackParam="10&#xD;&#xA;${v:tmp_hint}" ActionType="NamedCallback" />
</Actions>
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="Self" ExpressionTypeR="String" ConditionType="StringNotEqualNocase" />
<ConditionSingle Enabled="true" ExpressionL="${d:PartyListPlayerDescs[${_ffxivzoneid}]}" ExpressionTypeL="String" ExpressionR="" ExpressionTypeR="String" ConditionType="StringNotEqualNocase" />
</Condition>
</Trigger>
</Triggers>
</Folder>
<Folder FFXIVZoneFilterEnabled="True" FfxivZoneFilterRegularExpression="^997$" Id="e5093644-63ea-4665-9d39-86bb6f38c70a" Name="测试（真小鸟）" Enabled="false">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="小队列表注册区域" Id="91055331-efde-46d9-8da4-32956e188039" RegularExpression="^.{15}\S+ 01:(?&lt;zoneId&gt;[^:]*):">
<Actions>
<Action OrderNumber="1" LogMessageText="PartyList:Register:${n: 0x${zoneId} }:MT, ST, H1, H2, D1, D2, D3, D4" LogProcess="True" ActionType="LogMessage" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="false" Name="使用说明（面向开发）" Id="cd4fd5b6-771b-43e7-bade-270e895303d5" RegularExpression="">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="首先通过触发器注册某副本的地图 ID" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="注册后可在进本、团灭、倒计时时自动触发提示" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="根据不同模式，用户可按提示设置自身或全队的职能顺序" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Asynchronous="False" Description="支持两种模式：" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Asynchronous="False" Description="1. 完整版" DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" Asynchronous="False" Description="    将 PartyList:Register:[要注册的地图 ID]:[逗号分隔的自定义的全员描述] 发送为待解析的 ACT 日志行，即可注册。" DescriptionOverride="True" />
<Action OrderNumber="7" ActionType="Placeholder" Asynchronous="False" Description="    如你可以使用 M4s 副本的 01 行（ZoneChanged）触发，并发送：PartyList:Register:1132:MT, ST, H1, H2, D1, D2, D3, D4" DescriptionOverride="True" />
<Action OrderNumber="8" ActionType="Placeholder" Asynchronous="False" Description="    用户也可以使用 /e party 手动调用此 UI" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Asynchronous="False" Description="  可使用的变量：" DescriptionOverride="True" />
<Action OrderNumber="10" ActionType="Placeholder" Asynchronous="False" Description="  · 列表 party：包含按顺序的八个 ID" DescriptionOverride="True" />
<Action OrderNumber="11" ActionType="Placeholder" Asynchronous="False" Description="  · 列表 pname：包含按顺序的八个名字（不建议在能使用 ID 的情况下使用）" DescriptionOverride="True" />
<Action OrderNumber="12" ActionType="Placeholder" Asynchronous="False" Description="  · 标量 myIdx：自身顺序，相当于 ${list:party.indexof(${_me.id})}" DescriptionOverride="True" />
<Action OrderNumber="13" ActionType="Placeholder" Asynchronous="False" Description="2. 单人版" DescriptionOverride="True" />
<Action OrderNumber="14" ActionType="Placeholder" Asynchronous="False" Description="    将 PartyList:Register:[要注册的地图 ID]:Self 发送为待解析的 ACT 日志行，即可注册。" DescriptionOverride="True" />
<Action OrderNumber="15" ActionType="Placeholder" Asynchronous="False" Description="    如你可以使用 M4s 副本的 01 行（ZoneChanged）触发，并发送：PartyList:Register:1132:Self" DescriptionOverride="True" />
<Action OrderNumber="16" ActionType="Placeholder" Asynchronous="False" Description="    用户需要使用 /e MT 等文本指令设置自身职能顺序" DescriptionOverride="True" />
<Action OrderNumber="17" ActionType="Placeholder" Asynchronous="False" Description="  可使用的变量：" DescriptionOverride="True" />
<Action OrderNumber="18" ActionType="Placeholder" Asynchronous="False" Description="   · 标量 myIdx：自身顺序" DescriptionOverride="True" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="[Debug] 模拟小队：/e setparty [自身idx] [总人数]" Id="fba6f66c-ecbe-4ed4-a27b-0b97da485cc1" RegularExpression="^.{15}\S+ 00:0038:: *(?i:setparty) +(?&lt;idx&gt;[1-8]) +(?&lt;all&gt;[1-8])$">
<Actions>
<Action OrderNumber="1" ListVariableOp="SetAll" ListVariableName="party" ListVariableExpression="10${n: ${_idx}*111111}" ListVariableIndex="${all}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="2" ListVariableOp="Set" ListVariableName="party" ListVariableExpression="${_me.id}" ListVariableIndex="${idx}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="3" VariableOp="SetString" VariableName="myIdx" VariableExpression="${idx}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="4" LogMessageText="PartyList:MyIdx8:${idx}" LogProcess="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${all}" ExpressionTypeL="String" ExpressionR="8" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="5" UseTTSTextExpression="已设置调试小队" ActionType="UseTTS" Asynchronous="False" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${idx}" ExpressionTypeL="String" ExpressionR="${all}" ExpressionTypeR="String" ConditionType="NumericLessEqual" />
</Condition>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="false" Source="None" Name="使用说明" Id="e78deb64-81b4-4df2-a8fb-f1e40c7af632" RegularExpression="">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="　用户不需要、也不应改变或执行任何触发器，仅需要保持分组开启即可。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="　如果你是普通用户，无需阅读下面的内容。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="　本工具箱包含以下内容：" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Asynchronous="False" Description="高级标点工具箱（新版）" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Asynchronous="False" Description="  在切换区域（包括 ACT 与游戏之一运行时开启另一个）时向触发器程序注册回调" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" Asynchronous="False" Description="  用户可以直接使用具名回调操作 “AdvWm” 触发。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="7" LaunchProcessPathExpression="https://github.com/MnFeN/ACT_Tech_Guide" ActionType="LaunchProcess" Description="· 右键 - 测试动作 打开说明文档链接（GitHub）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="8" NamedCallbackName="AdvWm" NamedCallbackParam="// 左侧箭头可以展开为多行模式&#xD;&#xA;// 双斜线开始的行会当做为注释行，和空行一起被忽略&#xD;&#xA;// 所有参数的顺序不重要，每行提供一个参数&#xD;&#xA;&#xD;&#xA;// 采用日志中的坐标系，即正东 x+，正南 y+，正上 z+&#xD;&#xA;// 角度从正北开始逆时针递增，如 北 西 南 东 分别为： ±π, -π/2, 0, π/2&#xD;&#xA;&#xD;&#xA;// 必须参数：action，代表标点模式&#xD;&#xA;// place 模式下允许你输入一组相对坐标&#xD;&#xA;action: place&#xD;&#xA;&#xD;&#xA;// 可选参数：scaleX scaleY scaleZ：坐标在各个方向上的缩放尺度，负数即为反向&#xD;&#xA;// 未提供时的默认值：均为 1&#xD;&#xA;scaleX: 2&#xD;&#xA;scaleY: -2&#xD;&#xA;// 如果尺度相同，可以使用 scale: 2 简化&#xD;&#xA;&#xD;&#xA;// 可选参数 θ：旋转角度，可以理解为将这个相对坐标系的正北旋转至哪个绝对方向&#xD;&#xA;// 未提供时的默认值：-π （将正北旋转至正北，即未旋转）&#xD;&#xA;θ: π/2&#xD;&#xA;// 也可以写作角度，如 θ: 90°&#xD;&#xA;&#xD;&#xA;// 可选参数 center：中心坐标&#xD;&#xA;// 下方演示的是使用触发器的实体查询功能获取并填入自身坐标&#xD;&#xA;// 未提供时的默认值：0, 0, 0&#xD;&#xA;center: ${_me.x}, ${_me.y}, ${_me.z}&#xD;&#xA;&#xD;&#xA;// 提供的坐标首先经过缩放变换，其次经过平面旋转，最后平移至中心坐标&#xD;&#xA;&#xD;&#xA;// 下方给出所有相对坐标：&#xD;&#xA;A: 0, -4, 0&#xD;&#xA;// z = 0 可以省略：&#xD;&#xA;B: 4, -4&#xD;&#xA;// 也可以使用极坐标模式：polar [r], [θ]：&#xD;&#xA;C: polar 4, 90°&#xD;&#xA;// 也可以结合两种模式，以平面直角坐标系下的坐标为中心进一步添加一个极坐标系的偏移：&#xD;&#xA;D: 0, 4 polar 2, 30°&#xD;&#xA;// 清除一个标点：&#xD;&#xA;1: clear&#xD;&#xA;// “清除”一个标点，实为移动到看不见的位置，使之下次出现时没有淡入动画：&#xD;&#xA;2: fakeclear&#xD;&#xA;// 没有提供的标点会被忽略，保持标点的原状态&#xD;&#xA;// 3:... 4:...&#xD;&#xA;&#xD;&#xA;// 三条 hyphen 连字符为分隔线，代表另起一条指令，所有指令依次执行&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;// circle 模式下通过给定的圆心和半径将所有点标记在圆周的等分位置&#xD;&#xA;action: circle&#xD;&#xA;&#xD;&#xA;// 必须参数：waymarks，从正北开始所有的标点&#xD;&#xA;// 可以使用 _ 表示这个位置依旧需要等分，但是并不放置一个标点，如下面代表八等分圆但正南不标点&#xD;&#xA;waymarks: ABCD_234&#xD;&#xA;&#xD;&#xA;// 必须参数：r，半径&#xD;&#xA;r: 5&#xD;&#xA;&#xD;&#xA;// 必须参数：center 圆心坐标&#xD;&#xA;center: ${_me.x}, ${_me.y}, ${_me.z}&#xD;&#xA;&#xD;&#xA;// 可选参数：θ，与 place 中类似&#xD;&#xA;θ: -π&#xD;&#xA;&#xD;&#xA;// linear（连接两个点）和 arc（朝某个方向标记圆弧）指令还没写介绍，有兴趣可以看代码&#xD;&#xA;" ActionType="NamedCallback" Description="· 也可双击这行查看一小段简短说明" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Asynchronous="False" Description="  此外，你可以使用指令：/e pl/place A/B/C/D/1/2/3/4 [x] [y] [z] 放置标点。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="10" ActionType="Placeholder" Asynchronous="False" Description="  坐标参数均为可选，不提供时用自身坐标，如 /e pl A 将 A 点放在自己脚下。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="11" ActionType="Placeholder" Asynchronous="False" Description="高级标点工具箱（旧版）" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="12" ActionType="Placeholder" Asynchronous="False" Description="　旧版本，使用固定格式的日志触发标点，已弃用，但触发器依然保留以兼容旧版科技。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="13" ActionType="Placeholder" Asynchronous="False" Description="鲶鱼精邮差扩展" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="14" ActionType="Placeholder" Asynchronous="False" Description="　详见【鲶鱼精邮差扩展】文件夹。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="15" ActionType="Placeholder" Asynchronous="False" Description="　CafeACT 无法使用。建议更换呆萌。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="16" ActionType="Placeholder" Asynchronous="False" Description="关于" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="17" ActionType="Placeholder" Asynchronous="False" Description="　作者：MnFeN 阿洛" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="18" ActionType="Placeholder" Asynchronous="False" Description="　致谢：AtmoOmen　　Fragile　　Latihas　　Natsukage　　Small-Miao" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</ExportedFolder>
</TriggernometryExport>
