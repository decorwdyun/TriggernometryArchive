<?xml version="1.0"?>
<TriggernometryExport PluginVersion="1.2.0.715">
<ExportedFolder Id="14b5d78d-fad2-46ff-b462-9c44cc49d414" ZoneFilterRegularExpression="环境变量的版本号也一起改" Name="高级标点工具箱 AdvWm" Enabled="true">
<Folders>
<Folder Id="01130d36-0f74-445b-9582-a4d32eeb4761" Name="3. 鲶鱼精邮差扩展 v2.4" Enabled="true" RawEnvironmentVariables="version = 2.4">
<Folders>
<Folder Id="39d74586-7913-4558-b75f-266b0363823c" Name="Entity" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Scaling" Id="aa553e61-fd03-4722-8f7f-70ba55449ebf" RegularExpression="^.{15}\S+ 00:0038::scale +(?&lt;scales&gt;.+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_address}" ExpressionTypeL="String" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="ObjectScaling" NamedCallbackParam="${v:tmp_address}, ${f:replace(&quot; &quot;, &quot;,&quot;):${scales}}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="SetHighlightColor" Id="653c2955-0cd7-41d7-a629-46582a96a9fc" RegularExpression="^.{15}\S+ 00:0038::highlight (?&lt;color&gt;\d+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_address}" ExpressionTypeL="String" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="SetHighlightColor" NamedCallbackParam="${v:tmp_address}, ${color}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="SetStatusLoopVfx" Id="1e3043b1-526b-441d-956b-c8cc02c3e280" RegularExpression="^.{15}\S+ 00:0038::vfx (?&lt;vfxid&gt;.+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_address}" ExpressionTypeL="String" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="SetStatusLoopVfx" NamedCallbackParam="${v:tmp_address}, ${vfxid}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Redraw" Id="bf7ae932-cfd6-4d98-8576-3871e6aac94c" RegularExpression="^.{15}\S+ 00:0038::redraw$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_address}" ExpressionTypeL="String" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="Redraw" NamedCallbackParam="${v:tmp_address}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="c6dd2e86-d5f6-4596-a1ae-32ef4784652f" Name="ShowTextGimmickHint" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Hint / Warn" Id="0d4d73ca-632e-4955-961d-a8510332b78d" RegularExpression="^.{15}\S+ 00:0038:: *(?&lt;type&gt;[Hh][Ii][Nn][Tt]|[Ww][Aa][Rr][Nn]) +(?&lt;t&gt;[\d.]+) (?&lt;data&gt;.+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="${f:tolower:${type}}" NamedCallbackParam="${n:${t}}&#xD;&#xA;${data}" ActionType="NamedCallback" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="0c108af5-7204-4fc4-9d45-933de4fa2e8a" Name="Quit" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Quit" Id="a7e67bc0-1c6d-49fa-8479-c9b480af8958" RegularExpression="^.{15}\S+ 00:0038:: *[Qq][Uu][Ii][Tt] *$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="quit" NamedCallbackParam="0" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="2" NamedCallbackName="quit" NamedCallbackParam="1" ActionType="NamedCallback" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="4032058f-514e-4ba3-a3a5-8dc9fd836689" Name="Vfx" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="LockOn" Id="bf56ac77-a21f-4d55-811c-9c032ca43c62" RegularExpression="^.{15}\S+ 00:0038::lockon (?&lt;vfxname&gt;.+)$">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_entity[${_me.targetid}].address}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_address" VariableExpression="${_me.address}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_address}" ExpressionTypeL="String" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="LockOn" NamedCallbackParam="${v:tmp_address}, ${vfxname}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="tmp_address" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="false" Name="Channeling" Id="452aa387-4a41-4cb6-a344-9f25a5916792" RegularExpression="^.{15}\S+ 00:0038::channeling (?&lt;vfxname&gt;.+)$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="Channeling" NamedCallbackParam="${_me.address}, ${_entity[${_me.targetid}].address}, ${vfxname}" ActionType="NamedCallback" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="0${_entity[${_me.targetid}].address}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringNotEqualCase" />
</Condition>
</Action>
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="PostNamazuExtension" Id="d7faf865-eb7e-4d95-89da-5afc6111106c" RegularExpression="^.{15}\S+ 01:">
<Actions>
<Action OrderNumber="1" ExecScriptExpression="using System.Windows.Forms;&#xD;&#xA;using System.Threading;&#xD;&#xA;using Triggernometry;&#xD;&#xA;&#xD;&#xA;public bool IsCafeACT()&#xD;&#xA;{&#xD;&#xA;    Control current = RealPlugin.plug.ui;&#xD;&#xA;    while (current != null &amp;&amp; !(current is TabControl))&#xD;&#xA;    {&#xD;&#xA;        current = current.Parent;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    if (current is TabControl tabControl)&#xD;&#xA;    {&#xD;&#xA;        foreach (TabPage tabPage in tabControl.TabPages)&#xD;&#xA;        {&#xD;&#xA;            if (tabPage.Text == &quot;插件中心&quot;)&#xD;&#xA;            {&#xD;&#xA;                return true;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    return false;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void Log(string msg) =&gt; Triggernometry.Interpreter.StaticHelpers.Log(RealPlugin.DebugLevelEnum.Warning, msg);&#xD;&#xA;void Error(string msg) =&gt; Triggernometry.Interpreter.StaticHelpers.Log(RealPlugin.DebugLevelEnum.Error, msg);&#xD;&#xA;&#xD;&#xA;if (IsCafeACT())&#xD;&#xA;{&#xD;&#xA;    Log(&quot;  不要截图到处问这是什么意思该怎么办，上面写得很清楚了。&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Log(&quot;  如果你想使用高级功能，目前已知的解决方法仅有更换呆萌整合版本。&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Log(&quot;  鲶鱼精邮差扩展无法运行，将只有基础的场地标点功能。&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Log(&quot;  由于 CafeACT 使用旧版 ACT 且未解决程序集版本冲突，&quot;);&#xD;&#xA;    Thread.Sleep(10);&#xD;&#xA;    Error(&quot;[高级标点工具箱] 检测到 CafeACT 环境。&quot;);&#xD;&#xA;    Triggernometry.RealPlugin.plug.RegisterNamedCallback(&quot;hint&quot;, new Action&lt;object, string&gt;((_, __) =&gt; {}), null, registrant: &quot;注册失败&quot;);&#xD;&#xA;}&#xD;&#xA;" ActionType="ExecuteScript" Asynchronous="False" Description="检测 Cafe 环境" DescriptionOverride="True" />
<Action OrderNumber="2" ExecScriptAssembliesExpression="PostNamazu, GreyMagic" ExecScriptExpression="using System;&#xD;&#xA;using System.Globalization;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Text;&#xD;&#xA;using System.Threading;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;using PostNamazu;&#xD;&#xA;using PostNamazu.Common;&#xD;&#xA;using GreyMagic;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using Triggernometry.PluginBridges;&#xD;&#xA;using System.Numerics;&#xD;&#xA;&#xD;&#xA;bool initialized = false;&#xD;&#xA;for (int i = 1; i &lt;= 5; i++)&#xD;&#xA;{&#xD;&#xA;    try&#xD;&#xA;    {&#xD;&#xA;        PostNamazuExtension.Init();&#xD;&#xA;        initialized = true;&#xD;&#xA;        break;&#xD;&#xA;    }&#xD;&#xA;    catch&#xD;&#xA;    {&#xD;&#xA;        PostNamazuExtension.Log(RealPlugin.DebugLevelEnum.Warning, $&quot;鲶鱼精邮差扩展初始化失败，正在重试第 {i} / 5 次……&quot;);&#xD;&#xA;        if (i == 5) throw;&#xD;&#xA;    }&#xD;&#xA;    Thread.Sleep(i * 1000);&#xD;&#xA;}&#xD;&#xA;PostNamazuExtension.Log(RealPlugin.DebugLevelEnum.Warning, $&quot;鲶鱼精邮差扩展初始化成功。&quot;);&#xD;&#xA;&#xD;&#xA;public static class PostNamazuExtension&#xD;&#xA;{&#xD;&#xA;&#xD;&#xA;    #region Common&#xD;&#xA;&#xD;&#xA;    private static readonly string Name = &quot;PostNamazuExtension&quot;;&#xD;&#xA;&#xD;&#xA;    public static PostNamazu.PostNamazu NamazuPlugin =&gt; (PostNamazu.PostNamazu)RealPlugin.InstanceHook(null, &quot;PostNamazu.PostNamazu&quot;).pluginObj;&#xD;&#xA;    public static ExternalProcessMemory Memory =&gt; NamazuPlugin?.Memory;&#xD;&#xA;    public static SigScanner Scanner =&gt; NamazuPlugin?.SigScanner;&#xD;&#xA;    public static bool IsCN =&gt; !BridgeFFXIV.GetMyself().GetValue(&quot;name&quot;).ToString().Contains(&quot; &quot;);&#xD;&#xA;    private static PostNamazuUi _postNamazuUi;&#xD;&#xA;    public static PostNamazuUi PostNamazuUi&#xD;&#xA;    {&#xD;&#xA;        get&#xD;&#xA;        {&#xD;&#xA;            if (_postNamazuUi?.Parent as TabPage == null)&#xD;&#xA;            {&#xD;&#xA;                _postNamazuUi = GetPostNamazuUi();&#xD;&#xA;            }&#xD;&#xA;            return _postNamazuUi;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static bool IsReady =&gt; Triggernometry.Interpreter.StaticHelpers.XivProcess != null &amp;&amp; Memory != null;&#xD;&#xA;&#xD;&#xA;    private static PostNamazuUi GetPostNamazuUi()&#xD;&#xA;    {&#xD;&#xA;        TabPage tp = RealPlugin.InstanceHook(null, &quot;PostNamazu.PostNamazu&quot;).TabPage;&#xD;&#xA;        return tp.Controls.OfType&lt;PostNamazuUi&gt;().FirstOrDefault();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void OnXivProcUpdate()&#xD;&#xA;    {&#xD;&#xA;        ScanSignatures();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void RegisterCallback(string callBackName, Action&lt;string&gt; callBackAction, IntPtr? ptr = null)&#xD;&#xA;    {&#xD;&#xA;        if (ptr == IntPtr.Zero) return;&#xD;&#xA;        Triggernometry.RealPlugin.plug.RegisterNamedCallback(&#xD;&#xA;            callBackName,&#xD;&#xA;            new Action&lt;object, string&gt;((_, cmd) =&gt; callBackAction(cmd)),&#xD;&#xA;            null,&#xD;&#xA;            registrant: Name&#xD;&#xA;        );&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Init()&#xD;&#xA;    {&#xD;&#xA;        OnXivProcUpdate();&#xD;&#xA;        Triggernometry.Interpreter.StaticHelpers.RegisterXivProcessUpdatedAction(Name, new System.Action(OnXivProcUpdate));&#xD;&#xA;        RegisterCallback(&quot;hint&quot;, ShowTextGimmickHint.Hint);&#xD;&#xA;        RegisterCallback(&quot;warn&quot;, ShowTextGimmickHint.Warn);&#xD;&#xA;&#xD;&#xA;        RegisterCallback(&quot;quit&quot;, QuitInstance.DoQuitInstance, QuitInstancePtr);&#xD;&#xA;&#xD;&#xA;        RegisterCallback(&quot;ObjectScaling&quot;, EntityHelper.ObjectScaling);&#xD;&#xA;        RegisterCallback(&quot;SetOpacity&quot;, EntityHelper.SetOpacity);&#xD;&#xA;        RegisterCallback(&quot;SetOpacityForOtherPlayers&quot;, EntityHelper.SetOpacityForOtherPlayers);&#xD;&#xA;        RegisterCallback(&quot;Hide&quot;, EntityHelper.Hide);&#xD;&#xA;        RegisterCallback(&quot;HideOtherPlayers&quot;, EntityHelper.HideOtherPlayers);&#xD;&#xA;        RegisterCallback(&quot;SetStatusLoopVfx&quot;, EntityHelper.SetStatusLoopVfx);&#xD;&#xA;        RegisterCallback(&quot;Redraw&quot;, EntityHelper.Redraw);&#xD;&#xA;        RegisterCallback(&quot;SetHighlightColor&quot;, EntityHelper.SetHighlightColor);&#xD;&#xA;&#xD;&#xA;        RegisterCallback(&quot;LockOn&quot;, VfxHelper.LockOn, ActorVfxCreatePtr);&#xD;&#xA;        RegisterCallback(&quot;Channeling&quot;, VfxHelper.Channeling, ActorVfxCreatePtr);&#xD;&#xA;        //RegisterCallback(&quot;StaticVfxTest&quot;, VfxHelper.StaticVfxTest);&#xD;&#xA;        Echo($&quot;已激活：{Name} v${env:version}&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void CheckBeforeExecution(string command)&#xD;&#xA;    {&#xD;&#xA;        if (!IsReady)&#xD;&#xA;            throw new Exception(PostNamazu.Common.I18n.Translate(&quot;NamazuModule/XivProcNotFound&quot;, &quot;没有对应的 FFXIV 进程&quot;));&#xD;&#xA;&#xD;&#xA;        if (string.IsNullOrWhiteSpace(command))&#xD;&#xA;            throw new Exception(PostNamazu.Common.I18n.Translate(&quot;NamazuModule/EmptyCommand&quot;, &quot;指令为空&quot;));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    #endregion Common&#xD;&#xA;&#xD;&#xA;    #region Scanning&#xD;&#xA;&#xD;&#xA;    public static IntPtr GetUiModulePtr;&#xD;&#xA;    public static IntPtr FrameworkPtrPtr;&#xD;&#xA;    public static IntPtr ShowTextGimmickHintPtr;&#xD;&#xA;    public static IntPtr QuitInstancePtr;&#xD;&#xA;&#xD;&#xA;    public static IntPtr StaticVfxCreatePtr;    // 静态特效创建&#xD;&#xA;    public static IntPtr StaticVfxRunPtr;       // 静态特效运行&#xD;&#xA;    public static IntPtr StaticVfxRemovePtr;    // 静态特效移除&#xD;&#xA;    public static IntPtr ActorVfxCreatePtr;&#xD;&#xA;    public static IntPtr ActorVfxRemovePtr;&#xD;&#xA;    public static IntPtr CreateOmenPtr;&#xD;&#xA;    public static IntPtr RemoveOmenPtr;&#xD;&#xA;    //public const string RescourseLoadSyncSig = &quot;E8 ?? ?? ?? ?? 48 8B ?? ?? ?? 84 ?? 40 ?? ?? F6 B9&quot;;//资源加载(同步Sig)&#xD;&#xA;    //public const string SetOmenColorSig = &quot;48 ?? ?? ?? ?? ?? ?? 48 ?? ?? 74 ?? 48 ?? ?? ?? f3 ?? ?? ?? ?? ?? f3 0f 11 89&quot;;//设置Omen颜色Sig&#xD;&#xA;    //public const string SetOmenMatrixSig = &quot;e8 ?? ?? ?? ?? 48 ?? ?? e8 ?? ?? ?? ?? 85 ?? 74 ?? 84&quot;;//设置Omen矩阵Sig&#xD;&#xA;    //public const string CreateVfxSig = &quot;e8 ?? ?? ?? ?? 48 ?? ?? 48 ?? ?? 74 ?? b2 ?? 48 ?? ?? e8 ?? ?? ?? ?? b2 ?? 48 ?? ?? e8 ?? ?? ?? ?? f6 05&quot;;//创建特效Sig&#xD;&#xA;    //public const string SetVfxP1Sig = &quot;e8 ?? ?? ?? ?? b2 ?? 48 ?? ?? e8 ?? ?? ?? ?? f6 05&quot;;//不知道设置什么Sig1&#xD;&#xA;    //public const string SetVfxP2Sig = &quot;e8 ?? ?? ?? ?? f6 05 ?? ?? ?? ?? ?? 74 ?? 80 3d ?? ?? ?? ?? ?? 73&quot;;//不知道什么Sig2&#xD;&#xA;    //public const string InitVfxParamSig = &quot;e8 ?? ?? ?? ?? f3 ?? ?? ?? ?? ?? ?? ?? 48 ?? ?? ?? ?? ?? ?? 48 ?? ?? ?? 48 ?? ?? ?? ?? c7 44 24&quot;;// 初始化特效参数Sig&#xD;&#xA;    //public const string GetResourceSyncSig = &quot;E8 ?? ?? ?? ?? 48 8D 8F ?? ?? ?? ?? 48 89 87 ?? ?? ?? ?? 48 8D 54 24&quot;;&#xD;&#xA;    //public const string VfxResSettupCompleteSig = &quot;40 ?? 48 ?? ?? ?? 48 ?? ?? 33 ?? 8b ?? f0 0f c0 83&quot;;&#xD;&#xA;&#xD;&#xA;    public static void ScanSignatures()&#xD;&#xA;    {&#xD;&#xA;        var myName = BridgeFFXIV.GetMyself().GetValue(&quot;name&quot;).ToString();&#xD;&#xA;        bool notFound = string.IsNullOrEmpty(myName);&#xD;&#xA;        bool isCn = !notFound &amp;&amp; !myName.Contains(&quot; &quot;);&#xD;&#xA;        bool isGlobal = !notFound &amp;&amp; myName.Contains(&quot; &quot;);&#xD;&#xA;        if (isCn || notFound) // 7.0 CN&#xD;&#xA;        {&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                var sigStart = Scanner.ScanText(&quot;49 8B C4 48 8B 0D&quot;, nameof(FrameworkPtrPtr));&#xD;&#xA;                FrameworkPtrPtr = sigStart + 24 + Memory.Read&lt;int&gt;(sigStart + 20);&#xD;&#xA;                notFound = false;&#xD;&#xA;            }&#xD;&#xA;            catch { }&#xD;&#xA;        }&#xD;&#xA;        if (isGlobal || notFound) // 7.0 global&#xD;&#xA;        {&#xD;&#xA;            var sigStart = Scanner.ScanText(&quot;49 8B DC 48 89 1D&quot;, nameof(FrameworkPtrPtr));&#xD;&#xA;            FrameworkPtrPtr = sigStart + 10 + Memory.Read&lt;int&gt;(sigStart + 6);&#xD;&#xA;        }&#xD;&#xA;        GetUiModulePtr = Scanner.ScanText(&quot;E8 ?? ?? ?? ?? 80 7B 1D 01&quot;, nameof(GetUiModulePtr));&#xD;&#xA;        ShowTextGimmickHintPtr = Scanner.ScanText(&quot;48 ?? ?? 0F 84 ?? ?? ?? ?? 4C ?? ?? 49 89 5B ?? 49 89 73&quot;, nameof(ShowTextGimmickHintPtr));&#xD;&#xA;        QuitInstancePtr = Scanner.ScanText(&quot;48 83 EC ?? 0F B6 D1 45 33 C9&quot;, nameof(QuitInstancePtr));&#xD;&#xA;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            //StaticVfxCreatePtr = Scanner.ScanText(&quot;E8 ?? ?? ?? ?? F3 0F 10 35 ?? ?? ?? ?? 48 89 43 08&quot;, nameof(StaticVfxCreatePtr));&#xD;&#xA;            //StaticVfxRunPtr = Scanner.ScanText(&quot;E8 ?? ?? ?? ?? 8B 4B 7C 85 C9&quot;, nameof(StaticVfxRunPtr));&#xD;&#xA;            //StaticVfxRemovePtr = Scanner.ScanText(&quot;40 53 48 83 EC 20 48 8B D9 48 8B 89 ?? ?? ?? ?? 48 85 C9 74 28 33 D2 E8 ?? ?? ?? ?? 48 8B 8B ?? ?? ?? ?? 48 85 C9&quot;, nameof(StaticVfxRemovePtr));&#xD;&#xA;            ActorVfxCreatePtr = Scanner.ScanText(&quot;E8 ?? ?? ?? ?? 48 8B D8 48 85 C0 74 ?? 0F B6 57 ?? 48 8B C8 C0 EA 02 80 E2 01&quot;, nameof(ActorVfxCreatePtr));&#xD;&#xA;            //ActorVfxCreatePtr = Scanner.ScanText(&quot;40 53 55 56 57 48 81 EC ?? ?? ?? ?? 0F 29 B4 24 ?? ?? ?? ?? 48 8B 05 ?? ?? ?? ?? 48 33 C4 48 89 84 24 ?? ?? ?? ?? 0F B6 AC 24 ?? ?? ?? ?? 0F 28 F3 49 8B F8&quot;, nameof(ActorVfxCreatePtr));&#xD;&#xA;            var sigStart = Scanner.ScanText(&quot;0F 11 48 10 48 8D 05 ?? ?? ?? ??&quot;, nameof(ActorVfxRemovePtr));&#xD;&#xA;            ActorVfxRemovePtr = Memory.Read&lt;IntPtr&gt;(sigStart + 11 + Memory.Read&lt;int&gt;(sigStart + 7));&#xD;&#xA;            //CreateOmenPtr = Scanner.ScanText(&quot;E8 ?? ?? ?? ?? 8D 4F ?? 48 63 D1 48 89 84 D3 ?? ?? ?? ??&quot;, nameof(CreateOmenPtr));&#xD;&#xA;            //RemoveOmenPtr = Scanner.ScanText(&quot;e8 ?? ?? ?? ?? 4c ?? ?? 48 ?? ?? ?? ?? 48 ?? ?? ?? ?? ?? ?? e8 ?? ?? ?? ?? eb&quot;, nameof(RemoveOmenPtr));&#xD;&#xA;        }&#xD;&#xA;        catch (Exception ex)&#xD;&#xA;        {&#xD;&#xA;            Log(RealPlugin.DebugLevelEnum.Error, $&quot;鲶鱼精邮差扩展的特效模块初始化失败，可能是游戏版本更新或某些卫月插件冲突所致：\n{ex.Message}\n&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #endregion Scanning&#xD;&#xA;&#xD;&#xA;    private static readonly object assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;    public static void ExecuteWithLock(System.Action action)&#xD;&#xA;    {&#xD;&#xA;        bool lockTaken = false;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            Monitor.Enter(assemblyLock, ref lockTaken);&#xD;&#xA;            action();&#xD;&#xA;        }&#xD;&#xA;        finally { if (lockTaken) Monitor.Exit(assemblyLock); }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static T ExecuteWithLock&lt;T&gt;(Func&lt;T&gt; function)&#xD;&#xA;    {&#xD;&#xA;        bool lockTaken = false;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            Monitor.Enter(assemblyLock, ref lockTaken);&#xD;&#xA;            return function();&#xD;&#xA;        }&#xD;&#xA;        finally { if (lockTaken) Monitor.Exit(assemblyLock); }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class ShowTextGimmickHint&#xD;&#xA;    {&#xD;&#xA;        public static void Hint(string command) =&gt; DoShowTextGimmickHint(true, command);&#xD;&#xA;        public static void Warn(string command) =&gt; DoShowTextGimmickHint(false, command);&#xD;&#xA;&#xD;&#xA;        public static void DoShowTextGimmickHint(bool isInfo, string command)&#xD;&#xA;        {&#xD;&#xA;            CheckBeforeExecution(command);&#xD;&#xA;&#xD;&#xA;            string rawTime = command.Substring(0, command.IndexOf('\n')).Trim();&#xD;&#xA;            if (!double.TryParse(rawTime, NumberStyles.Float, CultureInfo.InvariantCulture, out double time))&#xD;&#xA;            {&#xD;&#xA;                throw Context.ParseTypeError(&quot;string&quot;, rawTime, &quot;double&quot;, command);&#xD;&#xA;            }&#xD;&#xA;            int timeIn100Ms = Math.Max(0, (int)(time * 10));&#xD;&#xA;            string text = command.Substring(command.IndexOf('\n') + 1);&#xD;&#xA;            PostNamazuUi?.Log((isInfo ? &quot;Hint&quot; : &quot;Warn&quot;) + $&quot; ({timeIn100Ms / 10.0:F1} s): \n{text}&quot;);&#xD;&#xA;&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                var frameworkPtr = Memory.Read&lt;IntPtr&gt;(FrameworkPtrPtr);&#xD;&#xA;                var uiModulePtr = Memory.CallInjected64&lt;IntPtr&gt;(GetUiModulePtr, frameworkPtr);&#xD;&#xA;                var raptureAtkModule = Memory.CallInjected64&lt;IntPtr&gt;(Memory.Read&lt;IntPtr&gt;(Memory.Read&lt;IntPtr&gt;(uiModulePtr) + (0x8 * 7)), uiModulePtr);&#xD;&#xA;                var array = Encoding.UTF8.GetBytes(text);&#xD;&#xA;                using AllocatedMemory allocatedMemory = Memory.CreateAllocatedMemory(array.Length + 30);&#xD;&#xA;                allocatedMemory.AllocateOfChunk(&quot;cmd&quot;, array.Length);&#xD;&#xA;                allocatedMemory.WriteBytes(&quot;cmd&quot;, array);&#xD;&#xA;                _ = Memory.CallInjected64&lt;int&gt;(ShowTextGimmickHintPtr, raptureAtkModule, allocatedMemory.Address, isInfo ? 1 : 0, timeIn100Ms);&#xD;&#xA;            }&#xD;&#xA;            finally&#xD;&#xA;            {&#xD;&#xA;                if (flag) Monitor.Exit(assemblyLock);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class QuitInstance&#xD;&#xA;    {&#xD;&#xA;        public static void DoQuitInstance(string cmd)&#xD;&#xA;        {&#xD;&#xA;            cmd = cmd.Trim().ToLower();&#xD;&#xA;            bool force = cmd == &quot;1&quot; || cmd == &quot;true&quot;;&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                _ = Memory.CallInjected64&lt;IntPtr&gt;(QuitInstancePtr, force ? 1 : 0);&#xD;&#xA;            }&#xD;&#xA;            finally&#xD;&#xA;            {&#xD;&#xA;                if (flag) Monitor.Exit(assemblyLock);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class EntityHelper&#xD;&#xA;    {&#xD;&#xA;        public static void ObjectScaling(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            float scaleX = float.Parse(args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            float scaleY = float.Parse(args.Length &gt; 1 ? args[1] : args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            float scaleZ = float.Parse(args.Length &gt; 2 ? args[2] : args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                ObjectScaling(objectPtr, scaleX, scaleY, scaleZ);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetOpacity(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            float opacity = float.Parse(args[0], NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                SetOpacity(objectPtr, opacity);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetOpacityForOtherPlayers(string cmd)&#xD;&#xA;        {&#xD;&#xA;            float opacity = float.Parse(cmd, NumberStyles.Float, CultureInfo.InvariantCulture);&#xD;&#xA;            var addresses = BridgeFFXIV.GetAllEntities()&#xD;&#xA;                .Where(c =&gt; (c.GetValue(&quot;id&quot;).ToString().StartsWith(&quot;10&quot;) &amp;&amp; c.GetValue(&quot;id&quot;).ToString() != BridgeFFXIV.PlayerHexId)&#xD;&#xA;                     || c.GetValue(&quot;ownerid&quot;).ToString().StartsWith(&quot;10&quot;))&#xD;&#xA;                .Select(c =&gt; (IntPtr)long.Parse(c.GetValue(&quot;address&quot;).ToString()));&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                foreach (var address in addresses)&#xD;&#xA;                {&#xD;&#xA;                    SetOpacity(address, opacity);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Hide(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            bool hide = bool.TryParse(args[0].ToLower(), out hide) ? hide : (!MathParser.IsZero(MathParser.Parse(args[0])));&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                Hide(objectPtr, hide);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void HideOtherPlayers(string cmd)&#xD;&#xA;        {&#xD;&#xA;            bool hide = bool.TryParse(cmd.ToLower(), out hide) ? hide : (!MathParser.IsZero(MathParser.Parse(cmd)));&#xD;&#xA;&#xD;&#xA;            var addresses = BridgeFFXIV.GetAllEntities()&#xD;&#xA;                .Where(c =&gt; (c.GetValue(&quot;id&quot;).ToString().StartsWith(&quot;10&quot;) &amp;&amp; c.GetValue(&quot;id&quot;).ToString() != BridgeFFXIV.PlayerHexId)&#xD;&#xA;                     || c.GetValue(&quot;ownerid&quot;).ToString().StartsWith(&quot;10&quot;))&#xD;&#xA;                .Select(c =&gt; (IntPtr)long.Parse(c.GetValue(&quot;address&quot;).ToString()));&#xD;&#xA;&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                foreach (var address in addresses)&#xD;&#xA;                {&#xD;&#xA;                    Hide(address, hide);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetStatusLoopVfx(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            ushort vfxId = ushort.Parse(args[0]);&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                SetStatusLoopVfx(objectPtr, vfxId);&#xD;&#xA;                DisableDraw(objectPtr);&#xD;&#xA;                EnableDraw(objectPtr);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Redraw(string address)&#xD;&#xA;        {&#xD;&#xA;            IntPtr entityPtr = (IntPtr)long.Parse(address);&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                DisableDraw(entityPtr);&#xD;&#xA;                EnableDraw(entityPtr);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void SetHighlightColor(string cmd)&#xD;&#xA;        {&#xD;&#xA;            var args = ParseArgs_OutAddress(cmd, out IntPtr objectPtr);&#xD;&#xA;            byte color = byte.Parse(args[0]);&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                SetHighlightColor(objectPtr, color);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void ObjectScaling(IntPtr objectAddress, float scaleX, float scaleY, float scaleZ)&#xD;&#xA;        {&#xD;&#xA;            uint id = Memory.Read&lt;uint&gt;(objectAddress + 0x74);&#xD;&#xA;            if (BridgeFFXIV.PlayerId == id) // 调整视角高度&#xD;&#xA;            {&#xD;&#xA;                Memory.Write&lt;float&gt;(objectAddress + 0xC4, (scaleZ + 1) / 2f);&#xD;&#xA;            }&#xD;&#xA;            IntPtr drawObjectAddress = Memory.Read&lt;IntPtr&gt;(objectAddress + 0x100);&#xD;&#xA;            Memory.Write&lt;float&gt;(drawObjectAddress + 0x70, scaleX);&#xD;&#xA;            Memory.Write&lt;float&gt;(drawObjectAddress + 0x74, scaleZ);&#xD;&#xA;            Memory.Write&lt;float&gt;(drawObjectAddress + 0x78, scaleY);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void SetOpacity(IntPtr objectAddress, float opacity)&#xD;&#xA;        {&#xD;&#xA;            // FFXIVClientStructs/FFXIV/Client/Game/Character/Character.cs&#xD;&#xA;            // [FieldOffset(0x21C8)] public float Alpha;&#xD;&#xA;            Memory.Write&lt;float&gt;(objectAddress + 0x21C8, opacity);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void Hide(IntPtr objectAddress, bool hide)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write&lt;byte&gt;(objectAddress + 0x118, (byte)(hide ? 2 : 0));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void SetStatusLoopVfx(IntPtr objectAddress, ushort id)&#xD;&#xA;        {&#xD;&#xA;            Memory.Write&lt;ushort&gt;(objectAddress + (IsCN ? 0x1D8 : 0x1C8), id);&#xD;&#xA;            DisableDraw(objectAddress);&#xD;&#xA;            EnableDraw(objectAddress);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void EnableDraw(IntPtr address)&#xD;&#xA;        {&#xD;&#xA;            IntPtr vTablePtr = Memory.Read&lt;IntPtr&gt;(address);&#xD;&#xA;            IntPtr enableDrawPtr = Memory.Read&lt;IntPtr&gt;(vTablePtr + 8 * 12);&#xD;&#xA;            _ = Memory.CallInjected64&lt;IntPtr&gt;(enableDrawPtr, address);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void DisableDraw(IntPtr address)&#xD;&#xA;        {&#xD;&#xA;            IntPtr vTablePtr = Memory.Read&lt;IntPtr&gt;(address);&#xD;&#xA;            IntPtr disableDrawPtr = Memory.Read&lt;IntPtr&gt;(vTablePtr + 8 * 13);&#xD;&#xA;            _ = Memory.CallInjected64&lt;IntPtr&gt;(disableDrawPtr, address);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void SetHighlightColor(IntPtr address, byte color)&#xD;&#xA;        {&#xD;&#xA;            IntPtr vTablePtr = Memory.Read&lt;IntPtr&gt;(address);&#xD;&#xA;            IntPtr setHighlightColorPtr = Memory.Read&lt;IntPtr&gt;(vTablePtr + 8 * 26);&#xD;&#xA;            _ = Memory.CallInjected64&lt;IntPtr&gt;(setHighlightColorPtr, address, color);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static class VfxHelper&#xD;&#xA;    {&#xD;&#xA;        public static void LockOn(string cmd)&#xD;&#xA;        {&#xD;&#xA;            string[] args = ParseArgs_OutAddress(cmd, out IntPtr tgtAddress);&#xD;&#xA;            string vfxName = args[0];&#xD;&#xA;            var assemblyLock = Memory.Executor.AssemblyLock;&#xD;&#xA;            var flag = false;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                Monitor.Enter(assemblyLock, ref flag);&#xD;&#xA;                _LockOn(tgtAddress, vfxName);&#xD;&#xA;            }&#xD;&#xA;            finally { if (flag) Monitor.Exit(assemblyLock); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static IntPtr _LockOn(IntPtr tgtAddress, string vfxName)&#xD;&#xA;        {&#xD;&#xA;            string path = $&quot;vfx/lockon/eff/{vfxName}.avfx&quot;;&#xD;&#xA;            IntPtr pathPtr = IntPtr.Zero;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                pathPtr = Memory.AllocateMemory(256);&#xD;&#xA;                Memory.WriteString(pathPtr, path, Encoding.UTF8);&#xD;&#xA;                IntPtr vfxHandle = Memory.CallInjected64&lt;IntPtr&gt;(&#xD;&#xA;                    ActorVfxCreatePtr,&#xD;&#xA;                    pathPtr,    // vfx name&#xD;&#xA;                    tgtAddress, // caster &#xD;&#xA;                    tgtAddress, // target &#xD;&#xA;                    -1f, /*(char)*/(ushort)0, 0, /*(char)*/(ushort)0&#xD;&#xA;                );&#xD;&#xA;                return vfxHandle;&#xD;&#xA;            }&#xD;&#xA;            finally { if (pathPtr != IntPtr.Zero) Memory.FreeMemory(pathPtr); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public static void Channeling(string cmd)&#xD;&#xA;        {&#xD;&#xA;            string[] args = ParseArgs_OutAddress2(cmd, out IntPtr srcAddress, out IntPtr tgtAddress);&#xD;&#xA;            string vfxName = args[0];&#xD;&#xA;            double duration = args.Length &gt; 1 ? double.Parse(args[1], NumberStyles.Float, CultureInfo.InvariantCulture) : 3.0;&#xD;&#xA;&#xD;&#xA;            IntPtr vfxHandle = ExecuteWithLock(() =&gt; _Channeling(srcAddress, tgtAddress, vfxName));&#xD;&#xA;            Thread.Sleep((int)(duration * 1000));&#xD;&#xA;            ExecuteWithLock(() =&gt; _ActorVfxRemove(vfxHandle));&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static IntPtr _Channeling(IntPtr srcAddress, IntPtr tgtAddress, string vfxName)&#xD;&#xA;        {&#xD;&#xA;            string path = $&quot;vfx/channeling/eff/{vfxName}.avfx&quot;;&#xD;&#xA;            IntPtr pathPtr = IntPtr.Zero;&#xD;&#xA;            try&#xD;&#xA;            {&#xD;&#xA;                pathPtr = Memory.AllocateMemory(256);&#xD;&#xA;                Memory.WriteString(pathPtr, path, Encoding.UTF8);&#xD;&#xA;                IntPtr vfxHandle = Memory.CallInjected64&lt;IntPtr&gt;(&#xD;&#xA;                    ActorVfxCreatePtr,&#xD;&#xA;                    pathPtr,    // vfx name&#xD;&#xA;                    srcAddress, // caster &#xD;&#xA;                    tgtAddress, // target &#xD;&#xA;                    -1f, /*(char)*/(ushort)0, 0, /*(char)*/(ushort)0&#xD;&#xA;                );&#xD;&#xA;                return vfxHandle;&#xD;&#xA;            }&#xD;&#xA;            finally { if (pathPtr != IntPtr.Zero) Memory.FreeMemory(pathPtr); }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        private static void _ActorVfxRemove(IntPtr vfxHandle)&#xD;&#xA;        {&#xD;&#xA;            Memory.CallInjected64&lt;IntPtr&gt;(ActorVfxRemovePtr, vfxHandle, /*(char)*/(ushort)1);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static string[] ParseArgs_OutAddress(string cmd, out IntPtr address)&#xD;&#xA;    {&#xD;&#xA;        var args = Context.SplitArguments(cmd);&#xD;&#xA;        address = (IntPtr)long.Parse(args[0]);&#xD;&#xA;        return args.Skip(1).ToArray();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static string[] ParseArgs_OutAddress2(string cmd, out IntPtr address1, out IntPtr address2)&#xD;&#xA;    {&#xD;&#xA;        var args = Context.SplitArguments(cmd);&#xD;&#xA;        address1 = (IntPtr)long.Parse(args[0]);&#xD;&#xA;        address2 = (IntPtr)long.Parse(args[1]);&#xD;&#xA;        return args.Skip(2).ToArray();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Echo(string msg) =&gt; RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e {msg}&quot;);&#xD;&#xA;&#xD;&#xA;    public static void Log(RealPlugin.DebugLevelEnum level, string msg) =&gt; Interpreter.StaticHelpers.Log(level, msg);&#xD;&#xA;&#xD;&#xA;}" ActionType="ExecuteScript" Description="鲶鱼精邮差扩展【注册回调】" DescriptionOverride="True">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:hint}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:hint}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="false" Source="None" Name="鲶鱼精邮差扩展 说明" Id="3d73adad-f7c4-4148-a509-4d410fc2991e" RegularExpression="">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="CafeACT 无法使用此工具。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="鲶鱼精邮差扩展" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="　利用鲶鱼精邮差的内存相关工具，向触发器注册以下回调。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Asynchronous="False" Description="　注：这些功能与鲶鱼精本身无关。下方的测试行可以双击查看怎么使用。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Asynchronous="False" Description="1. 文本提示：“hint”（蓝色）、“warn”（红色），回调参数：“时间/秒（换行）显示文本”" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="6" NamedCallbackName="warn" NamedCallbackParam="3&#xD;&#xA;我是 Honey Bee 小姐的狗！" ActionType="NamedCallback" Description="· 右键此行可测试动作（显示提示文本）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="7" ActionType="Placeholder" Asynchronous="False" Description="2. 退出副本：“quit”，回调参数留空，如下一行" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="8" NamedCallbackName="quit" ActionType="NamedCallback" Description="· 右键此行可测试动作（退本）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Asynchronous="False" Description="3. 缩放实体：“ObjectScaling”，回调参数为 “实体地址, scaleX, scaleY, scaleZ”, 如下一行" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="10" NamedCallbackName="ObjectScaling" NamedCallbackParam="${_me.address}, 5" ActionType="NamedCallback" Description="· 右键此行可测试动作（放大自身）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="11" NamedCallbackName="ObjectScaling" NamedCallbackParam="${_me.address}, 1" ActionType="NamedCallback" Description="· 右键此行可测试动作（复原自身）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="12" ActionType="Placeholder" Asynchronous="False" Description="4. 设置不透明度：“SetOpacity”，回调参数为 “实体地址, 不透明度(0-1)” (7.1 暂不能使用)" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="13" NamedCallbackName="SetOpacity" NamedCallbackParam="${_me.address}, 0.3" ActionType="NamedCallback" Description="· 右键此行可测试动作（自身半透明）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="14" NamedCallbackName="SetOpacityForOtherPlayers" NamedCallbackParam="0.1" ActionType="NamedCallback" Description="· 右键此行可测试动作（全员半透明）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="15" NamedCallbackName="SetOpacity" NamedCallbackParam="${_me.address}, 1" ActionType="NamedCallback" Description="· 右键此行可测试动作（自身恢复）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="16" ActionType="Placeholder" Asynchronous="False" Description="5. 隐藏实体" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="17" NamedCallbackName="HideOtherPlayers" NamedCallbackParam="1" ActionType="NamedCallback" Description="· 右键此行可测试动作（全员隐藏）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="18" NamedCallbackName="HideOtherPlayers" NamedCallbackParam="0" ActionType="NamedCallback" Description="· 右键此行可测试动作（全员恢复）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="19" ActionType="Placeholder" Asynchronous="False" Description="6. 设置状态特效（StatusLoopVfx）" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="20" NamedCallbackName="SetStatusLoopVfx" NamedCallbackParam="${_me.address}, 683" ActionType="NamedCallback" Description="· 右键此行可测试动作（设置自身特效）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="21" NamedCallbackName="SetStatusLoopVfx" NamedCallbackParam="${_me.address}, 692" ActionType="NamedCallback" Description="· 右键此行可测试动作（设置自身特效）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="22" NamedCallbackName="SetStatusLoopVfx" NamedCallbackParam="${_me.address}, 0" ActionType="NamedCallback" Description="· 右键此行可测试动作（清除自身特效）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="23" ActionType="Placeholder" Asynchronous="False" Description="7. 设置点名标记特效（LockOn）" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="24" NamedCallbackName="LockOn" NamedCallbackParam="${_me.address}, m0857_stop_s5t1" ActionType="NamedCallback" Description="· 右键此行可测试动作（设置自身特效）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="25" NamedCallbackName="LockOn" NamedCallbackParam="${_me.address}, m0855trg_rot_c5a1" ActionType="NamedCallback" Description="· 右键此行可测试动作（设置自身特效）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="26" ActionType="Placeholder" Asynchronous="False" Description="8. 设置连线特效（Channeling）" DescBgColor="f0f8ff" DescTextColor="26f" DescriptionOverride="True" />
<Action OrderNumber="27" NamedCallbackName="Channeling" NamedCallbackParam="${_me.address}, ${_entity[${_me.targetid}].address}, chn_m0906_ht02k2" ActionType="NamedCallback" Description="· 右键此行可测试动作（设置特效：自身 → 选中的目标）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="9321d3b3-db08-4c77-a666-12ea3aa4c955" Name="1. 旧版本 v2.x（仅兼容）" Enabled="true">
<Folders>
<Folder Id="7bc14cc3-b30e-4a30-ab98-de293175e0d7" Name="场地标点" Enabled="true">
<Folders>
<Folder Id="5fe0d99f-46c7-415d-931d-7189cc5d0f7a" Name="debug" Enabled="false">
<Folders />
<Triggers>
<Trigger Enabled="false" Name="测试循环标点     B：自己-B 线性    AC：自己-C 径向" Id="62f5e3e1-f796-4e2d-8538-f70352cd6b2f" RegularExpression="^.{15}\S+ 1C:Add:(?&lt;wmid&gt;\d+):.{8}:(?&lt;pn&gt;[^:]+):(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" VariableOp="SetNumeric" VariableName="1" VariableExpression="${v:1} + 1" ActionType="Variable" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="AdmWm_test_A" VariableExpression="${x}:${y}:${z}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="3" LogMessageText="AdvWm_linearConnect:start:${_me.x}:${_me.y}:${_me.z}:end:${x}:${y}:${z}:waymarkers:ABCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="4" LogMessageText="AdvWm_polarConnect:center:${v:AdmWm_test_A}:start:${_me.x}:${_me.y}:${_me.z}:end:${x}:${y}:${z}:waymarkers:BCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="2" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="5" LogMessageText="${_event}" LogProcess="True" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid} = 1 || ${wmid} = 2" ExpressionTypeL="Numeric" ExpressionR="1" ExpressionTypeR="Numeric" ConditionType="NumericEqual" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pn}" ExpressionTypeL="String" ExpressionR="${_me}" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Trigger>
<Trigger Enabled="false" Name="测试   A-B：线性   A-C：径向" Id="8216a097-c621-45db-ba8c-6c1d96597c67" RegularExpression="^.{15}\S+ 1C:Add:(?&lt;wmid&gt;\d+):.{8}:(?&lt;pn&gt;[^:]+):(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" VariableOp="SetString" VariableName="AdmWm_test_start" VariableExpression="start:${x}:${y}:${z}" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="2" LogMessageText="AdvWm:linear:${v:AdmWm_test_start}:end:${x}:${y}:${z}:waymarkers:ABCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="3" LogMessageText="AdvWm:polar:center:${_me.x}:${_me.y}:${v:AdmWm_test_start}:end:${x}:${y}:${z}:waymarkers:ABCD1234" LogProcess="True" VariableOp="SetString" ActionType="LogMessage" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wmid}" ExpressionTypeL="String" ExpressionR="2" ExpressionTypeR="String" ConditionType="NumericEqual" />
</Condition>
</Action>
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pn}" ExpressionTypeL="String" ExpressionR="${_me}" ExpressionTypeR="String" ConditionType="StringEqualNocase" />
</Condition>
</Trigger>
</Triggers>
</Folder>
<Folder Id="5892ce88-e3e5-4028-aad6-dcb431cbeace" Name="恢复 / 清空标点" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="Load 队列" Id="1797a53f-32e1-41d0-a594-f50c7f3e5f8b" RegularExpression="^AdvWm_loadQueue:(?&lt;t&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="本触发器会被所有标点指令打断" DescriptionOverride="True" />
<Action OrderNumber="2" NamedCallbackName="place" NamedCallbackParam="load" ActionType="NamedCallback" ExecutionDelayExpression="(${t}) * 1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Load" Id="67d0391f-3a0c-4722-8bb9-a6d5e7bfb77d" RegularExpression="^AdvWm_load$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="place" NamedCallbackParam="load" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Clear" Id="f7c6e160-74a4-4e69-9f4d-1fd3e10ea206" RegularExpression="^AdvWm_clear$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="place" NamedCallbackParam="{&#xD;&#xA;  &quot;A&quot;:{}, &#xD;&#xA;  &quot;B&quot;:{}, &#xD;&#xA;  &quot;C&quot;:{}, &#xD;&#xA;  &quot;D&quot;:{}, &#xD;&#xA;  &quot;One&quot;:{}, &#xD;&#xA;  &quot;Two&quot;:{}, &#xD;&#xA;  &quot;Three&quot;:{}, &#xD;&#xA;  &quot;Four&quot;:{}&#xD;&#xA;}" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="Clear 队列" Id="717d5d8c-d723-4726-8a87-3ce0bab8b66f" RegularExpression="^AdvWm_clearQueue:(?&lt;t&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="本触发器会被所有标点指令打断" DescriptionOverride="True" />
<Action OrderNumber="2" NamedCallbackName="place" NamedCallbackParam="{&#xD;&#xA;  &quot;A&quot;:{}, &#xD;&#xA;  &quot;B&quot;:{}, &#xD;&#xA;  &quot;C&quot;:{}, &#xD;&#xA;  &quot;D&quot;:{}, &#xD;&#xA;  &quot;One&quot;:{}, &#xD;&#xA;  &quot;Two&quot;:{}, &#xD;&#xA;  &quot;Three&quot;:{}, &#xD;&#xA;  &quot;Four&quot;:{}&#xD;&#xA;}" ActionType="NamedCallback" ExecutionDelayExpression="(${t}) * 1000" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="转发排队" Id="e9eedd43-98ff-4347-b42f-f43ccc596f37" RegularExpression="^AdvWm_(?&lt;type&gt;clear|load):(?&lt;t&gt;.+)$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="用这个转发，以免同时执行一条标点和一条排队取消时，后者立刻被前者打断" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="AdvWm_${type}Queue:${n: max(0, ${t} - 0.5) }" LogProcess="True" ActionType="LogMessage" ExecutionDelayExpression="${t} &gt; 0.5 ? 0.5 : ${t}" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="9e0479ef-598b-4aa2-86fd-82fbbd2de7b0" Name="本地标点转为网络标点" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="本地标点转为网络标点" Id="f80b4f8a-7882-4d82-903d-406341774880" RegularExpression="^AdvWm_public$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="command" NamedCallbackParam="/waymark save 30" ActionType="NamedCallback" />
<Action OrderNumber="2" NamedCallbackName="command" NamedCallbackParam="/waymark preset 30" ActionType="NamedCallback" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="如果你无论如何一定想在 30 号位置存自己的标点，把上面两个 30 换成你不用的槽位。" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Name="径向插值标点 polarConnect" Id="da5da6c8-051a-48e7-a6f6-3cd06181d234" RegularExpression="^AdvWm_polarConnect:[Cc]enter:(?&lt;xc&gt;[^:]+):(?&lt;yc&gt;[^:]+)(?::[^:]+)?:[Ss]tart:(?&lt;x0&gt;[^:]+):(?&lt;y0&gt;[^:]+):(?&lt;z0&gt;[^:]+):[Ee]nd:(?&lt;x1&gt;[^:]+):(?&lt;y1&gt;[^:]+):(?&lt;z1&gt;[^:]+):[Ww]aymarkers:(?&lt;wm&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="1797a53f-32e1-41d0-a594-f50c7f3e5f8b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="717d5d8c-d723-4726-8a87-3ce0bab8b66f" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Description="初始化" DescriptionOverride="True" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_len" VariableExpression="${f:length:${wm}}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" DictVariableOp="Build" DictVariableTarget="AdvWm_WmMapping" DictVariableValue="=,A=A,B=B,C=C,D=D,1=One,2=Two,3=Three,4=Four" DictTargetPersist="True" ActionType="DictVariable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pd:AdvWm_WmMapping.size}" ExpressionTypeL="String" ExpressionR="8" ExpressionTypeR="String" ConditionType="NumericNotEqual" />
</Condition>
</Action>
<Action OrderNumber="6" ActionType="Placeholder" Description="极坐标转换（注：实际为不考虑高度的柱坐标系）" DescriptionOverride="True" />
<Action OrderNumber="7" VariableOp="SetNumeric" VariableName="AdvWm_r0" VariableExpression="d(${xc}, ${yc}, ${x0}, ${y0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="8" VariableOp="SetNumeric" VariableName="AdvWm_r1" VariableExpression="d(${xc}, ${yc}, ${x1}, ${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="9" VariableOp="SetNumeric" VariableName="AdvWm_θ0" VariableExpression="θ(${xc}, ${yc}, ${x0}, ${y0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="10" VariableOp="SetNumeric" VariableName="AdvWm_θ1" VariableExpression="θ(${xc}, ${yc}, ${x1}, ${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="11" VariableOp="SetNumeric" VariableName="AdvWm_θ1" VariableExpression="relθ(${v:AdvWm_θ0}, ${v:AdvWm_θ1}) + ${v:AdvWm_θ0}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" ActionType="Placeholder" Description="wm 拆分为列表   转换为标点名" DescriptionOverride="True" />
<Action OrderNumber="13" ListVariableOp="SetAll" ListVariableName="AdvWm_polar" ListVariableExpression="${pd:AdvWm_WmMapping[${f:slice(${n:${_idx}-1}):${wm}}]}" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="14" ActionType="Placeholder" Description="计算所有半径和角度" DescriptionOverride="True" />
<Action OrderNumber="15" ListVariableOp="SetAll" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_r" ListVariableExpression="((${v:AdvWm_len} - ${_idx}) * ${v:AdvWm_r0} + (${_idx} - 1) * ${v:AdvWm_r1}) / (${v:AdvWm_len} - 1)" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="16" ListVariableOp="SetAll" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_θ" ListVariableExpression="((${v:AdvWm_len} - ${_idx}) * ${v:AdvWm_θ0} + (${_idx} - 1) * ${v:AdvWm_θ1}) / (${v:AdvWm_len} - 1)" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="17" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="18" ListVariableOp="SetAll" ListVariableName="AdvWm_polar" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;: ${n: ${xc} + ${l:AdvWm_r[${_idx}]} * sin(${l:AdvWm_θ[${_idx}]})}, &#xD;&#xA;    &quot;Z&quot;: ${n: ${yc} + ${l:AdvWm_r[${_idx}]} * cos(${l:AdvWm_θ[${_idx}]})}, &#xD;&#xA;    &quot;Y&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${z0} + (${_idx} - 1) * ${z1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Active&quot;: true&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="19" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="20" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_polar.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wm}" ExpressionTypeL="String" ExpressionR="[A-D1-4]{2,8}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="绝对坐标标点 abs" Id="5c439cf2-5e58-48bb-a1da-d9321b4a458a" RegularExpression="^AdvWm_abs(?&lt;A&gt;:A:(?&lt;xa&gt;[^:]*):(?&lt;ya&gt;[^:]*):(?&lt;za&gt;[^:]*):(?&lt;aa&gt;[^:]*))?(?&lt;B&gt;:B:(?&lt;xb&gt;[^:]*):(?&lt;yb&gt;[^:]*):(?&lt;zb&gt;[^:]*):(?&lt;ab&gt;[^:]*))?(?&lt;C&gt;:C:(?&lt;xc&gt;[^:]*):(?&lt;yc&gt;[^:]*):(?&lt;zc&gt;[^:]*):(?&lt;ac&gt;[^:]*))?(?&lt;D&gt;:D:(?&lt;xd&gt;[^:]*):(?&lt;yd&gt;[^:]*):(?&lt;zd&gt;[^:]*):(?&lt;ad&gt;[^:]*))?(?&lt;One&gt;:One:(?&lt;x1&gt;[^:]*):(?&lt;y1&gt;[^:]*):(?&lt;z1&gt;[^:]*):(?&lt;a1&gt;[^:]*))?(?&lt;Two&gt;:Two:(?&lt;x2&gt;[^:]*):(?&lt;y2&gt;[^:]*):(?&lt;z2&gt;[^:]*):(?&lt;a2&gt;[^:]*))?(?&lt;Three&gt;:Three:(?&lt;x3&gt;[^:]*):(?&lt;y3&gt;[^:]*):(?&lt;z3&gt;[^:]*):(?&lt;a3&gt;[^:]*))?(?&lt;Four&gt;:Four:(?&lt;x4&gt;[^:]*):(?&lt;y4&gt;[^:]*):(?&lt;z4&gt;[^:]*):(?&lt;a4&gt;[^:]*))?$">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="1797a53f-32e1-41d0-a594-f50c7f3e5f8b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="717d5d8c-d723-4726-8a87-3ce0bab8b66f" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" VariableOp="SetNumeric" VariableName="AdvWm_x_A" VariableExpression="(${xa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_y_A" VariableExpression="(${ya})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" VariableOp="SetNumeric" VariableName="AdvWm_z_A" VariableExpression="(${za})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="6" VariableOp="SetNumeric" VariableName="AdvWm_a_A" VariableExpression="(${aa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="7" VariableOp="SetNumeric" VariableName="AdvWm_x_B" VariableExpression="(${xb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="8" VariableOp="SetNumeric" VariableName="AdvWm_y_B" VariableExpression="(${yb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="9" VariableOp="SetNumeric" VariableName="AdvWm_z_B" VariableExpression="(${zb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="10" VariableOp="SetNumeric" VariableName="AdvWm_a_B" VariableExpression="(${ab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="11" VariableOp="SetNumeric" VariableName="AdvWm_x_C" VariableExpression="(${xc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" VariableOp="SetNumeric" VariableName="AdvWm_y_C" VariableExpression="(${yc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="13" VariableOp="SetNumeric" VariableName="AdvWm_z_C" VariableExpression="(${zc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="14" VariableOp="SetNumeric" VariableName="AdvWm_a_C" VariableExpression="(${ac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="15" VariableOp="SetNumeric" VariableName="AdvWm_x_D" VariableExpression="(${xd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="16" VariableOp="SetNumeric" VariableName="AdvWm_y_D" VariableExpression="(${yd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="17" VariableOp="SetNumeric" VariableName="AdvWm_z_D" VariableExpression="(${zd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="18" VariableOp="SetNumeric" VariableName="AdvWm_a_D" VariableExpression="(${ad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="19" VariableOp="SetNumeric" VariableName="AdvWm_x_One" VariableExpression="(${x1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="20" VariableOp="SetNumeric" VariableName="AdvWm_y_One" VariableExpression="(${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="SetNumeric" VariableName="AdvWm_z_One" VariableExpression="(${z1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" VariableOp="SetNumeric" VariableName="AdvWm_a_One" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="SetNumeric" VariableName="AdvWm_x_Two" VariableExpression="(${x2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="24" VariableOp="SetNumeric" VariableName="AdvWm_y_Two" VariableExpression="(${y2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="25" VariableOp="SetNumeric" VariableName="AdvWm_z_Two" VariableExpression="(${z2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="26" VariableOp="SetNumeric" VariableName="AdvWm_a_Two" VariableExpression="(${a2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="27" VariableOp="SetNumeric" VariableName="AdvWm_x_Three" VariableExpression="(${x3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="28" VariableOp="SetNumeric" VariableName="AdvWm_y_Three" VariableExpression="(${y3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="29" VariableOp="SetNumeric" VariableName="AdvWm_z_Three" VariableExpression="(${z3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="30" VariableOp="SetNumeric" VariableName="AdvWm_a_Three" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="31" VariableOp="SetNumeric" VariableName="AdvWm_x_Four" VariableExpression="(${x4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="32" VariableOp="SetNumeric" VariableName="AdvWm_y_Four" VariableExpression="(${y4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="33" VariableOp="SetNumeric" VariableName="AdvWm_z_Four" VariableExpression="(${z4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="34" VariableOp="SetNumeric" VariableName="AdvWm_a_Four" VariableExpression="(${a4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="35" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="36" ListVariableOp="Build" ListVariableExpression=",A,B,C,D,One,Two,Three,Four" ListVariableTarget="AdvWm_abs" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="37" ListVariableOp="Filter" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_abs" ListVariableExpression="${f:length:${${_this}}} != 0" ListVariableTarget="AdvWm_abs" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="38" ListVariableOp="SetAll" ListVariableName="AdvWm_abs" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;:${var:AdvWm_x_${_this}}, &#xD;&#xA;    &quot;Y&quot;:${var:AdvWm_z_${_this}}, &#xD;&#xA;    &quot;Z&quot;:${var:AdvWm_y_${_this}}, &#xD;&#xA;    &quot;Active&quot;:${var:AdvWm_a_${_this}}&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="39" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="40" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_abs.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="41" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="42" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="43" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="线性插值标点 linearConnect" Id="760b7865-2b82-47cf-9cee-2a50a87056cf" RegularExpression="^AdvWm_linearConnect:[Ss]tart:(?&lt;x0&gt;[^:]+):(?&lt;y0&gt;[^:]+):(?&lt;z0&gt;[^:]+):[Ee]nd:(?&lt;x1&gt;[^:]+):(?&lt;y1&gt;[^:]+):(?&lt;z1&gt;[^:]+):[Ww]aymarkers:(?&lt;wm&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="1797a53f-32e1-41d0-a594-f50c7f3e5f8b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="717d5d8c-d723-4726-8a87-3ce0bab8b66f" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Description="初始化" DescriptionOverride="True" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_len" VariableExpression="${f:length:${wm}}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" DictVariableOp="Build" DictVariableTarget="AdvWm_WmMapping" DictVariableValue="=,A=A,B=B,C=C,D=D,1=One,2=Two,3=Three,4=Four" DictTargetPersist="True" ActionType="DictVariable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${pd:AdvWm_WmMapping.size}" ExpressionTypeL="String" ExpressionR="8" ExpressionTypeR="String" ConditionType="NumericNotEqual" />
</Condition>
</Action>
<Action OrderNumber="6" ActionType="Placeholder" Description="wm 拆分为列表   转换为标点名" DescriptionOverride="True" />
<Action OrderNumber="7" ListVariableOp="SetAll" ListVariableName="AdvWm_linear" ListVariableExpression="${pd:AdvWm_WmMapping[${f:slice(${n:${_idx}-1}):${wm}}]}" ListVariableIndex="${v:AdvWm_len}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="8" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="9" ListVariableOp="SetAll" ListVariableName="AdvWm_linear" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${x0} + (${_idx} - 1) * ${x1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Z&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${y0} + (${_idx} - 1) * ${y1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Y&quot;: ${n: ((${v:AdvWm_len} - ${_idx}) * ${z0} + (${_idx} - 1) * ${z1}) / (${v:AdvWm_len} - 1)}, &#xD;&#xA;    &quot;Active&quot;: true&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="10" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="11" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_linear.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="13" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="14" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${wm}" ExpressionTypeL="String" ExpressionR="[A-D1-4]{2,8}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="旋转矩阵标点 rotate" Id="2467d152-d6b6-4f09-bc62-061c990591b0" RegularExpression="^AdvWm_rotate(?::[Ss]cale:(?&lt;scale&gt;[^:]*))?(?::θ:(?&lt;theta&gt;[^:]*))?(?::[Cc]enter:(?&lt;x0&gt;[^:]*):(?&lt;y0&gt;[^:]*):(?&lt;z0&gt;[^:]*))?(?&lt;A&gt;:A:(?&lt;xa&gt;[^:]*):(?&lt;ya&gt;[^:]*):(?&lt;za&gt;[^:]*):(?&lt;aa&gt;[^:]*))?(?&lt;B&gt;:B:(?&lt;xb&gt;[^:]*):(?&lt;yb&gt;[^:]*):(?&lt;zb&gt;[^:]*):(?&lt;ab&gt;[^:]*))?(?&lt;C&gt;:C:(?&lt;xc&gt;[^:]*):(?&lt;yc&gt;[^:]*):(?&lt;zc&gt;[^:]*):(?&lt;ac&gt;[^:]*))?(?&lt;D&gt;:D:(?&lt;xd&gt;[^:]*):(?&lt;yd&gt;[^:]*):(?&lt;zd&gt;[^:]*):(?&lt;ad&gt;[^:]*))?(?&lt;One&gt;:One:(?&lt;x1&gt;[^:]*):(?&lt;y1&gt;[^:]*):(?&lt;z1&gt;[^:]*):(?&lt;a1&gt;[^:]*))?(?&lt;Two&gt;:Two:(?&lt;x2&gt;[^:]*):(?&lt;y2&gt;[^:]*):(?&lt;z2&gt;[^:]*):(?&lt;a2&gt;[^:]*))?(?&lt;Three&gt;:Three:(?&lt;x3&gt;[^:]*):(?&lt;y3&gt;[^:]*):(?&lt;z3&gt;[^:]*):(?&lt;a3&gt;[^:]*))?(?&lt;Four&gt;:Four:(?&lt;x4&gt;[^:]*):(?&lt;y4&gt;[^:]*):(?&lt;z4&gt;[^:]*):(?&lt;a4&gt;[^:]*))?$">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="1797a53f-32e1-41d0-a594-f50c7f3e5f8b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="717d5d8c-d723-4726-8a87-3ce0bab8b66f" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" ActionType="Placeholder" Description="本触发器为带有旋转角度的标点函数，以 给定的各组坐标偏移 与 给定角度对应的旋转矩阵 分别相乘得到各组实际坐标，并以计算结果调用鲶鱼精邮差场地标点。" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Description="格式：AdvWm_rotate:θ:-3.14:Center:100:100:0:A:0:-10:0:1:B:10:0:0:1:C:...:D:...:One:...:Two:...:Three:...:Four:..." DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="7" ActionType="Placeholder" Description="θ: 作为相对北的参照物所处的坐标的 atan2(dx, dy) 值，即从绝对正北开始逆时针一周 -pi 至 pi" DescriptionOverride="True" />
<Action OrderNumber="8" ActionType="Placeholder" Description="Center：场中心坐标，作为旋转中心。需要 (x0, y0, z0) 三个数值。" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Description="A/B/C/D/One/Two/Three/Four: 四个值：(dx, dy, dz, isActive)。其中坐标偏移以相对中心、相对方向为正北时的参考系计算。如以参照物为正北（正上）" DescriptionOverride="True" />
<Action OrderNumber="10" ActionType="Placeholder" Description="如以参照物为正北（正上）时，位于场地中心左 5 下 2 的 A 点，可以记为 “A:-5:2:0:1”" DescriptionOverride="True" />
<Action OrderNumber="11" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="12" ActionType="Placeholder" Description="可以缺少整组数据（如 B:xB:yB:zB:isActiveB 整组省略），但剩余组要按顺序。" DescriptionOverride="True" />
<Action OrderNumber="13" ActionType="Placeholder" Description="省略的θ、Center组将使用缺省值：-pi, (100, 100, 0), 省略某个标点组则不会修改该标点（与鲶鱼精邮差相同）。" DescriptionOverride="True" />
<Action OrderNumber="14" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="15" ActionType="Placeholder" Description="也可以缺少单个数据，但要保留冒号，如前文“A:-5:2:0:1”可以记做“A:-5:2::1”，场地中心的 3 点可记做“Three::::1”。" DescriptionOverride="True" />
<Action OrderNumber="16" ActionType="Placeholder" Description="省略的参数将使用缺省值：x0 = 100, y0 = 100, z0 = 0, θ = -pi, 标点的四个参数均为 0" DescriptionOverride="True" />
<Action OrderNumber="17" ActionType="Placeholder" DescriptionOverride="True" />
<Action OrderNumber="18" VariableOp="SetNumeric" VariableName="AdvWm_θ" VariableExpression="${theta} ?? -pi" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="19" VariableOp="SetNumeric" VariableName="AdvWm_x0" VariableExpression="${x0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="20" VariableOp="SetNumeric" VariableName="AdvWm_y0" VariableExpression="${y0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="SetNumeric" VariableName="AdvWm_z0" VariableExpression="(${z0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" VariableOp="SetNumeric" VariableName="AdvWm_x_A" VariableExpression="(${xa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="SetNumeric" VariableName="AdvWm_y_A" VariableExpression="(${ya})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="24" VariableOp="SetNumeric" VariableName="AdvWm_z_A" VariableExpression="(${za})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="25" VariableOp="SetNumeric" VariableName="AdvWm_a_A" VariableExpression="(${aa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="26" VariableOp="SetNumeric" VariableName="AdvWm_x_B" VariableExpression="(${xb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="27" VariableOp="SetNumeric" VariableName="AdvWm_y_B" VariableExpression="(${yb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="28" VariableOp="SetNumeric" VariableName="AdvWm_z_B" VariableExpression="(${zb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="29" VariableOp="SetNumeric" VariableName="AdvWm_a_B" VariableExpression="(${ab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="30" VariableOp="SetNumeric" VariableName="AdvWm_x_C" VariableExpression="(${xc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="31" VariableOp="SetNumeric" VariableName="AdvWm_y_C" VariableExpression="(${yc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="32" VariableOp="SetNumeric" VariableName="AdvWm_z_C" VariableExpression="(${zc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="33" VariableOp="SetNumeric" VariableName="AdvWm_a_C" VariableExpression="(${ac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="34" VariableOp="SetNumeric" VariableName="AdvWm_x_D" VariableExpression="(${xd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="35" VariableOp="SetNumeric" VariableName="AdvWm_y_D" VariableExpression="(${yd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="36" VariableOp="SetNumeric" VariableName="AdvWm_z_D" VariableExpression="(${zd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="37" VariableOp="SetNumeric" VariableName="AdvWm_a_D" VariableExpression="(${ad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="38" VariableOp="SetNumeric" VariableName="AdvWm_x_One" VariableExpression="(${x1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="39" VariableOp="SetNumeric" VariableName="AdvWm_y_One" VariableExpression="(${y1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="40" VariableOp="SetNumeric" VariableName="AdvWm_z_One" VariableExpression="(${z1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="41" VariableOp="SetNumeric" VariableName="AdvWm_a_One" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="42" VariableOp="SetNumeric" VariableName="AdvWm_x_Two" VariableExpression="(${x2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="43" VariableOp="SetNumeric" VariableName="AdvWm_y_Two" VariableExpression="(${y2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="44" VariableOp="SetNumeric" VariableName="AdvWm_z_Two" VariableExpression="(${z2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="45" VariableOp="SetNumeric" VariableName="AdvWm_a_Two" VariableExpression="(${a2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="46" VariableOp="SetNumeric" VariableName="AdvWm_x_Three" VariableExpression="(${x3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="47" VariableOp="SetNumeric" VariableName="AdvWm_y_Three" VariableExpression="(${y3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="48" VariableOp="SetNumeric" VariableName="AdvWm_z_Three" VariableExpression="(${z3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="49" VariableOp="SetNumeric" VariableName="AdvWm_a_Three" VariableExpression="(${a3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="50" VariableOp="SetNumeric" VariableName="AdvWm_x_Four" VariableExpression="(${x4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="51" VariableOp="SetNumeric" VariableName="AdvWm_y_Four" VariableExpression="(${y4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="52" VariableOp="SetNumeric" VariableName="AdvWm_z_Four" VariableExpression="(${z4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="53" VariableOp="SetNumeric" VariableName="AdvWm_a_Four" VariableExpression="(${a4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="54" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="55" ListVariableOp="Build" ListVariableExpression=",A,B,C,D,One,Two,Three,Four" ListVariableTarget="AdvWm_rotate" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="56" ListVariableOp="Filter" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_rotate" ListVariableExpression="${f:length:${${_this}}} != 0" ListVariableTarget="AdvWm_rotate" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="57" ListVariableOp="SetAll" ListVariableName="AdvWm_rotate" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;:${n: ${var:AdvWm_x0} + (${scale} ?? 1) * (- ${var:AdvWm_x_${_this}}*cos(${var:AdvWm_θ}) - ${var:AdvWm_y_${_this}}*sin(${var:AdvWm_θ}))}, &#xD;&#xA;    &quot;Y&quot;:${n: ${var:AdvWm_z0} + (${scale} ?? 1) * ${var:AdvWm_z_${_this}}}, &#xD;&#xA;    &quot;Z&quot;:${n: ${var:AdvWm_y0} + (${scale} ?? 1) * (+ ${var:AdvWm_x_${_this}}*sin(${var:AdvWm_θ}) - ${var:AdvWm_y_${_this}}*cos(${var:AdvWm_θ}))}, &#xD;&#xA;    &quot;Active&quot;:${var:AdvWm_a_${_this}}&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="58" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="59" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_rotate.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="60" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="61" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="62" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="极坐标标点 polarDeg / polarRad" Id="c57d10d5-5ad9-448f-a231-2113478e8ecc" RegularExpression="^AdvWm_polar(?&lt;type&gt;Deg|Rad)(?::[Ss]cale:(?&lt;scale&gt;[^:]*))?(?::θ:(?&lt;theta&gt;[^:]*))?(?::[Cc]enter:(?&lt;x0&gt;[^:]*):(?&lt;y0&gt;[^:]*):(?&lt;z0&gt;[^:]*))?(?&lt;A&gt;:A:(?&lt;ra&gt;[^:]*):(?&lt;thetaa&gt;[^:]*):(?&lt;za&gt;[^:]*):(?&lt;aa&gt;[^:]*))?(?&lt;B&gt;:B:(?&lt;rb&gt;[^:]*):(?&lt;thetab&gt;[^:]*):(?&lt;zb&gt;[^:]*):(?&lt;ab&gt;[^:]*))?(?&lt;C&gt;:C:(?&lt;rc&gt;[^:]*):(?&lt;thetac&gt;[^:]*):(?&lt;zc&gt;[^:]*):(?&lt;ac&gt;[^:]*))?(?&lt;D&gt;:D:(?&lt;rd&gt;[^:]*):(?&lt;thetad&gt;[^:]*):(?&lt;zd&gt;[^:]*):(?&lt;ad&gt;[^:]*))?(?&lt;One&gt;:One:(?&lt;r1&gt;[^:]*):(?&lt;theta1&gt;[^:]*):(?&lt;z1&gt;[^:]*):(?&lt;a1&gt;[^:]*))?(?&lt;Two&gt;:Two:(?&lt;r2&gt;[^:]*):(?&lt;theta2&gt;[^:]*):(?&lt;z2&gt;[^:]*):(?&lt;a2&gt;[^:]*))?(?&lt;Three&gt;:Three:(?&lt;r3&gt;[^:]*):(?&lt;theta3&gt;[^:]*):(?&lt;z3&gt;[^:]*):(?&lt;a3&gt;[^:]*))?(?&lt;Four&gt;:Four:(?&lt;r4&gt;[^:]*):(?&lt;theta4&gt;[^:]*):(?&lt;z4&gt;[^:]*):(?&lt;a4&gt;[^:]*))?$">
<Actions>
<Action OrderNumber="1" TriggerOp="CancelTrigger" TriggerId="1797a53f-32e1-41d0-a594-f50c7f3e5f8b" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="2" TriggerOp="CancelTrigger" TriggerId="717d5d8c-d723-4726-8a87-3ce0bab8b66f" ActionType="Trigger" Asynchronous="False" />
<Action OrderNumber="3" VariableOp="SetNumeric" VariableName="AdvWm_dθ" VariableExpression="(${theta} ?? -pi) + pi" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="4" VariableOp="SetNumeric" VariableName="AdvWm_x0" VariableExpression="${x0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" VariableOp="SetNumeric" VariableName="AdvWm_y0" VariableExpression="${y0} ?? 100" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="6" VariableOp="SetNumeric" VariableName="AdvWm_z0" VariableExpression="(${z0})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="7" VariableOp="SetNumeric" VariableName="AdvWm_r_A" VariableExpression="(${ra})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="8" VariableOp="SetNumeric" VariableName="AdvWm_θ_A" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetaa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="9" VariableOp="SetNumeric" VariableName="AdvWm_z_A" VariableExpression="(${za})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="10" VariableOp="SetNumeric" VariableName="AdvWm_a_A" VariableExpression="(${aa})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="11" VariableOp="SetNumeric" VariableName="AdvWm_r_B" VariableExpression="(${rb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="12" VariableOp="SetNumeric" VariableName="AdvWm_θ_B" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="13" VariableOp="SetNumeric" VariableName="AdvWm_z_B" VariableExpression="(${zb})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="14" VariableOp="SetNumeric" VariableName="AdvWm_a_B" VariableExpression="(${ab})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="15" VariableOp="SetNumeric" VariableName="AdvWm_r_C" VariableExpression="(${rc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="16" VariableOp="SetNumeric" VariableName="AdvWm_θ_C" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="17" VariableOp="SetNumeric" VariableName="AdvWm_z_C" VariableExpression="(${zc})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="18" VariableOp="SetNumeric" VariableName="AdvWm_a_C" VariableExpression="(${ac})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="19" VariableOp="SetNumeric" VariableName="AdvWm_r_D" VariableExpression="(${rd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="20" VariableOp="SetNumeric" VariableName="AdvWm_θ_D" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${thetad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="21" VariableOp="SetNumeric" VariableName="AdvWm_z_D" VariableExpression="(${zd})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="22" VariableOp="SetNumeric" VariableName="AdvWm_a_D" VariableExpression="(${ad})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="23" VariableOp="SetNumeric" VariableName="AdvWm_r_One" VariableExpression="(${r1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="24" VariableOp="SetNumeric" VariableName="AdvWm_θ_One" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="25" VariableOp="SetNumeric" VariableName="AdvWm_z_One" VariableExpression="(${z1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="26" VariableOp="SetNumeric" VariableName="AdvWm_a_One" VariableExpression="(${a1})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="27" VariableOp="SetNumeric" VariableName="AdvWm_r_Two" VariableExpression="(${r2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="28" VariableOp="SetNumeric" VariableName="AdvWm_θ_Two" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="29" VariableOp="SetNumeric" VariableName="AdvWm_z_Two" VariableExpression="(${z2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="30" VariableOp="SetNumeric" VariableName="AdvWm_a_Two" VariableExpression="(${a2})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="31" VariableOp="SetNumeric" VariableName="AdvWm_r_Three" VariableExpression="(${r3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="32" VariableOp="SetNumeric" VariableName="AdvWm_θ_Three" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="33" VariableOp="SetNumeric" VariableName="AdvWm_z_Three" VariableExpression="(${z3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="34" VariableOp="SetNumeric" VariableName="AdvWm_a_Three" VariableExpression="(${a3})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="35" VariableOp="SetNumeric" VariableName="AdvWm_r_Four" VariableExpression="(${r4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="36" VariableOp="SetNumeric" VariableName="AdvWm_θ_Four" VariableExpression="((${type} == Deg) ? pi/180 : 1) * (${theta4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="37" VariableOp="SetNumeric" VariableName="AdvWm_z_Four" VariableExpression="(${z4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="38" VariableOp="SetNumeric" VariableName="AdvWm_a_Four" VariableExpression="(${a4})" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="39" Enabled="False" ActionType="Placeholder" Description="加权计算坐标   转换为 JSON 格式" DescriptionOverride="True" />
<Action OrderNumber="40" ListVariableOp="Build" ListVariableExpression=",A,B,C,D,One,Two,Three,Four" ListVariableTarget="AdvWm_polar" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="41" ListVariableOp="Filter" ListVariableExpressionType="Numeric" ListVariableName="AdvWm_polar" ListVariableExpression="${f:length:${${_this}}} != 0" ListVariableTarget="AdvWm_polar" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="42" ListVariableOp="SetAll" ListVariableName="AdvWm_polar" ListVariableExpression="&quot;${_this}&quot;: {&#xD;&#xA;    &quot;X&quot;: ${n: ${v:AdvWm_x0} + (${scale} ?? 1) * ${v:AdvWm_r_${_this}} * sin(${v:AdvWm_θ_${_this}} + ${v:AdvWm_dθ}) }, &#xD;&#xA;    &quot;Y&quot;: ${n: ${v:AdvWm_z0} + (${scale} ?? 1) * ${v:AdvWm_z_${_this}} }, &#xD;&#xA;    &quot;Z&quot;: ${n: ${v:AdvWm_y0} + (${scale} ?? 1) * ${v:AdvWm_r_${_this}} * cos(${v:AdvWm_θ_${_this}} + ${v:AdvWm_dθ}) }, &#xD;&#xA;    &quot;Active&quot;: ${v:AdvWm_a_${_this}}&#xD;&#xA;}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="43" Enabled="False" ActionType="Placeholder" Description="输出" DescriptionOverride="True" />
<Action OrderNumber="44" VariableOp="SetString" VariableName="AdvWm_json" VariableExpression="{&#xD;&#xA;${l:AdvWm_polar.join(&quot;,⏎&quot;)}&#xD;&#xA;}" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="45" VariableOp="Clipboard" VariableName="AdvWm_json" Enabled="False" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="46" NamedCallbackName="place" NamedCallbackParam="${v:AdvWm_json}" VariableOp="SetString" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="47" VariableOp="UnsetRegexUniversal" VariableName="^AdvWm" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="b6882dcf-ff88-4cc9-ad3a-6455d0f6984b" Name="实体标点" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="清空标点（网络） networkClear" Id="51703cef-956b-4b54-9499-66bdd7e1c2a3" RegularExpression="^AdvHm_networkClear:(?&lt;orders&gt;[1-8]+)">
<Actions>
<Action OrderNumber="1" ListVariableOp="SetAll" ListVariableName="AdvHm_clearAll" ListVariableExpression="    { &quot;c&quot;: &quot;command&quot;, &quot;p&quot;: &quot;/mk clear &lt;${f:slice(${_idx}):0${orders}}&gt;&quot; }" ListVariableIndex="${f:length:${orders}}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="AdvHm_clearAll" VariableExpression="[&#xD;&#xA;${l:AdvHm_clearAll.join(&quot;,⏎&quot;)}&#xD;&#xA;]" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="3" NamedCallbackName="queue" NamedCallbackParam="${v:AdvHm_clearAll}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="AdvHm_clearAll" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" ListVariableName="AdvHm_clearAll" ActionType="ListVariable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="清空标点（本地） localClear" Id="d05f41b8-ae95-401f-ba38-440001fc2472" RegularExpression="^AdvHm_localClear:(?!all$)(?&lt;listname&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" ListVariableOp="SetAll" ListVariableName="AdvHm_clearAll" ListVariableExpression="    {&#xD;&#xA;        &quot;c&quot;: &quot;mark&quot;,&#xD;&#xA;        &quot;p&quot;: &quot;{\&quot;Name\&quot;: \&quot;${l:${listname}[${_idx}]}\&quot;, \&quot;MarkType\&quot;: \&quot;0\&quot;, \&quot;LocalOnly\&quot;: 1}&quot;&#xD;&#xA;    }" ListVariableIndex="${l:${listname}.size}" ActionType="ListVariable" Asynchronous="False" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="AdvHm_clearAll" VariableExpression="[&#xD;&#xA;${l:AdvHm_clearAll.join(&quot;,⏎&quot;)}&#xD;&#xA;]" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="3" NamedCallbackName="queue" NamedCallbackParam="${v:AdvHm_clearAll}" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="4" VariableName="AdvHm_clearAll" ActionType="Variable" Asynchronous="False" />
<Action OrderNumber="5" ListVariableName="AdvHm_clearAll" ActionType="ListVariable" Asynchronous="False" />
</Actions>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="清空全部标点（本地） localClear:all" Id="18416d14-9652-4847-8975-cf1f01c0b5a1" RegularExpression="^AdvHm_localClear:all(?::id:(?&lt;id&gt;.+))?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Description="指定一个实体 ID，对其遍历执行所有标点后清除标点。ID 未提供时默认为自己。" DescriptionOverride="True" />
<Action OrderNumber="2" VariableOp="SetString" VariableName="tmp_id" VariableExpression="0x${_me.id}" ActionType="Variable">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${id}" ExpressionTypeL="String" ExpressionR="[14]0.{6}" ExpressionTypeR="String" ConditionType="RegexNotMatch" />
</Condition>
</Action>
<Action OrderNumber="3" VariableOp="SetString" VariableName="tmp_id" VariableExpression="0x${id}" ActionType="Variable">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${id}" ExpressionTypeL="String" ExpressionR="[14]0.{6}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
<Action OrderNumber="4" LoopInitExpression="32" LoopIncrExpression="-1" ActionType="Loop">
<LoopCondition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${_i}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="NumericGreaterEqual" />
</LoopCondition>
<LoopActions>
<Action OrderNumber="1" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;    &quot;ActorID&quot;: ${v:tmp_id},&#xD;&#xA;    &quot;MarkType&quot;: ${_i},&#xD;&#xA;    &quot;LocalOnly&quot;: true&#xD;&#xA;}" ActionType="NamedCallback" />
</LoopActions>
</Action>
<Action OrderNumber="5" VariableName="tmp_id" ActionType="Variable">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${id}" ExpressionTypeL="String" ExpressionR="[14]0.{6}" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
</Actions>
</Trigger>
<Trigger Enabled="true" Name="单个实体标点 mark" Id="14c0827d-2534-48ca-828d-5b7b42304e86" RegularExpression="^AdvHm_mark:(?&lt;entity&gt;[^:]+):(?&lt;marker&gt;[^:]+):(?&lt;isLocal&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" VariableOp="SetNumeric" VariableName="tmp_match" VariableExpression="1" ActionType="Variable" Asynchronous="False">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${entity}" ExpressionTypeL="String" ExpressionR="^[14]0[A-F0-9].{6}$" ExpressionTypeR="String" ConditionType="RegexMatch" />
</Condition>
</Action>
<Action OrderNumber="2" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;  &quot;ActorID&quot;: 0x${entity},&#xD;&#xA;  &quot;MarkType&quot;: &quot;${marker}&quot;,&#xD;&#xA;  &quot;LocalOnly&quot;: ${isLocal} &#xD;&#xA;}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_match}" ExpressionTypeL="Numeric" ExpressionR="1" ExpressionTypeR="Numeric" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="3" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;  &quot;Name&quot;: &quot;${entity}&quot;,&#xD;&#xA;  &quot;MarkType&quot;: &quot;${marker}&quot;,&#xD;&#xA;  &quot;LocalOnly&quot;: ${isLocal} &#xD;&#xA;}" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${v:tmp_match}" ExpressionTypeL="Numeric" ExpressionR="0" ExpressionTypeR="Numeric" ConditionType="NumericEqual" />
</Condition>
</Action>
<Action OrderNumber="4" NamedCallbackName="mark" NamedCallbackParam="{&#xD;&#xA;  ${f:ifmatch(${entity}, '&quot;ActorID&quot;: 0x${entity}', '&quot;Name&quot;: &quot;${entity}&quot;'):[14]0[0-9A-F]｛6｝},&#xD;&#xA;  &quot;MarkType&quot;: &quot;${marker}&quot;,&#xD;&#xA;  &quot;LocalOnly&quot;: ${isLocal} &#xD;&#xA;}" ActionType="NamedCallback" />
<Action OrderNumber="5" VariableName="tmp_match" ActionType="Variable" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers />
</Folder>
<Folder Id="1cdd33b6-860d-4997-8e0a-aa9ed55fecd9" Name="2. 新版本 v4.7" Enabled="true" RawEnvironmentVariables="version = 4.7">
<Folders>
<Folder Id="b7183948-e655-468b-93aa-e5904c51c20b" Name="WaymarkEncoder" Enabled="true">
<Folders>
<Folder Id="fdecf75b-43b3-43d2-b506-64324dc650c1" Name="user" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Sequential="True" Name="2. 应答 + 播报" Id="48910e13-c80c-4f9b-a0bc-33e386c8ac2b" RegularExpression="^.{15}\S+ 1C:Add:0:.{8}:[^:]*:(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="Action: Answer" ActionType="NamedCallback" />
<Action OrderNumber="2" NamedCallbackName="AdvWm" NamedCallbackParam="Action: GetUsers" ActionType="NamedCallback" ExecutionDelayExpression="2000" />
<Action OrderNumber="3" ListVariableName="AdvWm_users" ActionType="ListVariable" />
<Action OrderNumber="4" NamedCallbackName="AdvWm" NamedCallbackParam="A: ${v:AdvWm_A}&#xD;&#xA;public: true" ActionType="NamedCallback">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ev:AdvWm_A}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="5" VariableName="AdvWm_A" ActionType="Variable" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="abs(${z})" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="3. 接收" Id="311f3835-2184-4b1a-b8a0-71bb404a4a0f" RegularExpression="^.{15}\S+ 1C:Add:0:.{8}:[^:]*:(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+):(?&lt;z&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" ListVariableOp="Push" ListVariableName="AdvWm_users" ListVariableExpression="${f:dec2hex8:${n: (round(${x} * 100) - 8000) * 0x1000 + (round(${y} * 100) - 8000) + 0x10000000}}, ${n: round(${z}, 2)}" ActionType="ListVariable" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="abs(${z})" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="abs(${z})" ExpressionTypeL="Numeric" ExpressionR="0.14" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="1. 询问" Id="4c0e265f-171b-42db-9d05-d0f0c0335d48" RegularExpression="^.{15}\S+ 00:0038::(?&lt;user&gt;[!?！？]user)$">
<Actions>
<Action OrderNumber="1" TriggerOp="EnableTrigger" TriggerId="48910e13-c80c-4f9b-a0bc-33e386c8ac2b" ActionType="Trigger" Description="? 是匿名" DescriptionOverride="True" />
<Action OrderNumber="2" TriggerOp="EnableTrigger" TriggerId="311f3835-2184-4b1a-b8a0-71bb404a4a0f" ActionType="Trigger" Description="! 是实名" DescriptionOverride="True" />
<Action OrderNumber="3" VariableOp="SetString" VariableName="AdvWm_A" VariableExpression="${if: ${_wm[A].active} ? ${_wm[A].pos} : clear}" ActionType="Variable" />
<Action OrderNumber="4" NamedCallbackName="AdvWm" NamedCallbackParam="Action: ${if: ${f:startwith(?):${f:tohalfwidth:${user}}} ? AskAnonymous : Ask }" ActionType="NamedCallback" />
</Actions>
</Trigger>
</Triggers>
</Folder>
<Folder Id="ba765f3e-d2ee-4a1d-b91b-8380ff917f40" Name="tell" Enabled="true">
<Folders />
<Triggers>
<Trigger Enabled="true" Name="2. 接收" Id="e0920ff6-4d3f-4c30-b57d-abecdd386c99" RegularExpression="^.{15}\S+ 1C:Add:0:(?&lt;id&gt;.{8}):(?&lt;name&gt;[^:]*):(?&lt;x&gt;[^:]+):(?&lt;y&gt;[^:]+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="Action: Decode&#xD;&#xA;Sender: ${name} (${_entity[${id}].jobEN3})" ActionType="NamedCallback" ExecutionDelayExpression="500" />
</Actions>
<Condition Enabled="true" Grouping="And">
<ConditionSingle Enabled="true" ExpressionL="${x}" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
<ConditionSingle Enabled="true" ExpressionL="${y}" ExpressionTypeL="Numeric" ExpressionR="0xff14 / 1000" ExpressionTypeR="Numeric" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Name="1. 发送" Id="4044efd8-daab-40a9-a236-c9bbd34df28e" RegularExpression="^.{15}\S+ 00:0038::(?&lt;tell&gt;[!?！？]tell) (?&lt;msg&gt;.+)">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="Action: ${if: ${f:startwith(?):${f:tohalfwidth:${tell}}} ? EncodeAnonymous : Encode }&#xD;&#xA;Data: ${msg}" ActionType="NamedCallback" />
<Action OrderNumber="2" Asynchronous="False" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers />
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="true" Name="版本" Id="12ea2db7-467f-4217-9519-4158c3e2cf21" RegularExpression="^AdvWm_getVersion">
<Actions>
<Action OrderNumber="1" ListVariableOp="Push" ListVariableName="AdvWm_version" ListVariableExpression="${env:version}" ActionType="ListVariable" />
</Actions>
</Trigger>
<Trigger Enabled="false" Name="导入提示" Id="ee433595-a947-4524-83f6-6c0f96b82ef4" RegularExpression="^." PrevActionsRefire="Deny" PeriodRefire="Deny" RefirePeriodExpression="30000">
<Actions>
<Action OrderNumber="1" MessageBoxIconType="Information" MessageBoxText="高级标点工具箱已更新 v${env:version}。&#xD;&#xA;如果你有本地版本，请删除本地版本，以免冲突。&#xD;&#xA;如果你是开发者，可以查看使用说明中的新功能介绍。&#xD;&#xA;&#xD;&#xA;本条消息只会提示一次。" ActionType="MessageBox" />
<Action OrderNumber="2" TriggerOp="DisableTrigger" TriggerId="ee433595-a947-4524-83f6-6c0f96b82ef4" ActionType="Trigger" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="手动标点： /e pl/place A/B/C/D/1/2/3/4 (x) (y) (z)" Id="211c6dea-7c20-4408-8c81-41ad2d73d708" RegularExpression="^.{15}\S+ 00:0038:: *[Pp][Ll]([Aa][Cc][Ee])? +(?&lt;wm&gt;[A-Da-d1-4])(?&lt;x&gt; +[^ ]+)?(?&lt;y&gt; +[^ ]+)?(?&lt;z&gt; +[^ ]+)? *$">
<Actions>
<Action OrderNumber="1" NamedCallbackName="AdvWm" NamedCallbackParam="action: place&#xD;&#xA;${wm}: (${x} ?? ${_me.x}), (${y} ?? ${_me.y}), (${z} ?? ${_me.z})" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="1. 注册回调" Id="0b9aac06-e1c6-4dab-a1f8-7d62bf2fc661" RegularExpression="^.{15}\S+ 01:">
<Actions>
<Action OrderNumber="1" ExecScriptExpression="using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Collections.Generic;&#xD;&#xA;using System.Linq;&#xD;&#xA;using System.Text;&#xD;&#xA;using System.Text.RegularExpressions;&#xD;&#xA;using Triggernometry;&#xD;&#xA;using static System.Math;&#xD;&#xA;using Triggernometry.PluginBridges;&#xD;&#xA;using System.Windows.Forms;&#xD;&#xA;&#xD;&#xA;public struct Info&#xD;&#xA;{&#xD;&#xA;    public const string Name = &quot;AdvWm&quot;;&#xD;&#xA;    public const string NameCN = &quot;高级标点工具箱&quot;;&#xD;&#xA;    public const string Version = &quot;${env:version}&quot;;&#xD;&#xA;    public const string Author = &quot;阿洛 MnFeN&quot;;&#xD;&#xA;&#xD;&#xA;    public static string InitInfo =&gt; $&quot;{Name}：{NameCN} v{Version} by {Author} 已成功初始化。&quot;;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;RealPlugin.plug.RegisterNamedCallback(&quot;AdvWm&quot;, new Action&lt;object, string&gt;(AdvWm.NamedCallback), null, registrant: $&quot;{Info.NameCN} v{Info.Version}&quot;);&#xD;&#xA;RealPlugin.plug.InvokeNamedCallback(&quot;NamazuLog&quot;, Info.InitInfo);&#xD;&#xA;Interpreter.StaticHelpers.Log(RealPlugin.DebugLevelEnum.Custom, Info.InitInfo);&#xD;&#xA;&#xD;&#xA;public class AdvWm&#xD;&#xA;{&#xD;&#xA;    string _command;&#xD;&#xA;    /// &lt;summary&gt; All keys are in lowercase. &lt;/summary&gt;&#xD;&#xA;    Dictionary&lt;string, string&gt; _argsDict;&#xD;&#xA;    string _action = &quot;&quot;;&#xD;&#xA;    bool _log = true;&#xD;&#xA;    bool _local = true;&#xD;&#xA;&#xD;&#xA;    public AdvWm(string command)&#xD;&#xA;    {&#xD;&#xA;        _command = command;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Log(string message) =&gt; RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e {message}&quot;);&#xD;&#xA;&#xD;&#xA;    public static void NamedCallback(object _, string input)&#xD;&#xA;    {&#xD;&#xA;        var commands = input.Split(new string[] { &quot;---&quot; }, StringSplitOptions.None);&#xD;&#xA;        foreach (var command in commands)&#xD;&#xA;        {&#xD;&#xA;            new AdvWm(command).Execute();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static readonly HashSet&lt;string&gt; postNamazuWaymarkKeywords = new HashSet&lt;string&gt; {&#xD;&#xA;        &quot;save&quot;, &quot;backup&quot;, &quot;load&quot;, &quot;restore&quot;, &quot;reset&quot;, &quot;clear&quot;, &quot;public&quot;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private void Execute()&#xD;&#xA;    {&#xD;&#xA;        string simpleCmd = _command.ToLower().Trim();&#xD;&#xA;        if (postNamazuWaymarkKeywords.Contains(simpleCmd))&#xD;&#xA;        {&#xD;&#xA;            RealPlugin.plug.InvokeNamedCallback(&quot;place&quot;, simpleCmd);&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        _argsDict = _command.Split('\n')&#xD;&#xA;            .Where(line =&gt; line.Contains(&quot;:&quot;) &amp;&amp; !line.StartsWith(&quot;//&quot;))&#xD;&#xA;            .ToDictionary(&#xD;&#xA;                line =&gt; line.Substring(0, line.IndexOf(':')).Trim().ToLower(),&#xD;&#xA;                line =&gt; line.Substring(line.IndexOf(':') + 1).Trim()&#xD;&#xA;            );&#xD;&#xA;&#xD;&#xA;        // 解析共通参数&#xD;&#xA;        TryGetArg(&quot;Action&quot;, out _action);&#xD;&#xA;        _log = !TryGetArg(&quot;Log&quot;, out string log) || bool.Parse(log.ToLower());&#xD;&#xA;        _local = !TryGetArg(&quot;Local&quot;, &quot;LocalOnly&quot;, out string local) || bool.Parse(local.ToLower());&#xD;&#xA;&#xD;&#xA;        Waymarks waymarks;&#xD;&#xA;        switch (_action?.ToLower() ?? &quot;&quot;)&#xD;&#xA;        {&#xD;&#xA;            case &quot;getversion&quot;:&#xD;&#xA;                Interpreter.StaticHelpers.SetScalarVariable(isPersistent: false, $&quot;{Info.Name}_version&quot;, Info.Version); return;&#xD;&#xA;            case &quot;encode&quot;:&#xD;&#xA;                WaymarksEncoder.EncodeAndSendWaymarks(GetArg(&quot;data&quot;), false); return;&#xD;&#xA;            case &quot;encodeanonymous&quot;:&#xD;&#xA;                WaymarksEncoder.EncodeAndSendWaymarks(GetArg(&quot;data&quot;), true); return;&#xD;&#xA;            case &quot;decode&quot;:&#xD;&#xA;                string sender = GetArg(&quot;sender&quot;);&#xD;&#xA;                WaymarksEncoder.DecodeFromWaymarksAndShow(); return;&#xD;&#xA;            case &quot;ask&quot;:&#xD;&#xA;                WaymarksEncoder.Ask(false); return;&#xD;&#xA;            case &quot;askanonymous&quot;:&#xD;&#xA;                WaymarksEncoder.Ask(true); return;&#xD;&#xA;            case &quot;answer&quot;:&#xD;&#xA;                WaymarksEncoder.Answer(); return;&#xD;&#xA;            case &quot;getusers&quot;:&#xD;&#xA;                WaymarksEncoder.GetUsersResult(); return;&#xD;&#xA;            case &quot;polar&quot;: // 不推荐使用，仅为兼容旧版本，可被 default 模式完全替代&#xD;&#xA;                waymarks = ParseWaymarksPolar(); break;&#xD;&#xA;            case &quot;circle&quot;:&#xD;&#xA;                waymarks = ParseWaymarksCircle(); break;&#xD;&#xA;            case &quot;arc&quot;:&#xD;&#xA;                waymarks = ParseWaymarksArc(); break;&#xD;&#xA;            case &quot;linear&quot;:&#xD;&#xA;            case &quot;connect&quot;:&#xD;&#xA;            case &quot;linearconnect&quot;:&#xD;&#xA;                waymarks = ParseWaymarksLinearConnect(); break;&#xD;&#xA;            // case &quot;absolute&quot;:  case &quot;relative&quot;:  case &quot;place&quot;: 旧版本的指令全部整合为默认的标点模式&#xD;&#xA;            default:&#xD;&#xA;                waymarks = ParseWaymarksDefault(); break;&#xD;&#xA;        }&#xD;&#xA;        // Log($&quot;初始：\n{waymarks}&quot;);&#xD;&#xA;        TryApplyScales(waymarks);&#xD;&#xA;        // Log($&quot;伸缩：\n{waymarks}&quot;);&#xD;&#xA;        TryApplyRotation(waymarks);&#xD;&#xA;        // Log($&quot;旋转：\n{waymarks}&quot;);&#xD;&#xA;        TryApplyCenter(waymarks);&#xD;&#xA;        // Log($&quot;平移：\n{waymarks}&quot;);&#xD;&#xA;        waymarks.LocalOnly = _local;&#xD;&#xA;        waymarks.Log = _log;&#xD;&#xA;        waymarks.Mark();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的所有坐标，生成一组初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksDefault()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        foreach (string name in Waymark.WaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (TryGetArg(name, out string rawCoord))&#xD;&#xA;            {&#xD;&#xA;                waymarks.Add(Waymark.Parse(name, rawCoord));&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的所有极坐标，生成一组初始标点。建议使用 Default 替代。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksPolar()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        foreach (string name in Waymark.WaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (TryGetArg(name, out string rawPolarCoord))&#xD;&#xA;            {   // 已重构为接近正常方法的处理逻辑&#xD;&#xA;                XIVCoord polarCoord = XIVCoord.ParseRawData(rawPolarCoord.StartsWith(&quot;polar &quot;) ? rawPolarCoord : $&quot;polar {rawPolarCoord}&quot;);&#xD;&#xA;                waymarks.Add(new Waymark(name, polarCoord.ToCartesian()));&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的半径和标点名，生成一组排列成圆周的初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksCircle()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        double rCardinal = MathParser.Parse(GetArg(&quot;R&quot;));&#xD;&#xA;        double rIntercard = TryGetArg(&quot;R2&quot;, out string rawR2) ? MathParser.Parse(rawR2) : rCardinal;&#xD;&#xA;        string[] usedWaymarkNames = GetArg(&quot;Waymarks&quot;).Select(c =&gt; char.ToLower(c).ToString()).ToArray(); // 用哪些点 相对正北逆时针 如 A4D3C2B1&#xD;&#xA;        double step = 2 * PI / usedWaymarkNames.Length; // 相邻标点的角度差&#xD;&#xA;        int count = 0;&#xD;&#xA;        foreach (string name in usedWaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (Waymark.WaymarkNames.Contains(name))&#xD;&#xA;            {&#xD;&#xA;                var r = (count &amp; 1) == 0 ? rCardinal : rIntercard;&#xD;&#xA;                var θ = count * step - PI;&#xD;&#xA;                waymarks.Add(new Waymark(name, new PolarCoord(r, θ, 0)));&#xD;&#xA;            }&#xD;&#xA;            count++;&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的半径、标点名、圆心角，生成一组排列成弧线的初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksArc()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        double r = MathParser.Parse(GetArg(&quot;R&quot;));   // 半径&#xD;&#xA;        string[] usedWaymarkNames = GetArg(&quot;Waymarks&quot;).Select(c =&gt; char.ToLower(c).ToString()).ToArray(); // 用哪些点 相对正北逆时针 如 A4D3C2B1&#xD;&#xA;        int stepCount = usedWaymarkNames.Length - 1;&#xD;&#xA;&#xD;&#xA;        // 圆弧的圆心角，不提供的时候默认为使标点紧邻的角度（弧长约 2.6）&#xD;&#xA;        double dθ = TryGetArg(&quot;dθ&quot;, &quot;dTheta&quot;, out string rawdθ) ? MathParser.Parse(rawdθ) : (stepCount &gt;= 1) ? 2.6 / r * stepCount : 0;&#xD;&#xA;        double θStep = (stepCount &gt;= 1) ? dθ / stepCount : 0; // 相邻标点的角度差&#xD;&#xA;        int count = 0;&#xD;&#xA;        foreach (string name in usedWaymarkNames)  // a b c d 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (Waymark.WaymarkNames.Contains(name)) // 允许使用非标点名的字符占位等分点，不会生成标点&#xD;&#xA;            {&#xD;&#xA;                PolarCoord polarCoord = new PolarCoord(r, (count - stepCount / 2.0) * θStep - PI, 0);&#xD;&#xA;                waymarks.Add(new Waymark(name, polarCoord));&#xD;&#xA;            }&#xD;&#xA;            count++;&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 根据提供的起点、终点、标点名，生成线性插值的初始标点。 &lt;/summary&gt;&#xD;&#xA;    private Waymarks ParseWaymarksLinearConnect()&#xD;&#xA;    {&#xD;&#xA;        Waymarks waymarks = new Waymarks();&#xD;&#xA;        string[] usedWaymarkNames = GetArg(&quot;Waymarks&quot;).Select(c =&gt; char.ToLower(c).ToString()).ToArray(); // 用哪些点 起点到终点 如 A4D3C2B1&#xD;&#xA;        if (usedWaymarkNames.Length &lt; 2)&#xD;&#xA;        {&#xD;&#xA;            throw new Exception(&quot;AdvWm: LinearConnect 模式下，提供的标点数量不足 2&quot;);&#xD;&#xA;        }&#xD;&#xA;        XIVCoord startCoord = XIVCoord.ParseRawData(GetArg(&quot;start&quot;));&#xD;&#xA;        XIVCoord endCoord = XIVCoord.ParseRawData(GetArg(&quot;end&quot;));&#xD;&#xA;        XIVCoord vector = endCoord - startCoord;&#xD;&#xA;        double totalDistance = vector.Length;&#xD;&#xA;        // Log($&quot;{vector}&quot;);&#xD;&#xA;        int count = 0;&#xD;&#xA;        foreach (string name in usedWaymarkNames)  // A B C D 1 2 3 4&#xD;&#xA;        {&#xD;&#xA;            if (Waymark.WaymarkNames.Contains(name))&#xD;&#xA;            {&#xD;&#xA;                double percentage = (double)count / (usedWaymarkNames.Length - 1);  // 标点默认等分&#xD;&#xA;                if (TryGetArg(name, out string rawDistance))   // 也可以不等分，自定义标点位置&#xD;&#xA;                {&#xD;&#xA;                    if (rawDistance.EndsWith(&quot; m&quot;))      // 以 A: 5 m 形式提供的距离&#xD;&#xA;                    {&#xD;&#xA;                        // @d 代表总长度，如 A: @d - 5 m 意为终点前 5 m&#xD;&#xA;                        string strTotalDistance = totalDistance.ToString(MathParser.CultureInfo);&#xD;&#xA;                        rawDistance = rawDistance.Replace(&quot;@d&quot;, strTotalDistance);&#xD;&#xA;                        double distance = MathParser.Parse(rawDistance.Substring(0, rawDistance.Length - 2));&#xD;&#xA;                        percentage = distance / totalDistance;&#xD;&#xA;                    }&#xD;&#xA;                    else                                // 以 A: 0.125 形式提供的百分比&#xD;&#xA;                    {&#xD;&#xA;                        percentage = MathParser.Parse(rawDistance);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                XIVCoord coord = startCoord + percentage * vector;&#xD;&#xA;                waymarks.Add(new Waymark(name, coord));&#xD;&#xA;            }&#xD;&#xA;            count++;&#xD;&#xA;        }&#xD;&#xA;        return waymarks;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 如果当前指令提供了任何伸缩，将伸缩变换应用到给定的一组标点坐标。 &lt;/summary&gt;&#xD;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xD;&#xA;    private void TryApplyScales(Waymarks waymarks)&#xD;&#xA;    {&#xD;&#xA;        // 首先尝试解析 Scale 和具体的 ScaleX, ScaleY, ScaleZ 参数&#xD;&#xA;        bool hasScale = TryGetArg(&quot;Scale&quot;, out string rawScale);&#xD;&#xA;        bool hasScaleX = TryGetArg(&quot;ScaleX&quot;, out string rawScaleX);&#xD;&#xA;        bool hasScaleY = TryGetArg(&quot;ScaleY&quot;, out string rawScaleY);&#xD;&#xA;        bool hasScaleZ = TryGetArg(&quot;ScaleZ&quot;, out string rawScaleZ);&#xD;&#xA;&#xD;&#xA;        // 未给定参数则免去解析直接返回&#xD;&#xA;        if (!hasScale &amp;&amp; !hasScaleX &amp;&amp; !hasScaleY &amp;&amp; !hasScaleZ) return;&#xD;&#xA;&#xD;&#xA;        // 如果存在 scale 参数，按照 scaleX ?? scale ?? 1 的优先级解析&#xD;&#xA;        double defaultScale = hasScale ? MathParser.Parse(rawScale) : 1;&#xD;&#xA;&#xD;&#xA;        double scaleX = hasScaleX ? MathParser.Parse(rawScaleX) : defaultScale;&#xD;&#xA;        double scaleY = hasScaleY ? MathParser.Parse(rawScaleY) : defaultScale;&#xD;&#xA;        double scaleZ = hasScaleZ ? MathParser.Parse(rawScaleZ) : defaultScale;&#xD;&#xA;&#xD;&#xA;        // 如果任一缩放倍率不是 1，则缩放&#xD;&#xA;        if (Abs(scaleX - 1) &gt; 1e-5 || Abs(scaleY - 1) &gt; 1e-5 || Abs(scaleZ - 1) &gt; 1e-5)&#xD;&#xA;        {&#xD;&#xA;            foreach (Waymark wm in waymarks)&#xD;&#xA;            {&#xD;&#xA;                wm.Coord = wm.Coord.ScaleBy(scaleX, scaleY, scaleZ);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 如果当前指令提供了旋转，将伸缩变换应用到给定的一组标点坐标。 &lt;/summary&gt;&#xD;&#xA;    /// &lt;returns&gt;&lt;/returns&gt;&#xD;&#xA;    private void TryApplyRotation(Waymarks waymarks)&#xD;&#xA;    {&#xD;&#xA;        if (TryGetArg(&quot;θ&quot;, &quot;Theta&quot;, out string rawθ))&#xD;&#xA;        {&#xD;&#xA;            double θ = MathParser.Parse(rawθ);&#xD;&#xA;            foreach (Waymark wm in waymarks)&#xD;&#xA;            {&#xD;&#xA;                wm.Coord = wm.Coord.RotateTo(θ);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 如果当前指令提供了场地中心，将场地中心应用到给定的一组标点坐标。 &lt;/summary&gt;&#xD;&#xA;    void TryApplyCenter(Waymarks waymarks)&#xD;&#xA;    {&#xD;&#xA;        if (TryGetArg(&quot;O&quot;, &quot;Center&quot;, out string rawCenter))&#xD;&#xA;        {&#xD;&#xA;            XIVCoord centerCoord = XIVCoord.ParseRawData(rawCenter);&#xD;&#xA;            foreach (Waymark wm in waymarks)&#xD;&#xA;            {&#xD;&#xA;                wm.Coord = wm.Coord.MoveTo(centerCoord);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    string GetArg(params string[] keys)&#xD;&#xA;    {&#xD;&#xA;        string key = keys.Select(k =&gt; k.ToLower()).FirstOrDefault(k =&gt; _argsDict.ContainsKey(k))&#xD;&#xA;            ?? throw new ArgumentException($&quot;AdvWm: 未提供指定的必需参数 {string.Join(&quot; / &quot;, keys)}。&quot;);&#xD;&#xA;        return _argsDict[key];&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    bool TryGetArg(string key, out string value)&#xD;&#xA;    {&#xD;&#xA;        key = key.ToLower();&#xD;&#xA;        return _argsDict.TryGetValue(key, out value);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    bool TryGetArg(string key, string alternativeKey, out string value)&#xD;&#xA;    {&#xD;&#xA;        if (TryGetArg(key, out value))&#xD;&#xA;        {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;        return TryGetArg(alternativeKey, out value);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#region XIVCoord&#xD;&#xA;&#xD;&#xA;public abstract class XIVCoord&#xD;&#xA;{&#xD;&#xA;    //public abstract XIVCoord Copy();&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 将初始坐标视为相对坐标。&lt;br/&gt;&#xD;&#xA;    /// 将相对坐标系的正北（θ = ±pi）在平面内旋转至给定方向 &lt;paramref str=&quot;θ&quot;/&gt;。&lt;br/&gt;&lt;br/&gt;&#xD;&#xA;    /// 方向角度 &lt;paramref str=&quot;θ&quot;/&gt; 为游戏内标准，如：&lt;br/&gt;&#xD;&#xA;    /// · 正北（不旋转）= ±pi；&lt;br/&gt;&#xD;&#xA;    /// · 正南（旋转 180 度）= 0；&lt;br/&gt;&#xD;&#xA;    /// · 正东（顺时针旋转 90 度）= pi/2。&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    /// &lt;param str=&quot;theta&quot;&gt;将初始相对坐标系的正北（-pi）旋转到的方向角度。&lt;/param&gt;&#xD;&#xA;    public abstract XIVCoord RotateTo(double θ);&#xD;&#xA;    public abstract XIVCoord MoveTo(double dx, double dy, double dz);&#xD;&#xA;    public XIVCoord MoveTo(XIVCoord center) =&gt; this + center;&#xD;&#xA;    public abstract XIVCoord ScaleBy(double scaleX, double scaleY, double scaleZ);&#xD;&#xA;    public abstract CartesianCoord ToCartesian();&#xD;&#xA;    public abstract PolarCoord ToPolar();&#xD;&#xA;    public abstract double Length { get; }&#xD;&#xA;    public abstract string Jsonify();&#xD;&#xA;    public abstract override string ToString();&#xD;&#xA;&#xD;&#xA;    public static CartesianCoord operator +(XIVCoord a, XIVCoord b)&#xD;&#xA;    {&#xD;&#xA;        CartesianCoord cartesianA = a.ToCartesian();&#xD;&#xA;        CartesianCoord cartesianB = b.ToCartesian();&#xD;&#xA;&#xD;&#xA;        return new CartesianCoord(&#xD;&#xA;            cartesianA.X + cartesianB.X,&#xD;&#xA;            cartesianA.Y + cartesianB.Y,&#xD;&#xA;            cartesianA.Z + cartesianB.Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static CartesianCoord operator -(XIVCoord a, XIVCoord b)&#xD;&#xA;    {&#xD;&#xA;        CartesianCoord cartesianA = a.ToCartesian();&#xD;&#xA;        CartesianCoord cartesianB = b.ToCartesian();&#xD;&#xA;&#xD;&#xA;        return new CartesianCoord(&#xD;&#xA;            cartesianA.X - cartesianB.X,&#xD;&#xA;            cartesianA.Y - cartesianB.Y,&#xD;&#xA;            cartesianA.Z - cartesianB.Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator -(XIVCoord a)&#xD;&#xA;    {&#xD;&#xA;        if (a is CartesianCoord cartesianA)&#xD;&#xA;        {&#xD;&#xA;            return new CartesianCoord(-cartesianA.X, -cartesianA.Y, -cartesianA.Z);&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            PolarCoord polarA = (PolarCoord)a;&#xD;&#xA;            return new PolarCoord(polarA.R, polarA.θ + PI, polarA.Z);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator *(XIVCoord a, double n)&#xD;&#xA;    {&#xD;&#xA;        if (a is CartesianCoord cartesianA)&#xD;&#xA;        {&#xD;&#xA;            return new CartesianCoord(cartesianA.X * n, cartesianA.Y * n, cartesianA.Z * n);&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            PolarCoord polarA = (PolarCoord)a;&#xD;&#xA;            return new PolarCoord(polarA.R * n, polarA.θ, polarA.Z);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator *(double n, XIVCoord a) =&gt; a * n;&#xD;&#xA;&#xD;&#xA;    public static XIVCoord operator /(XIVCoord a, double n) =&gt; a * (1.0 / n);&#xD;&#xA;&#xD;&#xA;    private static Regex rexOpKeywords = new Regex(@&quot;\b(plus|minus|polar|minuspolar)\b&quot;, RegexOptions.IgnoreCase | RegexOptions.Compiled);&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 将一串直角坐标、极坐标、或混合方式指定的坐标解析并叠加，如：&lt;br /&gt;&lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;: 10, -10, 0 &lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;: &lt;paramref str=&quot;polar&quot;/&gt; 20, -45°, 0&lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;: 10, -10, 0 &lt;paramref str=&quot;polar&quot;/&gt; 20, -45°（在直角坐标基础上叠加极坐标结果）&lt;br /&gt;&lt;br /&gt;&#xD;&#xA;    /// 字符串格式详见 &lt;paramref str=&quot;rawCoords&quot;/&gt;。&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    /// &lt;param str=&quot;rawCoords&quot;&gt;&#xD;&#xA;    /// 一串坐标字符串，可包含多组坐标。&lt;br /&gt;&#xD;&#xA;    /// 每组坐标之间以关键字连接，坐标分量之间以逗号连接。如：&lt;br /&gt;&lt;br /&gt;&#xD;&#xA;    /// &lt;paramref str=&quot;A&quot;/&gt;:     x, y, z  &#xD;&#xA;    /// &lt;paramref str=&quot;plus&quot;/&gt;   x2, y2  &#xD;&#xA;    /// &lt;paramref str=&quot;minus&quot;/&gt;  x3, y3, z3  &#xD;&#xA;    /// &lt;paramref str=&quot;polar&quot;/&gt;  r1, θ1&#xD;&#xA;    /// &lt;paramref str=&quot;minuspolar&quot;/&gt; r2, θ2, z2&lt;br /&gt;&#xD;&#xA;    /// &lt;/param&gt;&#xD;&#xA;    public static XIVCoord ParseRawData(string rawCoords)&#xD;&#xA;    {&#xD;&#xA;        // 例：x, y, z plus x2, y2 minus x3, y3, z3 polar r1, θ1 minuspolar r2, θ2, z2&#xD;&#xA;&#xD;&#xA;        List&lt;string&gt; parts = new List&lt;string&gt;();&#xD;&#xA;        string currentPart = &quot;&quot;;&#xD;&#xA;        int depth = 0;&#xD;&#xA;        foreach (char c in rawCoords)&#xD;&#xA;        {&#xD;&#xA;            switch (c)&#xD;&#xA;            {&#xD;&#xA;                case ',':&#xD;&#xA;                    if (depth == 0)&#xD;&#xA;                    {&#xD;&#xA;                        parts.Add(currentPart);&#xD;&#xA;                        currentPart = &quot;&quot;;&#xD;&#xA;                        continue;&#xD;&#xA;                    }&#xD;&#xA;                    break;&#xD;&#xA;                case '(': depth++; break;&#xD;&#xA;                case ')': depth--; break;&#xD;&#xA;            }&#xD;&#xA;            currentPart += c;&#xD;&#xA;        }&#xD;&#xA;        parts.Add(currentPart);&#xD;&#xA;&#xD;&#xA;        if (depth != 0)&#xD;&#xA;        {&#xD;&#xA;            throw new Exception($&quot;AdvWm: 标点参数存在 {Abs(depth)} 个未闭合的{(depth &gt; 0 ? &quot;左&quot; : &quot;右&quot;)}括号。表达式：{rawCoords}&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // 此时：[x] [y] [z plus x2] [y2 minus x3] [y3] [z3 polar r] [θ] [z]&#xD;&#xA;&#xD;&#xA;        List&lt;XIVCoord&gt; coords = new List&lt;XIVCoord&gt;();&#xD;&#xA;        bool isCurrentPolar = false;&#xD;&#xA;        bool isCurrentPlus = true;&#xD;&#xA;        List&lt;string&gt; currentParams = new List&lt;string&gt;();&#xD;&#xA;&#xD;&#xA;        foreach (string part in parts)&#xD;&#xA;        {&#xD;&#xA;            string[] splitParts = rexOpKeywords.Split(part);&#xD;&#xA;&#xD;&#xA;            if (splitParts.Length == 3) // 找到操作符，拆分解析&#xD;&#xA;            {&#xD;&#xA;                string beforeOp = splitParts[0].Trim();&#xD;&#xA;                string operation = splitParts[1].Trim();&#xD;&#xA;                string afterOp = splitParts[2].Trim();&#xD;&#xA;&#xD;&#xA;                // 处理前部分&#xD;&#xA;                if (currentParams.Count != 0 || !string.IsNullOrEmpty(beforeOp)) // 不是形如 &quot;polar ...&quot; 的字符串开始位置&#xD;&#xA;                {&#xD;&#xA;                    currentParams.Add(beforeOp);&#xD;&#xA;                    XIVCoord coord = isCurrentPolar&#xD;&#xA;                        ? (XIVCoord)PolarCoord.Parse(currentParams.ToArray())&#xD;&#xA;                        : (XIVCoord)CartesianCoord.Parse(currentParams.ToArray());&#xD;&#xA;                    coords.Add(isCurrentPlus ? coord : -coord);&#xD;&#xA;                    currentParams.Clear();&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                // 处理操作符：是否是加法/极坐标操作&#xD;&#xA;                isCurrentPlus = !operation.StartsWith(&quot;minus&quot;);&#xD;&#xA;                isCurrentPolar = operation.EndsWith(&quot;polar&quot;);&#xD;&#xA;&#xD;&#xA;                // 处理后部分&#xD;&#xA;                currentParams.Add(afterOp);&#xD;&#xA;            }&#xD;&#xA;            else if (splitParts.Length == 1) // 未找到操作符，直接添加&#xD;&#xA;            {&#xD;&#xA;                currentParams.Add(splitParts[0].Trim());&#xD;&#xA;            }&#xD;&#xA;            else // 偷个懒，坐标最少两个参数，而只要有两个就会被逗号预先拆分，所以正常不会出现 1 3 以外的情况&#xD;&#xA;            {&#xD;&#xA;                throw new Exception($&quot;AdvWm: 标点参数解析时，关键字之间参数过少。\n表达式：{rawCoords}；\n出错位置：{part}&quot;);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        XIVCoord finalCoord = isCurrentPolar&#xD;&#xA;            ? (XIVCoord)PolarCoord.Parse(currentParams.ToArray())&#xD;&#xA;            : (XIVCoord)CartesianCoord.Parse(currentParams.ToArray());&#xD;&#xA;        coords.Add(isCurrentPlus ? finalCoord : -finalCoord);&#xD;&#xA;&#xD;&#xA;        // 此时：[Cartesian1] [Cartesian2] [Cartesian3] [Polar1]&#xD;&#xA;        return coords.Aggregate((c1, c2) =&gt; c1 + c2);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class CartesianCoord : XIVCoord&#xD;&#xA;{&#xD;&#xA;    public double X;&#xD;&#xA;    public double Y;&#xD;&#xA;    public double Z;&#xD;&#xA;&#xD;&#xA;    public string X_3 =&gt; X.ToString(&quot;0.###&quot;, System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;    public string Y_3 =&gt; Y.ToString(&quot;0.###&quot;, System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;    public string Z_3 =&gt; Z.ToString(&quot;0.###&quot;, System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;&#xD;&#xA;    public CartesianCoord(double x, double y, double z)&#xD;&#xA;    {&#xD;&#xA;        X = x; Y = y; Z = z;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord RotateTo(double θ)&#xD;&#xA;    {&#xD;&#xA;        var sin = Sin(θ);&#xD;&#xA;        var cos = Cos(θ);&#xD;&#xA;        (X, Y) = (-X * cos - Y * sin, X * sin - Y * cos);&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord MoveTo(double dx, double dy, double dz)&#xD;&#xA;    {&#xD;&#xA;        X += dx;&#xD;&#xA;        Y += dy;&#xD;&#xA;        Z += dz;&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord ScaleBy(double scaleX, double scaleY, double scaleZ)&#xD;&#xA;    {&#xD;&#xA;        X *= scaleX;&#xD;&#xA;        Y *= scaleY;&#xD;&#xA;        Z *= scaleZ;&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override CartesianCoord ToCartesian() =&gt; new CartesianCoord(X, Y, Z);&#xD;&#xA;&#xD;&#xA;    public override PolarCoord ToPolar()&#xD;&#xA;    {&#xD;&#xA;        double r = Sqrt(X * X + Y * Y);&#xD;&#xA;        double θ = Atan2(X, Y);&#xD;&#xA;        return new PolarCoord(r, θ, Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override double Length =&gt; Sqrt(X * X + Y * Y + Z * Z);&#xD;&#xA;&#xD;&#xA;    public override string ToString() =&gt; $&quot;({X_3}, {Y_3}, {Z_3})&quot;;&#xD;&#xA;&#xD;&#xA;    public override string Jsonify() =&gt; $&quot;\&quot;X\&quot;: {X_3}, \&quot;Z\&quot;: {Y_3}, \&quot;Y\&quot;: {Z_3}, \&quot;Active\&quot;: true&quot;;&#xD;&#xA;&#xD;&#xA;    public static CartesianCoord Parse(params string[] coords)&#xD;&#xA;    {&#xD;&#xA;        switch (coords.Length)&#xD;&#xA;        {&#xD;&#xA;            case 2:&#xD;&#xA;                return ParseCoordsString(coords[0], coords[1]);&#xD;&#xA;            case 3:&#xD;&#xA;                return ParseCoordsString(coords[0], coords[1], coords[2]);&#xD;&#xA;            default:&#xD;&#xA;                throw Context.ArgCountError(&quot;CartesianCoord: 坐标构造函数&quot;, &quot;2-3&quot;, coords.Length, &quot;[&quot; + string.Join(&quot;], [&quot;, coords) + &quot;]&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static CartesianCoord ParseCoordsString(string rawX, string rawY, string rawZ = null)&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            return new CartesianCoord(&#xD;&#xA;                MathParser.Parse(rawX),&#xD;&#xA;                MathParser.Parse(rawY),&#xD;&#xA;                rawZ == null ? 0 : MathParser.Parse(rawZ));&#xD;&#xA;        }&#xD;&#xA;        catch (Exception ex)&#xD;&#xA;        {&#xD;&#xA;            throw new ArgumentException($&quot;AdvWm: 直角坐标解析错误：{ex.Message}\n&quot; +&#xD;&#xA;                $&quot;原始数据：\nx = ({rawX}), \ny = ({rawY}), \nz = ({rawZ ?? &quot;null&quot;})&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public class PolarCoord : XIVCoord&#xD;&#xA;{&#xD;&#xA;    public double R;&#xD;&#xA;    public double θ;&#xD;&#xA;    public double Z;&#xD;&#xA;&#xD;&#xA;    public PolarCoord(double r, double θ, double z)&#xD;&#xA;    {&#xD;&#xA;        R = r; this.θ = θ; Z = z;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord RotateTo(double θ)&#xD;&#xA;    {&#xD;&#xA;        this.θ += θ + PI;&#xD;&#xA;        return this;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override XIVCoord MoveTo(double dx, double dy, double dz)&#xD;&#xA;        =&gt; ToCartesian().MoveTo(dx, dy, dz);&#xD;&#xA;&#xD;&#xA;    public override XIVCoord ScaleBy(double scaleX, double scaleY, double scaleZ)&#xD;&#xA;    {&#xD;&#xA;        if (Abs(scaleX - scaleY) &lt; 1e-5 &amp;&amp; scaleX &gt;= 1e-4)&#xD;&#xA;        {&#xD;&#xA;            R *= scaleX;&#xD;&#xA;            Z *= scaleZ;&#xD;&#xA;            return this;&#xD;&#xA;        }&#xD;&#xA;        else return ToCartesian().ScaleBy(scaleX, scaleY, scaleZ);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override CartesianCoord ToCartesian()&#xD;&#xA;    {&#xD;&#xA;        double x = R * Sin(θ);&#xD;&#xA;        double y = R * Cos(θ);&#xD;&#xA;        return new CartesianCoord(x, y, Z);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override PolarCoord ToPolar() =&gt; new PolarCoord(R, θ, Z);&#xD;&#xA;&#xD;&#xA;    public override double Length =&gt; Sqrt(R * R + Z * Z);&#xD;&#xA;&#xD;&#xA;    public override string ToString() =&gt; $&quot;(R={R}, θ={θ}, Z={Z})&quot;;&#xD;&#xA;&#xD;&#xA;    public override string Jsonify() =&gt; ToCartesian().Jsonify();&#xD;&#xA;&#xD;&#xA;    public static PolarCoord Parse(params string[] coords)&#xD;&#xA;    {&#xD;&#xA;        switch (coords.Length)&#xD;&#xA;        {&#xD;&#xA;            case 2:&#xD;&#xA;                return ParsePolarCoordsString(coords[0], coords[1]);&#xD;&#xA;            case 3:&#xD;&#xA;                return ParsePolarCoordsString(coords[0], coords[1], coords[2]);&#xD;&#xA;            default:&#xD;&#xA;                throw Context.ArgCountError(&quot;AdvWm: 极坐标构造函数&quot;, &quot;2-3&quot;, coords.Length, &quot;[&quot; + string.Join(&quot;], [&quot;, coords) + &quot;]&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static PolarCoord ParsePolarCoordsString(string rawR, string rawθ, string rawZ = null)&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            return new PolarCoord(&#xD;&#xA;                MathParser.Parse(rawR),&#xD;&#xA;                MathParser.Parse(rawθ),&#xD;&#xA;                rawZ == null ? 0 : MathParser.Parse(rawZ));&#xD;&#xA;        }&#xD;&#xA;        catch (Exception ex)&#xD;&#xA;        {&#xD;&#xA;            throw new ArgumentException($&quot;AdvWm: 极坐标解析错误：{ex.Message}\n\n&quot; +&#xD;&#xA;                $&quot;原始数据：\nr = ({rawR}), \nθ = ({rawθ}), \nz = ({rawZ})&quot;);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#endregion XIVCoord&#xD;&#xA;&#xD;&#xA;#region Waymark(s)&#xD;&#xA;&#xD;&#xA;public enum WaymarkType { A, B, C, D, One, Two, Three, Four }&#xD;&#xA;public class Waymark&#xD;&#xA;{&#xD;&#xA;    public WaymarkType Type { get; set; }&#xD;&#xA;    public XIVCoord Coord { get; set; }&#xD;&#xA;    public bool Ignore { get; set; }&#xD;&#xA;    public bool Active { get; set; }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 用于遍历时保证输出顺序&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    public static readonly string[] WaymarkNames = new string[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; };&#xD;&#xA;    public static readonly WaymarkType[] WaymarkTypes = new WaymarkType[]&#xD;&#xA;    {&#xD;&#xA;        WaymarkType.A, WaymarkType.B, WaymarkType.C, WaymarkType.D,&#xD;&#xA;        WaymarkType.One, WaymarkType.Two, WaymarkType.Three, WaymarkType.Four&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt;&#xD;&#xA;    /// 从用户输入的标点类型转化为实际 Type&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    public static readonly Dictionary&lt;string, WaymarkType&gt; TypeMap = Enumerable.Range(0, 8)&#xD;&#xA;        .ToDictionary(i =&gt; WaymarkNames[i], i =&gt; WaymarkTypes[i]);&#xD;&#xA;&#xD;&#xA;    public Waymark(WaymarkType type, XIVCoord coord = null, bool ignore = false)&#xD;&#xA;    {&#xD;&#xA;        Type = type;&#xD;&#xA;        Coord = coord ?? new CartesianCoord(0, 0, 0);&#xD;&#xA;        Active = coord != null;&#xD;&#xA;        Ignore = ignore;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public Waymark(string rawType, XIVCoord coord = null, bool ignore = false)&#xD;&#xA;    {&#xD;&#xA;        if (TypeMap.TryGetValue(rawType, out var mappedType))&#xD;&#xA;        {&#xD;&#xA;            Type = mappedType;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            throw new Exception($&quot;AdvWm: {rawType} 不是合法的标点名之一（A B C D 1 2 3 4）。&quot;);&#xD;&#xA;        }&#xD;&#xA;        Coord = coord ?? new CartesianCoord(0, 0, 0);&#xD;&#xA;        Active = coord != null;&#xD;&#xA;        Ignore = ignore;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static Waymark Parse(string rawType, string rawCoord, bool ignore = false)&#xD;&#xA;    {&#xD;&#xA;        Waymark wm = new Waymark(rawType, null, ignore);&#xD;&#xA;&#xD;&#xA;        switch (rawCoord.Trim().ToLower())&#xD;&#xA;        {&#xD;&#xA;            // 清除标点&#xD;&#xA;            case &quot;clear&quot;:&#xD;&#xA;                wm.Active = false;&#xD;&#xA;                wm.Coord = new CartesianCoord(0, 0, 0);&#xD;&#xA;                break;&#xD;&#xA;            // 变相地“清除”标点  不会有淡入淡出动画&#xD;&#xA;            case &quot;fakeclear&quot;:&#xD;&#xA;                wm.Active = true;&#xD;&#xA;                wm.Coord = new CartesianCoord(0, 0, 1000);&#xD;&#xA;                break;&#xD;&#xA;            default:&#xD;&#xA;                wm.Active = true;&#xD;&#xA;                wm.Coord = XIVCoord.ParseRawData(rawCoord);&#xD;&#xA;                break;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        return wm;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public string Jsonify() // 脚本调用不了 Json 的方法。。？&#xD;&#xA;    {&#xD;&#xA;        if (Ignore)&#xD;&#xA;            return &quot;&quot;;&#xD;&#xA;        if (Active)&#xD;&#xA;            return $&quot;\&quot;{Type}\&quot;: {{ {Coord.Jsonify()}, \&quot;Active\&quot;: true }}&quot;;&#xD;&#xA;        else&#xD;&#xA;            return $&quot;\&quot;{Type}\&quot;: {{}}&quot;;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public override string ToString() =&gt; Jsonify();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public sealed class Waymarks : IEnumerable&lt;Waymark&gt;&#xD;&#xA;{&#xD;&#xA;    private readonly Dictionary&lt;WaymarkType, Waymark&gt; _waymarks;&#xD;&#xA;    public bool Log = true;&#xD;&#xA;    public bool LocalOnly = true;&#xD;&#xA;&#xD;&#xA;    public Waymarks()&#xD;&#xA;    {&#xD;&#xA;        _waymarks = new Dictionary&lt;WaymarkType, Waymark&gt;();&#xD;&#xA;        foreach (var type in Waymark.WaymarkTypes)&#xD;&#xA;        {&#xD;&#xA;            _waymarks[type] = new Waymark(type, ignore: true);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public Waymark this[WaymarkType type]&#xD;&#xA;    {&#xD;&#xA;        get =&gt; _waymarks[type];&#xD;&#xA;        set =&gt; _waymarks[type] = value;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();&#xD;&#xA;    public IEnumerator&lt;Waymark&gt; GetEnumerator()&#xD;&#xA;    {&#xD;&#xA;        foreach (var type in Waymark.WaymarkTypes)&#xD;&#xA;        {&#xD;&#xA;            if (_waymarks.TryGetValue(type, out Waymark waymark))&#xD;&#xA;            {&#xD;&#xA;                yield return waymark;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public void Add(Waymark wm)&#xD;&#xA;    {&#xD;&#xA;        if (wm == null || wm.Ignore) return;&#xD;&#xA;        else _waymarks[wm.Type] = wm;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public string Jsonify()&#xD;&#xA;    {&#xD;&#xA;        var jsonList = _waymarks.Values.Where(wm =&gt; wm?.Ignore == false)&#xD;&#xA;            .Select(wm =&gt; &quot;    &quot; + wm.Jsonify()).ToList();&#xD;&#xA;        if (!Log)&#xD;&#xA;            jsonList.Add($&quot;    \&quot;Log\&quot;: false&quot;);&#xD;&#xA;        if (!LocalOnly)&#xD;&#xA;            jsonList.Add($&quot;    \&quot;LocalOnly\&quot;: false&quot;);&#xD;&#xA;        string data = string.Join(&quot;,\n&quot;, jsonList);&#xD;&#xA;        return $&quot;{{\n{string.Join(&quot;,\n&quot;, jsonList)}\n}}&quot;;&#xD;&#xA;    }&#xD;&#xA;    public override string ToString() =&gt; Jsonify();&#xD;&#xA;&#xD;&#xA;    public void Mark()&#xD;&#xA;    {&#xD;&#xA;        RealPlugin.plug.InvokeNamedCallback(&quot;place&quot;, this.Jsonify());&#xD;&#xA;        //RealPlugin.plug.InvokeNamedCallback(&quot;command&quot;, $&quot;/e {this}&quot;);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;#endregion Waymark(s)&#xD;&#xA;&#xD;&#xA;public static class WaymarksEncoder&#xD;&#xA;{&#xD;&#xA;    static bool IsSelfAnonymous =&gt; Interpreter.StaticHelpers.GetScalarVariable(true, &quot;AdvWm_Anonymous&quot;) != null;&#xD;&#xA;&#xD;&#xA;    private static int CoordToInt(float coord)&#xD;&#xA;    {&#xD;&#xA;        // 标点数据只有三位精度。&#xD;&#xA;        // float 在 ±16384 内时可保证第三位小数准确，小于这个阈值的最大 2^n / 1000 为 ±8388.608，恰好 24 bit&#xD;&#xA;        int encodedInt = (int)Round((double)coord * 1000);&#xD;&#xA;        if (encodedInt &lt; 0)            // -8388608 ~ -1&#xD;&#xA;            encodedInt += 0xFFFFFF;    // 转换为 8388608 (0x800000) ~ 16777215 (0xFFFFFF)&#xD;&#xA;        return encodedInt;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static float IntToCoord(int encodedInt) =&gt; (encodedInt &gt; 0x7FFFFF ? encodedInt - 0xFFFFFF : encodedInt) / 1000f;&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 通过 6 字节 int 解码 10XXXXXX ID &lt;/summary&gt;&#xD;&#xA;    static uint? CoordToId(float coord) =&gt; coord == 0 ? null : (uint?)(CoordToInt(coord) + 0x10000000);&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 将 id 编码为两个 3 字节精度的坐标：80.00 - 120.95 &lt;/summary&gt;&#xD;&#xA;    static (float, float) IdToCoords(uint id)&#xD;&#xA;    {&#xD;&#xA;        id -= 0x10000000;&#xD;&#xA;        return (80 + ((id &gt;&gt; 12) &amp; 0xFFF) / 100f, 80 + (id &amp; 0xFFF) / 100f);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 解码当前标点为文本，并检测发送者 &lt;/summary&gt;&#xD;&#xA;    public static void DecodeFromWaymarksAndShow()&#xD;&#xA;    {&#xD;&#xA;        List&lt;byte&gt; byteList = new List&lt;byte&gt;();&#xD;&#xA;        var waymarks = Triggernometry.Utilities.Memory.Waymarks.Read();&#xD;&#xA;        uint? senderId = CoordToId(waymarks.A.Z);&#xD;&#xA;        string senderDesc = &quot;Someone&quot;;&#xD;&#xA;        if (senderId != null)&#xD;&#xA;        {&#xD;&#xA;            var sender = BridgeFFXIV.GetIdEntity(senderId.Value.ToString(&quot;X&quot;));&#xD;&#xA;            senderDesc = $&quot;{sender.GetValue(&quot;name&quot;)} ({sender.GetValue(&quot;jobEN3&quot;)})&quot;;&#xD;&#xA;        }&#xD;&#xA;        foreach (var waymark in waymarks.Skip(1)) // 跳过用于表明密语消息的 A 点&#xD;&#xA;        {&#xD;&#xA;            if (!waymark.Active) break;&#xD;&#xA;            foreach (var coord in new[] { waymark.X, waymark.Y, waymark.Z })&#xD;&#xA;            {&#xD;&#xA;                int encodedInt = CoordToInt(coord);&#xD;&#xA;                // 从而将 ±8388.608 以内的 float 转换为 24 bit 数据，再分解为 3 字节&#xD;&#xA;                byteList.Add((byte)((encodedInt &gt;&gt; 16) &amp; 0xFF));   // 高8位&#xD;&#xA;                byteList.Add((byte)((encodedInt &gt;&gt; 8) &amp; 0xFF));    // 中8位&#xD;&#xA;                byteList.Add((byte)(encodedInt &amp; 0xFF));           // 低8位&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        string msg = Encoding.UTF8.GetString(byteList.ToArray());&#xD;&#xA;        AdvWm.Log($&quot;[AdvWm] Secret Message:\n{senderDesc} says:\n{msg}&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; 编码一串文本，以标点形式发送 &lt;/summary&gt;&#xD;&#xA;    public static void EncodeAndSendWaymarks(string msg, bool anonymous)&#xD;&#xA;    {&#xD;&#xA;        bool waymarkChkEnabled = true;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            waymarkChkEnabled = PostNamazuController.DetectAndEnableWaymarkChk();&#xD;&#xA;            byte[] byteArray = Encoding.UTF8.GetBytes(msg);&#xD;&#xA;            if (byteArray.Length &gt; 63)&#xD;&#xA;                throw new Exception(&quot;输入字符串过长，不能超过 63 字节。&quot;);&#xD;&#xA;&#xD;&#xA;            Array.Resize(ref byteArray, 63);&#xD;&#xA;&#xD;&#xA;            List&lt;int&gt; integers = new List&lt;int&gt;();&#xD;&#xA;            for (int i = 0; i &lt; 21; i++)&#xD;&#xA;            {&#xD;&#xA;                integers.Add((byteArray[i * 3] &lt;&lt; 16) | (byteArray[i * 3 + 1] &lt;&lt; 8) | (byteArray[i * 3 + 2]));&#xD;&#xA;            }&#xD;&#xA;            string advWm = $&quot;Local: false&quot;;&#xD;&#xA;            float az = anonymous ? 0 : IntToCoord((int)(BridgeFFXIV.PlayerId - 0x10000000));&#xD;&#xA;            advWm += $&quot;\nA: {0xFF14 / 1000f}, {0xFF14 / 1000f}, {az}&quot;;&#xD;&#xA;            string[] names = new string[] { &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; };&#xD;&#xA;            for (int i = 0; i &lt; 7; i++)&#xD;&#xA;            {&#xD;&#xA;                if (integers[i * 3] == 0 &amp;&amp; integers[i * 3 + 1] == 0 &amp;&amp; integers[i * 3 + 2] == 0)&#xD;&#xA;                    advWm += $&quot;\n{names[i]}: clear&quot;;&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    float x = IntToCoord(integers[i * 3]);&#xD;&#xA;                    float y = IntToCoord(integers[i * 3 + 1]);&#xD;&#xA;                    float z = IntToCoord(integers[i * 3 + 2]);&#xD;&#xA;                    advWm += $&quot;\n{names[i]}: {x}, {y}, {z}&quot;;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            RealPlugin.plug.InvokeNamedCallback(&quot;AdvWm&quot;, advWm);&#xD;&#xA;        }&#xD;&#xA;        catch (Exception e) { AdvWm.Log($&quot;发送失败：{e.Message}&quot;); }&#xD;&#xA;        finally { PostNamazuController.ResetWaymarkChk(waymarkChkEnabled); }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void Ask(bool wantAnonymous)&#xD;&#xA;        =&gt; AskOrAnswerByWaymarkA(0xFF14 / 1000f * (wantAnonymous ? -1 : 1), true);&#xD;&#xA;&#xD;&#xA;    public static void Answer()&#xD;&#xA;        =&gt; AskOrAnswerByWaymarkA(0.14f, false);&#xD;&#xA;&#xD;&#xA;    /// &lt;summary&gt; &#xD;&#xA;    /// 通过改变标点 A，发起关于谁在使用此工具箱的询问或应答。&#xD;&#xA;    /// x, y 各三字节精度，用于存储 ID；&#xD;&#xA;    /// z = ±0xff14 / 1000 代表发起询问（负值代表希望匿名）；±0.14 代表应答（负值代表没开启标点）。&#xD;&#xA;    /// &lt;/summary&gt;&#xD;&#xA;    private static void AskOrAnswerByWaymarkA(float z, bool isAsk)&#xD;&#xA;    {&#xD;&#xA;        bool waymarkChkEnabled = true;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            waymarkChkEnabled = PostNamazuController.DetectAndEnableWaymarkChk();&#xD;&#xA;            string advWm = $&quot;Local: false&quot;;&#xD;&#xA;            (float ax, float ay) = IdToCoords(BridgeFFXIV.PlayerId);&#xD;&#xA;            if (IsSelfAnonymous) // real anonymous&#xD;&#xA;                (ax, ay) = (80, 80);&#xD;&#xA;            if (!isAsk &amp;&amp; !waymarkChkEnabled)&#xD;&#xA;                z *= -1;&#xD;&#xA;            advWm += $&quot;\nA: {ax}, {ay}, {z}&quot;;&#xD;&#xA;            RealPlugin.plug.InvokeNamedCallback(&quot;AdvWm&quot;, advWm);&#xD;&#xA;        }&#xD;&#xA;        catch (Exception e) { AdvWm.Log($&quot;发送失败：{e.Message}&quot;); }&#xD;&#xA;        finally { PostNamazuController.ResetWaymarkChk(waymarkChkEnabled); }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void GetUsersResult()&#xD;&#xA;    {&#xD;&#xA;        var users = Interpreter.StaticHelpers.GetListVariable(false, &quot;AdvWm_users&quot;)?.Values?.Select(v =&gt; new UserEntry(v.ToString())).ToList();&#xD;&#xA;        if (users == null) return;&#xD;&#xA;        var ask = users?.FirstOrDefault(u =&gt; u.Asked);&#xD;&#xA;        // 查询者非自己且要求匿名时，不显示结果&#xD;&#xA;        if (ask?.Id != BridgeFFXIV.PlayerId &amp;&amp; (ask?.WantAnonymous ?? true) &amp;&amp; !IsSelfAnonymous) return;&#xD;&#xA;        var answers = users?.Where(u =&gt; !u.Asked).ToList();&#xD;&#xA;        string msg = $&quot;[AdvWm] 看看誰是挂友！&lt;se.10&gt;\nAsked by: \n  · {ask}\nUsers:\n  · {string.Join(&quot;\n  · &quot;, answers)}&quot;;&#xD;&#xA;        AdvWm.Log(msg);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public class UserEntry&#xD;&#xA;    {&#xD;&#xA;        public uint Id;&#xD;&#xA;        public float Z;&#xD;&#xA;        public bool Asked =&gt; Abs(Abs(Z) - 0xFF14 / 1000f) &lt; 0.001;&#xD;&#xA;        public bool EnabledWaymark =&gt; Asked || Z &gt; 0;&#xD;&#xA;        public bool WantAnonymous =&gt; Asked &amp;&amp; Z &lt; 0;&#xD;&#xA;        /// &lt;summary&gt; 接收如 10ABCDEF, -0.14 的输入，前面是 id，后面是标点的 z 坐标&lt;/summary&gt;&#xD;&#xA;        public UserEntry(string data)&#xD;&#xA;        {&#xD;&#xA;            var d = data.Split(',');&#xD;&#xA;            Id = uint.Parse(d[0], System.Globalization.NumberStyles.HexNumber);&#xD;&#xA;            Z = float.Parse(d[1], System.Globalization.CultureInfo.InvariantCulture);&#xD;&#xA;        }&#xD;&#xA;        public override string ToString()&#xD;&#xA;        {&#xD;&#xA;            bool anonymous = IsSelfAnonymous ? false : WantAnonymous;&#xD;&#xA;            var entity = BridgeFFXIV.GetIdEntity(Id.ToString(&quot;X&quot;));&#xD;&#xA;            string str = anonymous ? &quot;&quot; : entity.GetValue(&quot;name&quot;).ToString();&#xD;&#xA;            if (str == &quot;&quot;)&#xD;&#xA;                str = &quot;匿名&quot;;&#xD;&#xA;            else&#xD;&#xA;                str += $&quot; ({entity.GetValue(&quot;jobEN3&quot;)})&quot;;&#xD;&#xA;            if (!EnabledWaymark)&#xD;&#xA;                str += &quot; [未使用標点]&quot;;&#xD;&#xA;            return str;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public static class PostNamazuController&#xD;&#xA;{&#xD;&#xA;    private static CheckBox _waymarkCbx;&#xD;&#xA;    private static CheckBox WaymarkCbx =&gt; _waymarkCbx ?? GetWayMarkCbx();&#xD;&#xA;    private static TabPage TabPage =&gt; RealPlugin.InstanceHook(null, &quot;PostNamazu.PostNamazu&quot;).TabPage;&#xD;&#xA;    private static CheckBox GetWayMarkCbx() =&gt; SearchWayMarkCbxIn(TabPage);&#xD;&#xA;    private static CheckBox SearchWayMarkCbxIn(Control parent)&#xD;&#xA;    {&#xD;&#xA;        foreach (Control ctrl in parent.Controls)&#xD;&#xA;        {&#xD;&#xA;            if (ctrl is CheckBox checkBox &amp;&amp; checkBox.Text.ToLower() == &quot;waymark&quot;)&#xD;&#xA;            {&#xD;&#xA;                return checkBox;&#xD;&#xA;            }&#xD;&#xA;            else if (ctrl?.HasChildren == true)&#xD;&#xA;            {&#xD;&#xA;                CheckBox foundCbx = SearchWayMarkCbxIn(ctrl);&#xD;&#xA;                if (foundCbx != null) return foundCbx;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return null;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static bool DetectAndEnableWaymarkChk()&#xD;&#xA;    {&#xD;&#xA;        if (WaymarkCbx.InvokeRequired)&#xD;&#xA;        {&#xD;&#xA;            return (bool)WaymarkCbx.Invoke(new Func&lt;bool&gt;(DetectAndEnableWaymarkChk));&#xD;&#xA;        }&#xD;&#xA;        bool current = WaymarkCbx.Checked;&#xD;&#xA;        if (WaymarkCbx.Checked == false)&#xD;&#xA;            WaymarkCbx.Checked = true;&#xD;&#xA;        return current;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public static void ResetWaymarkChk(bool previousChecked)&#xD;&#xA;    {&#xD;&#xA;        if (WaymarkCbx.InvokeRequired)&#xD;&#xA;        {&#xD;&#xA;            WaymarkCbx.Invoke(new Action&lt;bool&gt;(ResetWaymarkChk), previousChecked);&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;        if (!previousChecked) WaymarkCbx.Checked = false;&#xD;&#xA;    }&#xD;&#xA;}" ActionType="ExecuteScript" Description="【代码】" DescBgColor="acf" DescriptionOverride="True" />
<Action OrderNumber="2" LogMessageText="AdvWm_Init" LogProcess="True" ActionType="LogMessage">
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:AdvWm}" ExpressionTypeL="String" ExpressionR="1" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Action>
<Action OrderNumber="3" FolderId="b7183948-e655-468b-93aa-e5904c51c20b" TriggerOp="EnableTrigger" TriggerId="4c0e265f-171b-42db-9d05-d0f0c0335d48" ActionType="Folder" />
<Action OrderNumber="4" FolderId="ba765f3e-d2ee-4a1d-b91b-8380ff917f40" TriggerOp="EnableTrigger" TriggerId="4c0e265f-171b-42db-9d05-d0f0c0335d48" ActionType="Folder" />
<Action OrderNumber="5" FolderId="fdecf75b-43b3-43d2-b506-64324dc650c1" TriggerOp="EnableTrigger" TriggerId="4c0e265f-171b-42db-9d05-d0f0c0335d48" ActionType="Folder" />
<Action OrderNumber="6" TriggerOp="EnableTrigger" TriggerId="4c0e265f-171b-42db-9d05-d0f0c0335d48" ActionType="Trigger" />
<Action OrderNumber="7" TriggerOp="EnableTrigger" TriggerId="48910e13-c80c-4f9b-a0bc-33e386c8ac2b" ActionType="Trigger" />
<Action OrderNumber="8" TriggerOp="EnableTrigger" TriggerId="311f3835-2184-4b1a-b8a0-71bb404a4a0f" ActionType="Trigger" />
</Actions>
<Condition Enabled="true" Grouping="Or">
<ConditionSingle Enabled="true" ExpressionL="${ecallback:AdvWm}" ExpressionTypeL="String" ExpressionR="0" ExpressionTypeR="String" ConditionType="StringEqualCase" />
</Condition>
</Trigger>
<Trigger Enabled="true" Sequential="True" Name="2. 消息文本" Id="622e7956-7712-4c9e-9bd2-92d5a4ce3b85" RegularExpression="^AdvWm_Init">
<Actions>
<Action OrderNumber="1" NamedCallbackName="command" NamedCallbackParam="/e ${if: ${f:contain(&quot; &quot;):${_me.name}} ? &quot;已激活：高級標点工具箱&quot; : &quot;已启用：高级标点工具箱&quot; }&#xD;&#xA;AdvWm v${env:version} by 阿洛 MnFeN" ActionType="NamedCallback" />
</Actions>
</Trigger>
<Trigger Enabled="true" Name="场地标点：/e mk [正点半径] [斜点半径]?    如 &quot;/e mk 15&quot;  &quot;/e mk 18 10&quot;" Id="803ec462-ecb8-4619-9c72-01b796da24b3" RegularExpression="^.{15}\S+ 00:0038:: *mk +(?&lt;card&gt;[^ ]+)(?: +(?&lt;intercard&gt;[^ ]+))? *(?&lt;center&gt;@ *(?&lt;x0&gt;[^ ]+) +(?&lt;y0&gt;[^ ]+)(?: +(?&lt;z0&gt;[^ ]+))? *)?$">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="需求：高级标点工具箱，没有的在远程触发器 - 自检 里找" DescriptionOverride="True" />
<Action OrderNumber="2" NamedCallbackName="AdvWm" NamedCallbackParam="action: circle&#xD;&#xA;waymarks: ADCB&#xD;&#xA;r: ${card}&#xD;&#xA;center: ${n: ${x0} ?? 100}, ${n: ${y0} ?? 100}, ${n: ${z0} ?? ${_me.z}}" ActionType="NamedCallback" Asynchronous="False" Description="ABCD" DescriptionOverride="True" />
<Action OrderNumber="3" NamedCallbackName="AdvWm" NamedCallbackParam="action: circle&#xD;&#xA;waymarks: 4321&#xD;&#xA;θ: -3/4 * π&#xD;&#xA;r: (${intercard} ?? ${card})&#xD;&#xA;center: ${n: ${x0} ?? 100}, ${n: ${y0} ?? 100}, ${n: ${z0} ?? ${_me.z}}" Enabled="False" ActionType="NamedCallback" Asynchronous="False" Description="1234（北侧从左到右 4A1）" DescriptionOverride="True" />
<Action OrderNumber="4" NamedCallbackName="AdvWm" NamedCallbackParam="action: circle&#xD;&#xA;waymarks: 4321&#xD;&#xA;θ: -1/4 * π&#xD;&#xA;r: (${intercard} ?? ${card})&#xD;&#xA;center: ${n: ${x0} ?? 100}, ${n: ${y0} ?? 100}, ${n: ${z0} ?? ${_me.z}}" ActionType="NamedCallback" Asynchronous="False" Description="1234（北侧从左到右 1A2）" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Asynchronous="False" Description="应用本地标点（使全队可见）： " DescriptionOverride="True" />
<Action OrderNumber="6" NamedCallbackName="command" NamedCallbackParam="/waymark save 30" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="7" NamedCallbackName="command" NamedCallbackParam="/waymark preset 30" ActionType="NamedCallback" Asynchronous="False" />
<Action OrderNumber="8" LogMessageText="[00:00:00.000] 0 00:0038::mk 15 10" LogProcess="True" Enabled="False" ActionType="LogMessage" Description="如果解析插件真的完全不工作，双击这行在 mk 之后输入标点参数，右键测试这行（左面的对号不要点）" DescBgColor="fdd" DescTextColor="000" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</Folder>
</Folders>
<Triggers>
<Trigger Enabled="false" Source="None" Name="使用说明" Id="629af2e6-23b4-4d33-b964-8aa4568b126a" RegularExpression="">
<Actions>
<Action OrderNumber="1" ActionType="Placeholder" Asynchronous="False" Description="　用户不需要、也不应改变或执行任何触发器，仅需要保持分组开启即可。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="2" ActionType="Placeholder" Asynchronous="False" Description="　如果你是普通用户，无需阅读下面的内容。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="3" ActionType="Placeholder" Asynchronous="False" Description="　本工具箱包含以下内容：" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="4" ActionType="Placeholder" Asynchronous="False" Description="高级标点工具箱（新版）" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="5" ActionType="Placeholder" Asynchronous="False" Description="  在切换区域（包括 ACT 与游戏之一运行时开启另一个）时向触发器程序注册回调" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="6" ActionType="Placeholder" Asynchronous="False" Description="  用户可以直接使用具名回调操作 “AdvWm” 触发。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="7" LaunchProcessPathExpression="https://github.com/MnFeN/ACT_Tech_Guide" ActionType="LaunchProcess" Description="· 右键 - 测试动作 打开说明文档链接（GitHub）" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="8" NamedCallbackName="AdvWm" NamedCallbackParam="// 左侧箭头可以展开为多行模式&#xD;&#xA;// 双斜线开始的行会当做为注释行，和空行一起被忽略&#xD;&#xA;// 所有参数的顺序不重要，每行提供一个参数&#xD;&#xA;&#xD;&#xA;// 采用日志中的坐标系，即正东 x+，正南 y+，正上 z+&#xD;&#xA;// 角度从正北开始逆时针递增，如 北 西 南 东 分别为： ±π, -π/2, 0, π/2&#xD;&#xA;&#xD;&#xA;// 必须参数：action，代表标点模式&#xD;&#xA;// place 模式下允许你输入一组相对坐标&#xD;&#xA;action: place&#xD;&#xA;&#xD;&#xA;// 可选参数：scaleX scaleY scaleZ：坐标在各个方向上的缩放尺度，负数即为反向&#xD;&#xA;// 未提供时的默认值：均为 1&#xD;&#xA;scaleX: 2&#xD;&#xA;scaleY: -2&#xD;&#xA;// 如果尺度相同，可以使用 scale: 2 简化&#xD;&#xA;&#xD;&#xA;// 可选参数 θ：旋转角度，可以理解为将这个相对坐标系的正北旋转至哪个绝对方向&#xD;&#xA;// 未提供时的默认值：-π （将正北旋转至正北，即未旋转）&#xD;&#xA;θ: π/2&#xD;&#xA;// 也可以写作角度，如 θ: 90°&#xD;&#xA;&#xD;&#xA;// 可选参数 center：中心坐标&#xD;&#xA;// 下方演示的是使用触发器的实体查询功能获取并填入自身坐标&#xD;&#xA;// 未提供时的默认值：0, 0, 0&#xD;&#xA;center: ${_me.x}, ${_me.y}, ${_me.z}&#xD;&#xA;&#xD;&#xA;// 提供的坐标首先经过缩放变换，其次经过平面旋转，最后平移至中心坐标&#xD;&#xA;&#xD;&#xA;// 下方给出所有相对坐标：&#xD;&#xA;A: 0, -4, 0&#xD;&#xA;// z = 0 可以省略：&#xD;&#xA;B: 4, -4&#xD;&#xA;// 也可以使用极坐标模式：polar [r], [θ]：&#xD;&#xA;C: polar 4, 90°&#xD;&#xA;// 也可以结合两种模式，以平面直角坐标系下的坐标为中心进一步添加一个极坐标系的偏移：&#xD;&#xA;D: 0, 4 polar 2, 30°&#xD;&#xA;// 清除一个标点：&#xD;&#xA;1: clear&#xD;&#xA;// “清除”一个标点，实为移动到看不见的位置，使之下次出现时没有淡入动画：&#xD;&#xA;2: fakeclear&#xD;&#xA;// 没有提供的标点会被忽略，保持标点的原状态&#xD;&#xA;// 3:... 4:...&#xD;&#xA;&#xD;&#xA;// 三条 hyphen 连字符为分隔线，代表另起一条指令，所有指令依次执行&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;// circle 模式下通过给定的圆心和半径将所有点标记在圆周的等分位置&#xD;&#xA;action: circle&#xD;&#xA;&#xD;&#xA;// 必须参数：waymarks，从正北开始所有的标点&#xD;&#xA;// 可以使用 _ 表示这个位置依旧需要等分，但是并不放置一个标点，如下面代表八等分圆但正南不标点&#xD;&#xA;waymarks: ABCD_234&#xD;&#xA;&#xD;&#xA;// 必须参数：r，半径&#xD;&#xA;r: 5&#xD;&#xA;&#xD;&#xA;// 必须参数：center 圆心坐标&#xD;&#xA;center: ${_me.x}, ${_me.y}, ${_me.z}&#xD;&#xA;&#xD;&#xA;// 可选参数：θ，与 place 中类似&#xD;&#xA;θ: -π&#xD;&#xA;&#xD;&#xA;// linear（连接两个点）和 arc（朝某个方向标记圆弧）指令还没写介绍，有兴趣可以看代码&#xD;&#xA;" ActionType="NamedCallback" Description="· 也可双击这行查看一小段简短说明" DescBgColor="f0f8ff" DescTextColor="2a8" DescriptionOverride="True" />
<Action OrderNumber="9" ActionType="Placeholder" Asynchronous="False" Description="  此外，你可以使用指令：/e pl/place A/B/C/D/1/2/3/4 [x] [y] [z] 放置标点。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="10" ActionType="Placeholder" Asynchronous="False" Description="  坐标参数均为可选，不提供时用自身坐标，如 /e pl A 将 A 点放在自己脚下。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="11" ActionType="Placeholder" Asynchronous="False" Description="高级标点工具箱（旧版）" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="12" ActionType="Placeholder" Asynchronous="False" Description="　旧版本，使用固定格式的日志触发标点，已弃用，但触发器依然保留以兼容旧版科技。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="13" ActionType="Placeholder" Asynchronous="False" Description="鲶鱼精邮差扩展" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="14" ActionType="Placeholder" Asynchronous="False" Description="　详见【鲶鱼精邮差扩展】文件夹。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="15" ActionType="Placeholder" Asynchronous="False" Description="　CafeACT 无法使用。建议更换呆萌。" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="16" ActionType="Placeholder" Asynchronous="False" Description="关于" DescBgColor="acf" DescTextColor="248" DescriptionOverride="True" />
<Action OrderNumber="17" ActionType="Placeholder" Asynchronous="False" Description="　作者：MnFeN 阿洛" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
<Action OrderNumber="18" ActionType="Placeholder" Asynchronous="False" Description="　致谢：AtmoOmen　　Fragile　　Latihias　　Natsukage　　Small-Miao" DescBgColor="f0f8ff" DescTextColor="234" DescriptionOverride="True" />
</Actions>
</Trigger>
</Triggers>
</ExportedFolder>
</TriggernometryExport>